{
    "0.21rc2": {
        "sklearn.dummy": {
            "DummyClassifier": {
                "__init__": [
                    "self",
                    "strategy",
                    "random_state",
                    "constant"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "DummyRegressor": {
                "__init__": [
                    "self",
                    "strategy",
                    "constant",
                    "quantile"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X",
                    "return_std"
                ],
                "_more_tags": [
                    "self"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            }
        },
        "sklearn.random_projection": {
            "johnson_lindenstrauss_min_dim": [
                "n_samples",
                "eps"
            ],
            "_check_density": [
                "density",
                "n_features"
            ],
            "_check_input_size": [
                "n_components",
                "n_features"
            ],
            "gaussian_random_matrix": [
                "n_components",
                "n_features",
                "random_state"
            ],
            "sparse_random_matrix": [
                "n_components",
                "n_features",
                "density",
                "random_state"
            ],
            "BaseRandomProjection": {
                "__init__": [
                    "self",
                    "n_components",
                    "eps",
                    "dense_output",
                    "random_state"
                ],
                "_make_random_matrix": [
                    "self",
                    "n_components",
                    "n_features"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "GaussianRandomProjection": {
                "__init__": [
                    "self",
                    "n_components",
                    "eps",
                    "random_state"
                ],
                "_make_random_matrix": [
                    "self",
                    "n_components",
                    "n_features"
                ]
            },
            "SparseRandomProjection": {
                "__init__": [
                    "self",
                    "n_components",
                    "density",
                    "eps",
                    "dense_output",
                    "random_state"
                ],
                "_make_random_matrix": [
                    "self",
                    "n_components",
                    "n_features"
                ]
            }
        },
        "sklearn.kernel_ridge": {
            "KernelRidge": {
                "__init__": [
                    "self",
                    "alpha",
                    "kernel",
                    "gamma",
                    "degree",
                    "coef0",
                    "kernel_params"
                ],
                "_get_kernel": [
                    "self",
                    "X",
                    "Y"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.multioutput": {
            "_fit_estimator": [
                "estimator",
                "X",
                "y",
                "sample_weight"
            ],
            "_partial_fit_estimator": [
                "estimator",
                "X",
                "y",
                "classes",
                "sample_weight",
                "first_time"
            ],
            "MultiOutputEstimator": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MultiOutputRegressor": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "MultiOutputClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "_BaseChain": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "order",
                    "cv",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "ClassifierChain": {
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "RegressorChain": {
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.naive_bayes": {
            "BaseNB": {
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "GaussianNB": {
                "__init__": [
                    "self",
                    "priors",
                    "var_smoothing"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_update_mean_variance": [
                    "n_past",
                    "mu",
                    "var",
                    "X",
                    "sample_weight"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "sample_weight"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "_refit",
                    "sample_weight"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            },
            "BaseDiscreteNB": {
                "_update_class_log_prior": [
                    "self",
                    "class_prior"
                ],
                "_check_alpha": [
                    "self"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_get_coef": [
                    "self"
                ],
                "_get_intercept": [
                    "self"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MultinomialNB": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_prior",
                    "class_prior"
                ],
                "_count": [
                    "self",
                    "X",
                    "Y"
                ],
                "_update_feature_log_prob": [
                    "self",
                    "alpha"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            },
            "ComplementNB": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_prior",
                    "class_prior",
                    "norm"
                ],
                "_count": [
                    "self",
                    "X",
                    "Y"
                ],
                "_update_feature_log_prob": [
                    "self",
                    "alpha"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            },
            "BernoulliNB": {
                "__init__": [
                    "self",
                    "alpha",
                    "binarize",
                    "fit_prior",
                    "class_prior"
                ],
                "_count": [
                    "self",
                    "X",
                    "Y"
                ],
                "_update_feature_log_prob": [
                    "self",
                    "alpha"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn": {
            "setup_module": [
                "module"
            ]
        },
        "sklearn.calibration": {
            "_sigmoid_calibration": [
                "df",
                "y",
                "sample_weight"
            ],
            "calibration_curve": [
                "y_true",
                "y_prob",
                "normalize",
                "n_bins",
                "strategy"
            ],
            "CalibratedClassifierCV": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "method",
                    "cv"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "_CalibratedClassifier": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "method",
                    "classes"
                ],
                "_preproc": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "_SigmoidCalibration": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "T"
                ]
            }
        },
        "sklearn.impute": {
            "_check_inputs_dtype": [
                "X",
                "missing_values"
            ],
            "_get_mask": [
                "X",
                "value_to_mask"
            ],
            "_most_frequent": [
                "array",
                "extra_value",
                "n_repeat"
            ],
            "SimpleImputer": {
                "__init__": [
                    "self",
                    "missing_values",
                    "strategy",
                    "fill_value",
                    "verbose",
                    "copy",
                    "add_indicator"
                ],
                "_validate_input": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_sparse_fit": [
                    "self",
                    "X",
                    "strategy",
                    "missing_values",
                    "fill_value"
                ],
                "_dense_fit": [
                    "self",
                    "X",
                    "strategy",
                    "missing_values",
                    "fill_value"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "IterativeImputer": {
                "__init__": [
                    "self",
                    "estimator",
                    "missing_values",
                    "sample_posterior",
                    "max_iter",
                    "tol",
                    "n_nearest_features",
                    "initial_strategy",
                    "imputation_order",
                    "min_value",
                    "max_value",
                    "verbose",
                    "random_state",
                    "add_indicator"
                ],
                "_impute_one_feature": [
                    "self",
                    "X_filled",
                    "mask_missing_values",
                    "feat_idx",
                    "neighbor_feat_idx",
                    "estimator",
                    "fit_mode"
                ],
                "_get_neighbor_feat_idx": [
                    "self",
                    "n_features",
                    "feat_idx",
                    "abs_corr_mat"
                ],
                "_get_ordered_idx": [
                    "self",
                    "mask_missing_values"
                ],
                "_get_abs_corr_mat": [
                    "self",
                    "X_filled",
                    "tolerance"
                ],
                "_initial_imputation": [
                    "self",
                    "X"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MissingIndicator": {
                "__init__": [
                    "self",
                    "missing_values",
                    "features",
                    "sparse",
                    "error_on_new"
                ],
                "_get_missing_features_info": [
                    "self",
                    "X"
                ],
                "_validate_input": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.isotonic": {
            "check_increasing": [
                "x",
                "y"
            ],
            "isotonic_regression": [
                "y",
                "sample_weight",
                "y_min",
                "y_max",
                "increasing"
            ],
            "IsotonicRegression": {
                "__init__": [
                    "self",
                    "y_min",
                    "y_max",
                    "increasing",
                    "out_of_bounds"
                ],
                "_check_fit_data": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_build_f": [
                    "self",
                    "X",
                    "y"
                ],
                "_build_y": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "trim_duplicates"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "transform": [
                    "self",
                    "T"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "__getstate__": [
                    "self"
                ],
                "__setstate__": [
                    "self",
                    "state"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.exceptions": {
            "NotFittedError": {},
            "ChangedBehaviorWarning": {},
            "ConvergenceWarning": {},
            "DataConversionWarning": {},
            "DataDimensionalityWarning": {},
            "EfficiencyWarning": {},
            "FitFailedWarning": {},
            "NonBLASDotWarning": {},
            "SkipTestWarning": {},
            "UndefinedMetricWarning": {}
        },
        "sklearn.multiclass": {
            "_fit_binary": [
                "estimator",
                "X",
                "y",
                "classes"
            ],
            "_partial_fit_binary": [
                "estimator",
                "X",
                "y"
            ],
            "_predict_binary": [
                "estimator",
                "X"
            ],
            "_check_estimator": [
                "estimator"
            ],
            "_fit_ovo_binary": [
                "estimator",
                "X",
                "y",
                "i",
                "j"
            ],
            "_partial_fit_ovo_binary": [
                "estimator",
                "X",
                "y",
                "i",
                "j"
            ],
            "_ConstantPredictor": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "OneVsRestClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "multilabel_": [
                    "self"
                ],
                "n_classes_": [
                    "self"
                ],
                "coef_": [
                    "self"
                ],
                "intercept_": [
                    "self"
                ],
                "_pairwise": [
                    "self"
                ],
                "_first_estimator": [
                    "self"
                ]
            },
            "OneVsOneClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "n_classes_": [
                    "self"
                ],
                "_pairwise": [
                    "self"
                ]
            },
            "OutputCodeClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "code_size",
                    "random_state",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.discriminant_analysis": {
            "_cov": [
                "X",
                "shrinkage"
            ],
            "_class_means": [
                "X",
                "y"
            ],
            "_class_cov": [
                "X",
                "y",
                "priors",
                "shrinkage"
            ],
            "LinearDiscriminantAnalysis": {
                "__init__": [
                    "self",
                    "solver",
                    "shrinkage",
                    "priors",
                    "n_components",
                    "store_covariance",
                    "tol"
                ],
                "_solve_lsqr": [
                    "self",
                    "X",
                    "y",
                    "shrinkage"
                ],
                "_solve_eigen": [
                    "self",
                    "X",
                    "y",
                    "shrinkage"
                ],
                "_solve_svd": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "QuadraticDiscriminantAnalysis": {
                "__init__": [
                    "self",
                    "priors",
                    "reg_param",
                    "store_covariance",
                    "tol"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.base": {
            "clone": [
                "estimator",
                "safe"
            ],
            "_pprint": [
                "params",
                "offset",
                "printer"
            ],
            "_update_if_consistent": [
                "dict1",
                "dict2"
            ],
            "is_classifier": [
                "estimator"
            ],
            "is_regressor": [
                "estimator"
            ],
            "is_outlier_detector": [
                "estimator"
            ],
            "BaseEstimator": {
                "_get_param_names": [
                    "cls"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ],
                "__repr__": [
                    "self",
                    "N_CHAR_MAX"
                ],
                "__getstate__": [
                    "self"
                ],
                "__setstate__": [
                    "self",
                    "state"
                ],
                "_get_tags": [
                    "self"
                ]
            },
            "ClassifierMixin": {
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "RegressorMixin": {
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "ClusterMixin": {
                "fit_predict": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "BiclusterMixin": {
                "biclusters_": [
                    "self"
                ],
                "get_indices": [
                    "self",
                    "i"
                ],
                "get_shape": [
                    "self",
                    "i"
                ],
                "get_submatrix": [
                    "self",
                    "i",
                    "data"
                ]
            },
            "TransformerMixin": {
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "DensityMixin": {
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "OutlierMixin": {
                "fit_predict": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "MetaEstimatorMixin": {},
            "MultiOutputMixin": {
                "_more_tags": [
                    "self"
                ]
            },
            "_UnstableArchMixin": {
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.kernel_approximation": {
            "RBFSampler": {
                "__init__": [
                    "self",
                    "gamma",
                    "n_components",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "SkewedChi2Sampler": {
                "__init__": [
                    "self",
                    "skewedness",
                    "n_components",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "AdditiveChi2Sampler": {
                "__init__": [
                    "self",
                    "sample_steps",
                    "sample_interval"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_transform_dense": [
                    "self",
                    "X"
                ],
                "_transform_sparse": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "Nystroem": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "coef0",
                    "degree",
                    "kernel_params",
                    "n_components",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_get_kernel_params": [
                    "self"
                ]
            }
        },
        "sklearn.pipeline": {
            "_name_estimators": [
                "estimators"
            ],
            "make_pipeline": [],
            "_transform_one": [
                "transformer",
                "X",
                "y",
                "weight"
            ],
            "_fit_transform_one": [
                "transformer",
                "X",
                "y",
                "weight",
                "message_clsname",
                "message"
            ],
            "_fit_one": [
                "transformer",
                "X",
                "y",
                "weight",
                "message_clsname",
                "message"
            ],
            "make_union": [],
            "Pipeline": {
                "__init__": [
                    "self",
                    "steps",
                    "memory",
                    "verbose"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ],
                "_validate_steps": [
                    "self"
                ],
                "_iter": [
                    "self",
                    "with_final",
                    "filter_passthrough"
                ],
                "__len__": [
                    "self"
                ],
                "__getitem__": [
                    "self",
                    "ind"
                ],
                "_estimator_type": [
                    "self"
                ],
                "named_steps": [
                    "self"
                ],
                "_final_estimator": [
                    "self"
                ],
                "_log_message": [
                    "self",
                    "step_idx"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "fit_predict": [
                    "self",
                    "X",
                    "y"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self"
                ],
                "_transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self"
                ],
                "_inverse_transform": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "classes_": [
                    "self"
                ],
                "_pairwise": [
                    "self"
                ]
            },
            "FeatureUnion": {
                "__init__": [
                    "self",
                    "transformer_list",
                    "n_jobs",
                    "transformer_weights",
                    "verbose"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ],
                "_validate_transformers": [
                    "self"
                ],
                "_iter": [
                    "self"
                ],
                "get_feature_names": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_log_message": [
                    "self",
                    "name",
                    "idx",
                    "total"
                ],
                "_parallel_func": [
                    "self",
                    "X",
                    "y",
                    "fit_params",
                    "func"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_update_transformer_list": [
                    "self",
                    "transformers"
                ]
            }
        },
        "sklearn._config": {
            "get_config": [],
            "set_config": [
                "assume_finite",
                "working_memory",
                "print_changed_only"
            ],
            "config_context": []
        },
        "sklearn.semi_supervised.label_propagation": {
            "BaseLabelPropagation": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "n_neighbors",
                    "alpha",
                    "max_iter",
                    "tol",
                    "n_jobs"
                ],
                "_get_kernel": [
                    "self",
                    "X",
                    "y"
                ],
                "_build_graph": [
                    "self"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LabelPropagation": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "n_neighbors",
                    "max_iter",
                    "tol",
                    "n_jobs"
                ],
                "_build_graph": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LabelSpreading": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "n_neighbors",
                    "alpha",
                    "max_iter",
                    "tol",
                    "n_jobs"
                ],
                "_build_graph": [
                    "self"
                ]
            }
        },
        "sklearn.semi_supervised": {},
        "sklearn.semi_supervised.tests": {},
        "sklearn.semi_supervised.tests.test_label_propagation": {
            "test_fit_transduction": [],
            "test_distribution": [],
            "test_predict": [],
            "test_predict_proba": [],
            "test_label_spreading_closed_form": [],
            "test_label_propagation_closed_form": [],
            "test_valid_alpha": [],
            "test_convergence_speed": [],
            "test_convergence_warning": []
        },
        "sklearn.svm.bounds": {
            "l1_min_c": [
                "X",
                "y",
                "loss",
                "fit_intercept",
                "intercept_scaling"
            ]
        },
        "sklearn.svm.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.svm": {},
        "sklearn.svm.base": {
            "_one_vs_one_coef": [
                "dual_coef",
                "n_support",
                "support_vectors"
            ],
            "_get_liblinear_solver_type": [
                "multi_class",
                "penalty",
                "loss",
                "dual"
            ],
            "_fit_liblinear": [
                "X",
                "y",
                "C",
                "fit_intercept",
                "intercept_scaling",
                "class_weight",
                "penalty",
                "dual",
                "verbose",
                "max_iter",
                "tol",
                "random_state",
                "multi_class",
                "loss",
                "epsilon",
                "sample_weight"
            ],
            "BaseLibSVM": {
                "__init__": [
                    "self",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "C",
                    "nu",
                    "epsilon",
                    "shrinking",
                    "probability",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "random_state"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_validate_targets": [
                    "self",
                    "y"
                ],
                "_warn_from_fit_status": [
                    "self"
                ],
                "_dense_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "solver_type",
                    "kernel",
                    "random_seed"
                ],
                "_sparse_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "solver_type",
                    "kernel",
                    "random_seed"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_dense_predict": [
                    "self",
                    "X"
                ],
                "_sparse_predict": [
                    "self",
                    "X"
                ],
                "_compute_kernel": [
                    "self",
                    "X"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "_dense_decision_function": [
                    "self",
                    "X"
                ],
                "_sparse_decision_function": [
                    "self",
                    "X"
                ],
                "_validate_for_predict": [
                    "self",
                    "X"
                ],
                "coef_": [
                    "self"
                ],
                "_get_coef": [
                    "self"
                ]
            },
            "BaseSVC": {
                "__init__": [
                    "self",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "C",
                    "nu",
                    "shrinking",
                    "probability",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "decision_function_shape",
                    "random_state"
                ],
                "_validate_targets": [
                    "self",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_check_proba": [
                    "self"
                ],
                "predict_proba": [
                    "self"
                ],
                "_predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self"
                ],
                "_predict_log_proba": [
                    "self",
                    "X"
                ],
                "_dense_predict_proba": [
                    "self",
                    "X"
                ],
                "_sparse_predict_proba": [
                    "self",
                    "X"
                ],
                "_get_coef": [
                    "self"
                ]
            }
        },
        "sklearn.svm.classes": {
            "LinearSVC": {
                "__init__": [
                    "self",
                    "penalty",
                    "loss",
                    "dual",
                    "tol",
                    "C",
                    "multi_class",
                    "fit_intercept",
                    "intercept_scaling",
                    "class_weight",
                    "verbose",
                    "random_state",
                    "max_iter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "LinearSVR": {
                "__init__": [
                    "self",
                    "epsilon",
                    "tol",
                    "C",
                    "loss",
                    "fit_intercept",
                    "intercept_scaling",
                    "dual",
                    "verbose",
                    "random_state",
                    "max_iter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "SVC": {
                "__init__": [
                    "self",
                    "C",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "probability",
                    "tol",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "decision_function_shape",
                    "random_state"
                ]
            },
            "NuSVC": {
                "__init__": [
                    "self",
                    "nu",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "probability",
                    "tol",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "decision_function_shape",
                    "random_state"
                ]
            },
            "SVR": {
                "__init__": [
                    "self",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "C",
                    "epsilon",
                    "shrinking",
                    "cache_size",
                    "verbose",
                    "max_iter"
                ]
            },
            "NuSVR": {
                "__init__": [
                    "self",
                    "nu",
                    "C",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "tol",
                    "cache_size",
                    "verbose",
                    "max_iter"
                ]
            },
            "OneClassSVM": {
                "__init__": [
                    "self",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "nu",
                    "shrinking",
                    "cache_size",
                    "verbose",
                    "max_iter",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.svm.tests.test_bounds": {
            "test_l1_min_c": [
                "loss",
                "X_label",
                "Y_label",
                "intercept_label"
            ],
            "test_l1_min_c_l2_loss": [],
            "check_l1_min_c": [
                "X",
                "y",
                "loss",
                "fit_intercept",
                "intercept_scaling"
            ],
            "test_ill_posed_min_c": [],
            "test_unsupported_loss": []
        },
        "sklearn.svm.tests": {},
        "sklearn.svm.tests.test_sparse": {
            "check_svm_model_equal": [
                "dense_svm",
                "sparse_svm",
                "X_train",
                "y_train",
                "X_test"
            ],
            "test_svc": [],
            "test_unsorted_indices": [],
            "test_svc_with_custom_kernel": [],
            "test_svc_iris": [],
            "test_sparse_decision_function": [],
            "test_error": [],
            "test_linearsvc": [],
            "test_linearsvc_iris": [],
            "test_weight": [],
            "test_sample_weights": [],
            "test_sparse_liblinear_intercept_handling": [],
            "test_sparse_oneclasssvm": [
                "datasets_index",
                "kernel"
            ],
            "test_sparse_realdata": [],
            "test_sparse_svc_clone_with_callable_kernel": [],
            "test_timeout": [],
            "test_consistent_proba": []
        },
        "sklearn.svm.tests.test_svm": {
            "test_libsvm_parameters": [],
            "test_libsvm_iris": [],
            "test_precomputed": [],
            "test_svr": [],
            "test_linearsvr": [],
            "test_linearsvr_fit_sampleweight": [],
            "test_svr_errors": [],
            "test_oneclass": [],
            "test_oneclass_decision_function": [],
            "test_oneclass_score_samples": [],
            "test_tweak_params": [],
            "test_probability": [],
            "test_decision_function": [],
            "test_decision_function_shape": [],
            "test_svr_predict": [],
            "test_weight": [],
            "test_sample_weights": [],
            "test_auto_weight": [],
            "test_bad_input": [],
            "test_unicode_kernel": [],
            "test_sparse_precomputed": [],
            "test_linearsvc_parameters": [],
            "test_linearsvx_loss_penalty_deprecations": [],
            "test_linear_svx_uppercase_loss_penality_raises_error": [],
            "test_linearsvc": [],
            "test_linearsvc_crammer_singer": [],
            "test_linearsvc_fit_sampleweight": [],
            "test_crammer_singer_binary": [],
            "test_linearsvc_iris": [],
            "test_dense_liblinear_intercept_handling": [
                "classifier"
            ],
            "test_liblinear_set_coef": [],
            "test_immutable_coef_property": [],
            "test_linearsvc_verbose": [],
            "test_svc_clone_with_callable_kernel": [],
            "test_svc_bad_kernel": [],
            "test_timeout": [],
            "test_unfitted": [],
            "test_consistent_proba": [],
            "test_linear_svm_convergence_warnings": [],
            "test_svr_coef_sign": [],
            "test_linear_svc_intercept_scaling": [],
            "test_lsvc_intercept_scaling_zero": [],
            "test_hasattr_predict_proba": [],
            "test_decision_function_shape_two_class": [],
            "test_ovr_decision_function": [],
            "test_gamma_auto": [],
            "test_gamma_scale": []
        },
        "sklearn.decomposition.truncated_svd": {
            "TruncatedSVD": {
                "__init__": [
                    "self",
                    "n_components",
                    "algorithm",
                    "n_iter",
                    "random_state",
                    "tol"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.decomposition.pca": {
            "_assess_dimension_": [
                "spectrum",
                "rank",
                "n_samples",
                "n_features"
            ],
            "_infer_dimension_": [
                "spectrum",
                "n_samples",
                "n_features"
            ],
            "PCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "copy",
                    "whiten",
                    "svd_solver",
                    "tol",
                    "iterated_power",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "_fit_full": [
                    "self",
                    "X",
                    "n_components"
                ],
                "_fit_truncated": [
                    "self",
                    "X",
                    "n_components",
                    "svd_solver"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.decomposition.sparse_pca": {
            "SparsePCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "ridge_alpha",
                    "max_iter",
                    "tol",
                    "method",
                    "n_jobs",
                    "U_init",
                    "V_init",
                    "verbose",
                    "random_state",
                    "normalize_components"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "MiniBatchSparsePCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "ridge_alpha",
                    "n_iter",
                    "callback",
                    "batch_size",
                    "verbose",
                    "shuffle",
                    "n_jobs",
                    "method",
                    "random_state",
                    "normalize_components"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.decomposition.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.decomposition": {},
        "sklearn.decomposition.kernel_pca": {
            "KernelPCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "kernel",
                    "gamma",
                    "degree",
                    "coef0",
                    "kernel_params",
                    "alpha",
                    "fit_inverse_transform",
                    "eigen_solver",
                    "tol",
                    "max_iter",
                    "remove_zero_eig",
                    "random_state",
                    "copy_X",
                    "n_jobs"
                ],
                "_pairwise": [
                    "self"
                ],
                "_get_kernel": [
                    "self",
                    "X",
                    "Y"
                ],
                "_fit_transform": [
                    "self",
                    "K"
                ],
                "_fit_inverse_transform": [
                    "self",
                    "X_transformed",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.decomposition.factor_analysis": {
            "FactorAnalysis": {
                "__init__": [
                    "self",
                    "n_components",
                    "tol",
                    "copy",
                    "max_iter",
                    "noise_variance_init",
                    "svd_method",
                    "iterated_power",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "get_covariance": [
                    "self"
                ],
                "get_precision": [
                    "self"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.decomposition.base": {
            "_BasePCA": {
                "get_covariance": [
                    "self"
                ],
                "get_precision": [
                    "self"
                ],
                "fit": [
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.decomposition.dict_learning": {
            "_sparse_encode": [
                "X",
                "dictionary",
                "gram",
                "cov",
                "algorithm",
                "regularization",
                "copy_cov",
                "init",
                "max_iter",
                "check_input",
                "verbose",
                "positive"
            ],
            "sparse_encode": [
                "X",
                "dictionary",
                "gram",
                "cov",
                "algorithm",
                "n_nonzero_coefs",
                "alpha",
                "copy_cov",
                "init",
                "max_iter",
                "n_jobs",
                "check_input",
                "verbose",
                "positive"
            ],
            "_update_dict": [
                "dictionary",
                "Y",
                "code",
                "verbose",
                "return_r2",
                "random_state",
                "positive"
            ],
            "dict_learning": [
                "X",
                "n_components",
                "alpha",
                "max_iter",
                "tol",
                "method",
                "n_jobs",
                "dict_init",
                "code_init",
                "callback",
                "verbose",
                "random_state",
                "return_n_iter",
                "positive_dict",
                "positive_code"
            ],
            "dict_learning_online": [
                "X",
                "n_components",
                "alpha",
                "n_iter",
                "return_code",
                "dict_init",
                "callback",
                "batch_size",
                "verbose",
                "shuffle",
                "n_jobs",
                "method",
                "iter_offset",
                "random_state",
                "return_inner_stats",
                "inner_stats",
                "return_n_iter",
                "positive_dict",
                "positive_code"
            ],
            "SparseCodingMixin": {
                "_set_sparse_coding_params": [
                    "self",
                    "n_components",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "split_sign",
                    "n_jobs",
                    "positive_code"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "SparseCoder": {
                "__init__": [
                    "self",
                    "dictionary",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "split_sign",
                    "n_jobs",
                    "positive_code"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "DictionaryLearning": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "max_iter",
                    "tol",
                    "fit_algorithm",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "n_jobs",
                    "code_init",
                    "dict_init",
                    "verbose",
                    "split_sign",
                    "random_state",
                    "positive_code",
                    "positive_dict"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "MiniBatchDictionaryLearning": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "n_iter",
                    "fit_algorithm",
                    "n_jobs",
                    "batch_size",
                    "shuffle",
                    "dict_init",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "verbose",
                    "split_sign",
                    "random_state",
                    "positive_code",
                    "positive_dict"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "iter_offset"
                ]
            }
        },
        "sklearn.decomposition.incremental_pca": {
            "IncrementalPCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "whiten",
                    "copy",
                    "batch_size"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "check_input"
                ]
            }
        },
        "sklearn.decomposition.online_lda": {
            "_update_doc_distribution": [
                "X",
                "exp_topic_word_distr",
                "doc_topic_prior",
                "max_iters",
                "mean_change_tol",
                "cal_sstats",
                "random_state"
            ],
            "LatentDirichletAllocation": {
                "__init__": [
                    "self",
                    "n_components",
                    "doc_topic_prior",
                    "topic_word_prior",
                    "learning_method",
                    "learning_decay",
                    "learning_offset",
                    "max_iter",
                    "batch_size",
                    "evaluate_every",
                    "total_samples",
                    "perp_tol",
                    "mean_change_tol",
                    "max_doc_update_iter",
                    "n_jobs",
                    "verbose",
                    "random_state"
                ],
                "_check_params": [
                    "self"
                ],
                "_init_latent_vars": [
                    "self",
                    "n_features"
                ],
                "_e_step": [
                    "self",
                    "X",
                    "cal_sstats",
                    "random_init",
                    "parallel"
                ],
                "_em_step": [
                    "self",
                    "X",
                    "total_samples",
                    "batch_update",
                    "parallel"
                ],
                "_check_non_neg_array": [
                    "self",
                    "X",
                    "whom"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_unnormalized_transform": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_approx_bound": [
                    "self",
                    "X",
                    "doc_topic_distr",
                    "sub_sampling"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_perplexity_precomp_distr": [
                    "self",
                    "X",
                    "doc_topic_distr",
                    "sub_sampling"
                ],
                "perplexity": [
                    "self",
                    "X",
                    "sub_sampling"
                ]
            }
        },
        "sklearn.decomposition.fastica_": {
            "_gs_decorrelation": [
                "w",
                "W",
                "j"
            ],
            "_sym_decorrelation": [
                "W"
            ],
            "_ica_def": [
                "X",
                "tol",
                "g",
                "fun_args",
                "max_iter",
                "w_init"
            ],
            "_ica_par": [
                "X",
                "tol",
                "g",
                "fun_args",
                "max_iter",
                "w_init"
            ],
            "_logcosh": [
                "x",
                "fun_args"
            ],
            "_exp": [
                "x",
                "fun_args"
            ],
            "_cube": [
                "x",
                "fun_args"
            ],
            "fastica": [
                "X",
                "n_components",
                "algorithm",
                "whiten",
                "fun",
                "fun_args",
                "max_iter",
                "tol",
                "w_init",
                "random_state",
                "return_X_mean",
                "compute_sources",
                "return_n_iter"
            ],
            "FastICA": {
                "__init__": [
                    "self",
                    "n_components",
                    "algorithm",
                    "whiten",
                    "fun",
                    "fun_args",
                    "max_iter",
                    "tol",
                    "w_init",
                    "random_state"
                ],
                "_fit": [
                    "self",
                    "X",
                    "compute_sources"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "copy"
                ]
            }
        },
        "sklearn.decomposition.nmf": {
            "norm": [
                "x"
            ],
            "trace_dot": [
                "X",
                "Y"
            ],
            "_check_init": [
                "A",
                "shape",
                "whom"
            ],
            "_beta_divergence": [
                "X",
                "W",
                "H",
                "beta",
                "square_root"
            ],
            "_special_sparse_dot": [
                "W",
                "H",
                "X"
            ],
            "_compute_regularization": [
                "alpha",
                "l1_ratio",
                "regularization"
            ],
            "_check_string_param": [
                "solver",
                "regularization",
                "beta_loss",
                "init"
            ],
            "_beta_loss_to_float": [
                "beta_loss"
            ],
            "_initialize_nmf": [
                "X",
                "n_components",
                "init",
                "eps",
                "random_state"
            ],
            "_update_coordinate_descent": [
                "X",
                "W",
                "Ht",
                "l1_reg",
                "l2_reg",
                "shuffle",
                "random_state"
            ],
            "_fit_coordinate_descent": [
                "X",
                "W",
                "H",
                "tol",
                "max_iter",
                "l1_reg_W",
                "l1_reg_H",
                "l2_reg_W",
                "l2_reg_H",
                "update_H",
                "verbose",
                "shuffle",
                "random_state"
            ],
            "_multiplicative_update_w": [
                "X",
                "W",
                "H",
                "beta_loss",
                "l1_reg_W",
                "l2_reg_W",
                "gamma",
                "H_sum",
                "HHt",
                "XHt",
                "update_H"
            ],
            "_multiplicative_update_h": [
                "X",
                "W",
                "H",
                "beta_loss",
                "l1_reg_H",
                "l2_reg_H",
                "gamma"
            ],
            "_fit_multiplicative_update": [
                "X",
                "W",
                "H",
                "beta_loss",
                "max_iter",
                "tol",
                "l1_reg_W",
                "l1_reg_H",
                "l2_reg_W",
                "l2_reg_H",
                "update_H",
                "verbose"
            ],
            "non_negative_factorization": [
                "X",
                "W",
                "H",
                "n_components",
                "init",
                "update_H",
                "solver",
                "beta_loss",
                "tol",
                "max_iter",
                "alpha",
                "l1_ratio",
                "regularization",
                "random_state",
                "verbose",
                "shuffle"
            ],
            "NMF": {
                "__init__": [
                    "self",
                    "n_components",
                    "init",
                    "solver",
                    "beta_loss",
                    "tol",
                    "max_iter",
                    "random_state",
                    "alpha",
                    "l1_ratio",
                    "verbose",
                    "shuffle"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y",
                    "W",
                    "H"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "W"
                ]
            }
        },
        "sklearn.decomposition.tests.test_online_lda": {
            "_build_sparse_mtx": [],
            "test_lda_default_prior_params": [],
            "test_lda_fit_batch": [],
            "test_lda_fit_online": [],
            "test_lda_partial_fit": [],
            "test_lda_dense_input": [],
            "test_lda_transform": [],
            "test_lda_fit_transform": [
                "method"
            ],
            "test_lda_partial_fit_dim_mismatch": [],
            "test_invalid_params": [],
            "test_lda_negative_input": [],
            "test_lda_no_component_error": [],
            "test_lda_transform_mismatch": [],
            "test_lda_multi_jobs": [
                "method"
            ],
            "test_lda_partial_fit_multi_jobs": [],
            "test_lda_preplexity_mismatch": [],
            "test_lda_perplexity": [
                "method"
            ],
            "test_lda_score": [
                "method"
            ],
            "test_perplexity_input_format": [],
            "test_lda_score_perplexity": [],
            "test_lda_fit_perplexity": [],
            "test_lda_empty_docs": [],
            "test_dirichlet_expectation": [],
            "check_verbosity": [
                "verbose",
                "evaluate_every",
                "expected_lines",
                "expected_perplexities"
            ],
            "test_verbosity": [
                "verbose",
                "evaluate_every",
                "expected_lines",
                "expected_perplexities"
            ]
        },
        "sklearn.decomposition.tests.test_dict_learning": {
            "test_sparse_encode_shapes_omp": [],
            "test_dict_learning_shapes": [],
            "test_dict_learning_overcomplete": [],
            "test_dict_learning_positivity": [
                "transform_algorithm",
                "positive_code",
                "positive_dict"
            ],
            "test_dict_learning_reconstruction": [],
            "test_dict_learning_reconstruction_parallel": [],
            "test_dict_learning_lassocd_readonly_data": [],
            "test_dict_learning_nonzero_coefs": [],
            "test_dict_learning_unknown_fit_algorithm": [],
            "test_dict_learning_split": [],
            "test_dict_learning_online_shapes": [],
            "test_dict_learning_online_positivity": [
                "transform_algorithm",
                "positive_code",
                "positive_dict"
            ],
            "test_dict_learning_online_verbosity": [],
            "test_dict_learning_online_estimator_shapes": [],
            "test_dict_learning_online_overcomplete": [],
            "test_dict_learning_online_initialization": [],
            "test_dict_learning_online_readonly_initialization": [],
            "test_dict_learning_online_partial_fit": [],
            "test_sparse_encode_shapes": [],
            "test_sparse_encode_positivity": [
                "positive"
            ],
            "test_sparse_encode_input": [],
            "test_sparse_encode_error": [],
            "test_sparse_encode_error_default_sparsity": [],
            "test_unknown_method": [],
            "test_sparse_coder_estimator": [],
            "test_sparse_coder_parallel_mmap": []
        },
        "sklearn.decomposition.tests.test_sparse_pca": {
            "generate_toy_data": [
                "n_components",
                "n_samples",
                "image_size",
                "random_state"
            ],
            "test_correct_shapes": [
                "norm_comp"
            ],
            "test_fit_transform": [
                "norm_comp"
            ],
            "test_fit_transform_parallel": [
                "norm_comp"
            ],
            "test_transform_nan": [
                "norm_comp"
            ],
            "test_fit_transform_tall": [
                "norm_comp"
            ],
            "test_initialization": [
                "norm_comp"
            ],
            "test_mini_batch_correct_shapes": [
                "norm_comp"
            ],
            "test_mini_batch_fit_transform": [
                "norm_comp"
            ],
            "test_scaling_fit_transform": [],
            "test_pca_vs_spca": [],
            "test_spca_deprecation_warning": [
                "spca"
            ]
        },
        "sklearn.decomposition.tests": {},
        "sklearn.decomposition.tests.test_truncated_svd": {
            "test_algorithms": [],
            "test_attributes": [],
            "test_too_many_components": [
                "algorithm"
            ],
            "test_sparse_formats": [
                "fmt"
            ],
            "test_inverse_transform": [
                "algo"
            ],
            "test_integers": [],
            "test_explained_variance": [],
            "test_singular_values": [],
            "test_truncated_svd_eq_pca": []
        },
        "sklearn.decomposition.tests.test_nmf": {
            "test_initialize_nn_output": [],
            "test_parameter_checking": [],
            "test_initialize_close": [],
            "test_initialize_variants": [],
            "test_nmf_fit_nn_output": [],
            "test_nmf_fit_close": [
                "solver"
            ],
            "test_nmf_transform": [
                "solver"
            ],
            "test_nmf_transform_custom_init": [],
            "test_nmf_inverse_transform": [
                "solver"
            ],
            "test_n_components_greater_n_features": [],
            "test_nmf_sparse_input": [],
            "test_nmf_sparse_transform": [],
            "test_non_negative_factorization_consistency": [],
            "test_non_negative_factorization_checking": [],
            "_beta_divergence_dense": [
                "X",
                "W",
                "H",
                "beta"
            ],
            "test_beta_divergence": [],
            "test_special_sparse_dot": [],
            "test_nmf_multiplicative_update_sparse": [],
            "test_nmf_negative_beta_loss": [],
            "test_nmf_regularization": [],
            "test_nmf_decreasing": [],
            "test_nmf_underflow": []
        },
        "sklearn.decomposition.tests.test_fastica": {
            "center_and_norm": [
                "x",
                "axis"
            ],
            "test_gs": [],
            "test_fastica_simple": [
                "add_noise"
            ],
            "test_fastica_nowhiten": [],
            "test_fastica_convergence_fail": [],
            "test_non_square_fastica": [
                "add_noise"
            ],
            "test_fit_transform": [],
            "test_inverse_transform": [],
            "test_fastica_errors": []
        },
        "sklearn.decomposition.tests.test_kernel_pca": {
            "test_kernel_pca": [],
            "test_kernel_pca_invalid_parameters": [],
            "test_kernel_pca_consistent_transform": [],
            "test_kernel_pca_deterministic_output": [],
            "test_kernel_pca_sparse": [],
            "test_kernel_pca_linear_kernel": [],
            "test_kernel_pca_n_components": [],
            "test_remove_zero_eig": [],
            "test_leave_zero_eig": [],
            "test_kernel_pca_precomputed": [],
            "test_kernel_pca_invalid_kernel": [],
            "test_gridsearch_pipeline": [],
            "test_gridsearch_pipeline_precomputed": [],
            "test_nested_circles": []
        },
        "sklearn.decomposition.tests.test_factor_analysis": {
            "test_factor_analysis": []
        },
        "sklearn.decomposition.tests.test_pca": {
            "test_pca": [],
            "test_pca_arpack_solver": [],
            "test_pca_randomized_solver": [],
            "test_no_empty_slice_warning": [],
            "test_whitening": [],
            "test_explained_variance": [],
            "test_singular_values": [],
            "test_pca_check_projection": [],
            "test_pca_inverse": [],
            "test_pca_validation": [
                "solver"
            ],
            "test_n_components_none": [
                "solver"
            ],
            "test_randomized_pca_check_projection": [],
            "test_randomized_pca_check_list": [],
            "test_randomized_pca_inverse": [],
            "test_n_components_mle": [],
            "test_pca_dim": [],
            "test_infer_dim_1": [],
            "test_infer_dim_2": [],
            "test_infer_dim_3": [],
            "test_infer_dim_by_explained_variance": [],
            "test_pca_score": [],
            "test_pca_score2": [],
            "test_pca_score3": [],
            "test_pca_score_with_different_solvers": [],
            "test_pca_zero_noise_variance_edge_cases": [],
            "test_svd_solver_auto": [],
            "test_pca_sparse_input": [
                "svd_solver"
            ],
            "test_pca_bad_solver": [],
            "test_pca_dtype_preservation": [
                "svd_solver"
            ],
            "test_pca_deterministic_output": [],
            "check_pca_float_dtype_preservation": [
                "svd_solver"
            ],
            "check_pca_int_dtype_upcast_to_double": [
                "svd_solver"
            ]
        },
        "sklearn.decomposition.tests.test_incremental_pca": {
            "test_incremental_pca": [],
            "test_incremental_pca_check_projection": [],
            "test_incremental_pca_inverse": [],
            "test_incremental_pca_validation": [],
            "test_n_components_none": [],
            "test_incremental_pca_set_params": [],
            "test_incremental_pca_num_features_change": [],
            "test_incremental_pca_batch_signs": [],
            "test_incremental_pca_batch_values": [],
            "test_incremental_pca_batch_rank": [],
            "test_incremental_pca_partial_fit": [],
            "test_incremental_pca_against_pca_iris": [],
            "test_incremental_pca_against_pca_random_data": [],
            "test_explained_variances": [],
            "test_singular_values": [],
            "test_whitening": [],
            "test_incremental_pca_partial_fit_float_division": []
        },
        "sklearn.experimental": {},
        "sklearn.experimental.enable_hist_gradient_boosting": {},
        "sklearn.experimental.tests": {},
        "sklearn.experimental.tests.test_enable_hist_gradient_boosting": {
            "test_imports_strategies": []
        },
        "sklearn.tree.export": {
            "_color_brew": [
                "n"
            ],
            "plot_tree": [
                "decision_tree",
                "max_depth",
                "feature_names",
                "class_names",
                "label",
                "filled",
                "impurity",
                "node_ids",
                "proportion",
                "rotate",
                "rounded",
                "precision",
                "ax",
                "fontsize"
            ],
            "export_graphviz": [
                "decision_tree",
                "out_file",
                "max_depth",
                "feature_names",
                "class_names",
                "label",
                "filled",
                "leaves_parallel",
                "impurity",
                "node_ids",
                "proportion",
                "rotate",
                "rounded",
                "special_characters",
                "precision"
            ],
            "_compute_depth": [
                "tree",
                "node"
            ],
            "export_text": [
                "decision_tree",
                "feature_names",
                "max_depth",
                "spacing",
                "decimals",
                "show_weights"
            ],
            "Sentinel": {
                "__repr__": [
                    "self"
                ]
            },
            "_BaseTreeExporter": {
                "__init__": [
                    "self",
                    "max_depth",
                    "feature_names",
                    "class_names",
                    "label",
                    "filled",
                    "impurity",
                    "node_ids",
                    "proportion",
                    "rotate",
                    "rounded",
                    "precision",
                    "fontsize"
                ],
                "get_color": [
                    "self",
                    "value"
                ],
                "get_fill_color": [
                    "self",
                    "tree",
                    "node_id"
                ],
                "node_to_str": [
                    "self",
                    "tree",
                    "node_id",
                    "criterion"
                ]
            },
            "_DOTTreeExporter": {
                "__init__": [
                    "self",
                    "out_file",
                    "max_depth",
                    "feature_names",
                    "class_names",
                    "label",
                    "filled",
                    "leaves_parallel",
                    "impurity",
                    "node_ids",
                    "proportion",
                    "rotate",
                    "rounded",
                    "special_characters",
                    "precision"
                ],
                "export": [
                    "self",
                    "decision_tree"
                ],
                "tail": [
                    "self"
                ],
                "head": [
                    "self"
                ],
                "recurse": [
                    "self",
                    "tree",
                    "node_id",
                    "criterion",
                    "parent",
                    "depth"
                ]
            },
            "_MPLTreeExporter": {
                "__init__": [
                    "self",
                    "max_depth",
                    "feature_names",
                    "class_names",
                    "label",
                    "filled",
                    "impurity",
                    "node_ids",
                    "proportion",
                    "rotate",
                    "rounded",
                    "precision",
                    "fontsize"
                ],
                "_make_tree": [
                    "self",
                    "node_id",
                    "et",
                    "depth"
                ],
                "export": [
                    "self",
                    "decision_tree",
                    "ax"
                ],
                "recurse": [
                    "self",
                    "node",
                    "tree",
                    "ax",
                    "scale_x",
                    "scale_y",
                    "height",
                    "depth"
                ]
            }
        },
        "sklearn.tree.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.tree.tree": {
            "BaseDecisionTree": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "max_leaf_nodes",
                    "random_state",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "class_weight",
                    "presort"
                ],
                "get_depth": [
                    "self"
                ],
                "get_n_leaves": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "check_input",
                    "X_idx_sorted"
                ],
                "_validate_X_predict": [
                    "self",
                    "X",
                    "check_input"
                ],
                "predict": [
                    "self",
                    "X",
                    "check_input"
                ],
                "apply": [
                    "self",
                    "X",
                    "check_input"
                ],
                "decision_path": [
                    "self",
                    "X",
                    "check_input"
                ],
                "feature_importances_": [
                    "self"
                ]
            },
            "DecisionTreeClassifier": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "random_state",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "class_weight",
                    "presort"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "check_input",
                    "X_idx_sorted"
                ],
                "predict_proba": [
                    "self",
                    "X",
                    "check_input"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "DecisionTreeRegressor": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "random_state",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "presort"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "check_input",
                    "X_idx_sorted"
                ]
            },
            "ExtraTreeClassifier": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "random_state",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "class_weight"
                ]
            },
            "ExtraTreeRegressor": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "random_state",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "max_leaf_nodes"
                ]
            }
        },
        "sklearn.tree": {},
        "sklearn.tree._reingold_tilford": {
            "buchheim": [
                "tree"
            ],
            "third_walk": [
                "tree",
                "n"
            ],
            "first_walk": [
                "v",
                "distance"
            ],
            "apportion": [
                "v",
                "default_ancestor",
                "distance"
            ],
            "move_subtree": [
                "wl",
                "wr",
                "shift"
            ],
            "execute_shifts": [
                "v"
            ],
            "ancestor": [
                "vil",
                "v",
                "default_ancestor"
            ],
            "second_walk": [
                "v",
                "m",
                "depth",
                "min"
            ],
            "DrawTree": {
                "__init__": [
                    "self",
                    "tree",
                    "parent",
                    "depth",
                    "number"
                ],
                "left": [
                    "self"
                ],
                "right": [
                    "self"
                ],
                "lbrother": [
                    "self"
                ],
                "get_lmost_sibling": [
                    "self"
                ],
                "__str__": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "max_extents": [
                    "self"
                ]
            },
            "Tree": {
                "__init__": [
                    "self",
                    "label",
                    "node_id"
                ]
            }
        },
        "sklearn.tree.tests.test_tree": {
            "assert_tree_equal": [
                "d",
                "s",
                "message"
            ],
            "test_classification_toy": [],
            "test_weighted_classification_toy": [],
            "test_regression_toy": [],
            "test_xor": [],
            "test_iris": [],
            "test_boston": [],
            "test_probability": [],
            "test_arrayrepr": [],
            "test_pure_set": [],
            "test_numerical_stability": [],
            "test_importances": [],
            "test_importances_raises": [],
            "test_importances_gini_equal_mse": [],
            "test_max_features": [],
            "test_error": [],
            "test_min_samples_split": [],
            "test_min_samples_leaf": [],
            "check_min_weight_fraction_leaf": [
                "name",
                "datasets",
                "sparse"
            ],
            "test_min_weight_fraction_leaf_on_dense_input": [
                "name"
            ],
            "test_min_weight_fraction_leaf_on_sparse_input": [
                "name"
            ],
            "check_min_weight_fraction_leaf_with_min_samples_leaf": [
                "name",
                "datasets",
                "sparse"
            ],
            "test_min_weight_fraction_leaf_with_min_samples_leaf_on_dense_input": [
                "name"
            ],
            "test_min_weight_fraction_leaf_with_min_samples_leaf_on_sparse_input": [
                "name"
            ],
            "test_min_impurity_split": [],
            "test_min_impurity_decrease": [],
            "test_multioutput": [],
            "test_classes_shape": [],
            "test_unbalanced_iris": [],
            "test_memory_layout": [],
            "test_sample_weight": [],
            "test_sample_weight_invalid": [],
            "check_class_weights": [
                "name"
            ],
            "test_class_weights": [
                "name"
            ],
            "check_class_weight_errors": [
                "name"
            ],
            "test_class_weight_errors": [
                "name"
            ],
            "test_max_leaf_nodes": [],
            "test_max_leaf_nodes_max_depth": [],
            "test_arrays_persist": [],
            "test_only_constant_features": [],
            "test_behaviour_constant_feature_after_splits": [],
            "test_with_only_one_non_constant_features": [],
            "test_big_input": [],
            "test_realloc": [],
            "test_huge_allocations": [],
            "check_sparse_input": [
                "tree",
                "dataset",
                "max_depth"
            ],
            "test_sparse_input": [
                "tree_type",
                "dataset"
            ],
            "test_sparse_input_reg_trees": [
                "tree_type",
                "dataset"
            ],
            "check_sparse_parameters": [
                "tree",
                "dataset"
            ],
            "check_sparse_criterion": [
                "tree",
                "dataset"
            ],
            "test_sparse": [
                "tree_type",
                "dataset",
                "check"
            ],
            "check_explicit_sparse_zeros": [
                "tree",
                "max_depth",
                "n_features"
            ],
            "test_explicit_sparse_zeros": [
                "tree_type"
            ],
            "check_raise_error_on_1d_input": [
                "name"
            ],
            "test_1d_input": [
                "name"
            ],
            "_check_min_weight_leaf_split_level": [
                "TreeEstimator",
                "X",
                "y",
                "sample_weight"
            ],
            "check_min_weight_leaf_split_level": [
                "name"
            ],
            "test_min_weight_leaf_split_level": [
                "name"
            ],
            "check_public_apply": [
                "name"
            ],
            "check_public_apply_sparse": [
                "name"
            ],
            "test_public_apply_all_trees": [
                "name"
            ],
            "test_public_apply_sparse_trees": [
                "name"
            ],
            "check_presort_sparse": [
                "est",
                "X",
                "y"
            ],
            "test_presort_sparse": [],
            "test_invalid_presort": [
                "cls"
            ],
            "test_decision_path_hardcoded": [],
            "check_decision_path": [
                "name"
            ],
            "test_decision_path": [
                "name"
            ],
            "check_no_sparse_y_support": [
                "name"
            ],
            "test_no_sparse_y_support": [
                "name"
            ],
            "test_mae": [],
            "test_criterion_copy": [],
            "test_empty_leaf_infinite_threshold": [],
            "test_multi_target": [
                "name"
            ],
            "test_decision_tree_memmap": []
        },
        "sklearn.tree.tests": {},
        "sklearn.tree.tests.test_reingold_tilford": {
            "test_buchheim": [
                "tree",
                "n_nodes"
            ]
        },
        "sklearn.tree.tests.test_export": {
            "test_graphviz_toy": [],
            "test_graphviz_errors": [],
            "test_friedman_mse_in_graphviz": [],
            "test_precision": [],
            "test_export_text_errors": [],
            "test_export_text": [],
            "test_plot_tree": []
        },
        "sklearn.gaussian_process.kernels": {
            "_check_length_scale": [
                "X",
                "length_scale"
            ],
            "_approx_fprime": [
                "xk",
                "f",
                "epsilon",
                "args"
            ],
            "Hyperparameter": {
                "__new__": [
                    "cls",
                    "name",
                    "value_type",
                    "bounds",
                    "n_elements",
                    "fixed"
                ],
                "__eq__": [
                    "self",
                    "other"
                ]
            },
            "Kernel": {
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ],
                "clone_with_theta": [
                    "self",
                    "theta"
                ],
                "n_dims": [
                    "self"
                ],
                "hyperparameters": [
                    "self"
                ],
                "theta": [
                    "self",
                    "theta"
                ],
                "bounds": [
                    "self"
                ],
                "__add__": [
                    "self",
                    "b"
                ],
                "__radd__": [
                    "self",
                    "b"
                ],
                "__mul__": [
                    "self",
                    "b"
                ],
                "__rmul__": [
                    "self",
                    "b"
                ],
                "__pow__": [
                    "self",
                    "b"
                ],
                "__eq__": [
                    "self",
                    "b"
                ],
                "__repr__": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "is_stationary": [
                    "self"
                ]
            },
            "NormalizedKernelMixin": {
                "diag": [
                    "self",
                    "X"
                ]
            },
            "StationaryKernelMixin": {
                "is_stationary": [
                    "self"
                ]
            },
            "CompoundKernel": {
                "__init__": [
                    "self",
                    "kernels"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "theta": [
                    "self",
                    "theta"
                ],
                "bounds": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "__eq__": [
                    "self",
                    "b"
                ],
                "is_stationary": [
                    "self"
                ],
                "diag": [
                    "self",
                    "X"
                ]
            },
            "KernelOperator": {
                "__init__": [
                    "self",
                    "k1",
                    "k2"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "hyperparameters": [
                    "self"
                ],
                "theta": [
                    "self",
                    "theta"
                ],
                "bounds": [
                    "self"
                ],
                "__eq__": [
                    "self",
                    "b"
                ],
                "is_stationary": [
                    "self"
                ]
            },
            "Sum": {
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "Product": {
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "Exponentiation": {
                "__init__": [
                    "self",
                    "kernel",
                    "exponent"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "hyperparameters": [
                    "self"
                ],
                "theta": [
                    "self",
                    "theta"
                ],
                "bounds": [
                    "self"
                ],
                "__eq__": [
                    "self",
                    "b"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "__repr__": [
                    "self"
                ],
                "is_stationary": [
                    "self"
                ]
            },
            "ConstantKernel": {
                "__init__": [
                    "self",
                    "constant_value",
                    "constant_value_bounds"
                ],
                "hyperparameter_constant_value": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "WhiteKernel": {
                "__init__": [
                    "self",
                    "noise_level",
                    "noise_level_bounds"
                ],
                "hyperparameter_noise_level": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "RBF": {
                "__init__": [
                    "self",
                    "length_scale",
                    "length_scale_bounds"
                ],
                "anisotropic": [
                    "self"
                ],
                "hyperparameter_length_scale": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "Matern": {
                "__init__": [
                    "self",
                    "length_scale",
                    "length_scale_bounds",
                    "nu"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "RationalQuadratic": {
                "__init__": [
                    "self",
                    "length_scale",
                    "alpha",
                    "length_scale_bounds",
                    "alpha_bounds"
                ],
                "hyperparameter_length_scale": [
                    "self"
                ],
                "hyperparameter_alpha": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "ExpSineSquared": {
                "__init__": [
                    "self",
                    "length_scale",
                    "periodicity",
                    "length_scale_bounds",
                    "periodicity_bounds"
                ],
                "hyperparameter_length_scale": [
                    "self"
                ],
                "hyperparameter_periodicity": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "DotProduct": {
                "__init__": [
                    "self",
                    "sigma_0",
                    "sigma_0_bounds"
                ],
                "hyperparameter_sigma_0": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "is_stationary": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "PairwiseKernel": {
                "__init__": [
                    "self",
                    "gamma",
                    "gamma_bounds",
                    "metric",
                    "pairwise_kernels_kwargs"
                ],
                "hyperparameter_gamma": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "X",
                    "Y",
                    "eval_gradient"
                ],
                "diag": [
                    "self",
                    "X"
                ],
                "is_stationary": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ]
            }
        },
        "sklearn.gaussian_process": {},
        "sklearn.gaussian_process.correlation_models": {
            "absolute_exponential": [
                "theta",
                "d"
            ],
            "squared_exponential": [
                "theta",
                "d"
            ],
            "generalized_exponential": [
                "theta",
                "d"
            ],
            "pure_nugget": [
                "theta",
                "d"
            ],
            "cubic": [
                "theta",
                "d"
            ],
            "linear": [
                "theta",
                "d"
            ]
        },
        "sklearn.gaussian_process.gpc": {
            "_BinaryGaussianProcessClassifierLaplace": {
                "__init__": [
                    "self",
                    "kernel",
                    "optimizer",
                    "n_restarts_optimizer",
                    "max_iter_predict",
                    "warm_start",
                    "copy_X_train",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "log_marginal_likelihood": [
                    "self",
                    "theta",
                    "eval_gradient"
                ],
                "_posterior_mode": [
                    "self",
                    "K",
                    "return_temporaries"
                ],
                "_constrained_optimization": [
                    "self",
                    "obj_func",
                    "initial_theta",
                    "bounds"
                ]
            },
            "GaussianProcessClassifier": {
                "__init__": [
                    "self",
                    "kernel",
                    "optimizer",
                    "n_restarts_optimizer",
                    "max_iter_predict",
                    "warm_start",
                    "copy_X_train",
                    "random_state",
                    "multi_class",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "kernel_": [
                    "self"
                ],
                "log_marginal_likelihood": [
                    "self",
                    "theta",
                    "eval_gradient"
                ]
            }
        },
        "sklearn.gaussian_process.regression_models": {
            "constant": [
                "x"
            ],
            "linear": [
                "x"
            ],
            "quadratic": [
                "x"
            ]
        },
        "sklearn.gaussian_process.gpr": {
            "GaussianProcessRegressor": {
                "__init__": [
                    "self",
                    "kernel",
                    "alpha",
                    "optimizer",
                    "n_restarts_optimizer",
                    "normalize_y",
                    "copy_X_train",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X",
                    "return_std",
                    "return_cov"
                ],
                "sample_y": [
                    "self",
                    "X",
                    "n_samples",
                    "random_state"
                ],
                "log_marginal_likelihood": [
                    "self",
                    "theta",
                    "eval_gradient"
                ],
                "_constrained_optimization": [
                    "self",
                    "obj_func",
                    "initial_theta",
                    "bounds"
                ]
            }
        },
        "sklearn.gaussian_process.tests.test_gpr": {
            "f": [
                "x"
            ],
            "test_gpr_interpolation": [
                "kernel"
            ],
            "test_lml_improving": [
                "kernel"
            ],
            "test_lml_precomputed": [
                "kernel"
            ],
            "test_converged_to_local_maximum": [
                "kernel"
            ],
            "test_solution_inside_bounds": [
                "kernel"
            ],
            "test_lml_gradient": [
                "kernel"
            ],
            "test_prior": [
                "kernel"
            ],
            "test_sample_statistics": [
                "kernel"
            ],
            "test_no_optimizer": [],
            "test_predict_cov_vs_std": [
                "kernel"
            ],
            "test_anisotropic_kernel": [],
            "test_random_starts": [],
            "test_y_normalization": [
                "kernel"
            ],
            "test_y_multioutput": [],
            "test_custom_optimizer": [
                "kernel"
            ],
            "test_gpr_correct_error_message": [],
            "test_duplicate_input": [
                "kernel"
            ],
            "test_no_fit_default_predict": [],
            "test_K_inv_reset": [
                "kernel"
            ]
        },
        "sklearn.gaussian_process.tests.test_gpc": {
            "f": [
                "x"
            ],
            "test_predict_consistent": [
                "kernel"
            ],
            "test_lml_improving": [
                "kernel"
            ],
            "test_lml_precomputed": [
                "kernel"
            ],
            "test_converged_to_local_maximum": [
                "kernel"
            ],
            "test_lml_gradient": [
                "kernel"
            ],
            "test_random_starts": [],
            "test_custom_optimizer": [
                "kernel"
            ],
            "test_multi_class": [
                "kernel"
            ],
            "test_multi_class_n_jobs": [
                "kernel"
            ]
        },
        "sklearn.gaussian_process.tests": {},
        "sklearn.gaussian_process.tests.test_kernels": {
            "test_kernel_gradient": [
                "kernel"
            ],
            "test_kernel_theta": [
                "kernel"
            ],
            "test_auto_vs_cross": [
                "kernel"
            ],
            "test_kernel_diag": [
                "kernel"
            ],
            "test_kernel_operator_commutative": [],
            "test_kernel_anisotropic": [],
            "test_kernel_stationary": [
                "kernel"
            ],
            "check_hyperparameters_equal": [
                "kernel1",
                "kernel2"
            ],
            "test_kernel_clone": [
                "kernel"
            ],
            "test_kernel_clone_after_set_params": [
                "kernel"
            ],
            "test_matern_kernel": [],
            "test_kernel_versus_pairwise": [
                "kernel"
            ],
            "test_set_get_params": [
                "kernel"
            ],
            "test_repr_kernels": [
                "kernel"
            ]
        },
        "sklearn.metrics.classification": {
            "_check_targets": [
                "y_true",
                "y_pred"
            ],
            "_weighted_sum": [
                "sample_score",
                "sample_weight",
                "normalize"
            ],
            "accuracy_score": [
                "y_true",
                "y_pred",
                "normalize",
                "sample_weight"
            ],
            "confusion_matrix": [
                "y_true",
                "y_pred",
                "labels",
                "sample_weight"
            ],
            "multilabel_confusion_matrix": [
                "y_true",
                "y_pred",
                "sample_weight",
                "labels",
                "samplewise"
            ],
            "cohen_kappa_score": [
                "y1",
                "y2",
                "labels",
                "weights",
                "sample_weight"
            ],
            "jaccard_similarity_score": [
                "y_true",
                "y_pred",
                "normalize",
                "sample_weight"
            ],
            "jaccard_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average",
                "sample_weight"
            ],
            "matthews_corrcoef": [
                "y_true",
                "y_pred",
                "sample_weight"
            ],
            "zero_one_loss": [
                "y_true",
                "y_pred",
                "normalize",
                "sample_weight"
            ],
            "f1_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average",
                "sample_weight"
            ],
            "fbeta_score": [
                "y_true",
                "y_pred",
                "beta",
                "labels",
                "pos_label",
                "average",
                "sample_weight"
            ],
            "_prf_divide": [
                "numerator",
                "denominator",
                "metric",
                "modifier",
                "average",
                "warn_for"
            ],
            "_check_set_wise_labels": [
                "y_true",
                "y_pred",
                "average",
                "labels",
                "pos_label"
            ],
            "precision_recall_fscore_support": [
                "y_true",
                "y_pred",
                "beta",
                "labels",
                "pos_label",
                "average",
                "warn_for",
                "sample_weight"
            ],
            "precision_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average",
                "sample_weight"
            ],
            "recall_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average",
                "sample_weight"
            ],
            "balanced_accuracy_score": [
                "y_true",
                "y_pred",
                "sample_weight",
                "adjusted"
            ],
            "classification_report": [
                "y_true",
                "y_pred",
                "labels",
                "target_names",
                "sample_weight",
                "digits",
                "output_dict"
            ],
            "hamming_loss": [
                "y_true",
                "y_pred",
                "labels",
                "sample_weight"
            ],
            "log_loss": [
                "y_true",
                "y_pred",
                "eps",
                "normalize",
                "sample_weight",
                "labels"
            ],
            "hinge_loss": [
                "y_true",
                "pred_decision",
                "labels",
                "sample_weight"
            ],
            "brier_score_loss": [
                "y_true",
                "y_prob",
                "sample_weight",
                "pos_label"
            ]
        },
        "sklearn.metrics.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.metrics": {},
        "sklearn.metrics.regression": {
            "_check_reg_targets": [
                "y_true",
                "y_pred",
                "multioutput"
            ],
            "mean_absolute_error": [
                "y_true",
                "y_pred",
                "sample_weight",
                "multioutput"
            ],
            "mean_squared_error": [
                "y_true",
                "y_pred",
                "sample_weight",
                "multioutput"
            ],
            "mean_squared_log_error": [
                "y_true",
                "y_pred",
                "sample_weight",
                "multioutput"
            ],
            "median_absolute_error": [
                "y_true",
                "y_pred"
            ],
            "explained_variance_score": [
                "y_true",
                "y_pred",
                "sample_weight",
                "multioutput"
            ],
            "r2_score": [
                "y_true",
                "y_pred",
                "sample_weight",
                "multioutput"
            ],
            "max_error": [
                "y_true",
                "y_pred"
            ]
        },
        "sklearn.metrics.pairwise": {
            "_return_float_dtype": [
                "X",
                "Y"
            ],
            "check_pairwise_arrays": [
                "X",
                "Y",
                "precomputed",
                "dtype"
            ],
            "check_paired_arrays": [
                "X",
                "Y"
            ],
            "euclidean_distances": [
                "X",
                "Y",
                "Y_norm_squared",
                "squared",
                "X_norm_squared"
            ],
            "_euclidean_distances_upcast": [
                "X",
                "XX",
                "Y",
                "YY"
            ],
            "_argmin_min_reduce": [
                "dist",
                "start"
            ],
            "pairwise_distances_argmin_min": [
                "X",
                "Y",
                "axis",
                "metric",
                "batch_size",
                "metric_kwargs"
            ],
            "pairwise_distances_argmin": [
                "X",
                "Y",
                "axis",
                "metric",
                "batch_size",
                "metric_kwargs"
            ],
            "haversine_distances": [
                "X",
                "Y"
            ],
            "manhattan_distances": [
                "X",
                "Y",
                "sum_over_features"
            ],
            "cosine_distances": [
                "X",
                "Y"
            ],
            "paired_euclidean_distances": [
                "X",
                "Y"
            ],
            "paired_manhattan_distances": [
                "X",
                "Y"
            ],
            "paired_cosine_distances": [
                "X",
                "Y"
            ],
            "paired_distances": [
                "X",
                "Y",
                "metric"
            ],
            "linear_kernel": [
                "X",
                "Y",
                "dense_output"
            ],
            "polynomial_kernel": [
                "X",
                "Y",
                "degree",
                "gamma",
                "coef0"
            ],
            "sigmoid_kernel": [
                "X",
                "Y",
                "gamma",
                "coef0"
            ],
            "rbf_kernel": [
                "X",
                "Y",
                "gamma"
            ],
            "laplacian_kernel": [
                "X",
                "Y",
                "gamma"
            ],
            "cosine_similarity": [
                "X",
                "Y",
                "dense_output"
            ],
            "additive_chi2_kernel": [
                "X",
                "Y"
            ],
            "chi2_kernel": [
                "X",
                "Y",
                "gamma"
            ],
            "distance_metrics": [],
            "_dist_wrapper": [
                "dist_func",
                "dist_matrix",
                "slice_"
            ],
            "_parallel_pairwise": [
                "X",
                "Y",
                "func",
                "n_jobs"
            ],
            "_pairwise_callable": [
                "X",
                "Y",
                "metric"
            ],
            "_check_chunk_size": [
                "reduced",
                "chunk_size"
            ],
            "_precompute_metric_params": [
                "X",
                "Y",
                "metric"
            ],
            "pairwise_distances_chunked": [
                "X",
                "Y",
                "reduce_func",
                "metric",
                "n_jobs",
                "working_memory"
            ],
            "pairwise_distances": [
                "X",
                "Y",
                "metric",
                "n_jobs"
            ],
            "kernel_metrics": [],
            "pairwise_kernels": [
                "X",
                "Y",
                "metric",
                "filter_params",
                "n_jobs"
            ]
        },
        "sklearn.metrics.base": {
            "_average_binary_score": [
                "binary_metric",
                "y_true",
                "y_score",
                "average",
                "sample_weight"
            ]
        },
        "sklearn.metrics.scorer": {
            "get_scorer": [
                "scoring"
            ],
            "_passthrough_scorer": [
                "estimator"
            ],
            "check_scoring": [
                "estimator",
                "scoring",
                "allow_none"
            ],
            "_check_multimetric_scoring": [
                "estimator",
                "scoring"
            ],
            "make_scorer": [
                "score_func",
                "greater_is_better",
                "needs_proba",
                "needs_threshold"
            ],
            "_BaseScorer": {
                "__init__": [
                    "self",
                    "score_func",
                    "sign",
                    "kwargs"
                ],
                "__repr__": [
                    "self"
                ],
                "_factory_args": [
                    "self"
                ]
            },
            "_PredictScorer": {
                "__call__": [
                    "self",
                    "estimator",
                    "X",
                    "y_true",
                    "sample_weight"
                ]
            },
            "_ProbaScorer": {
                "__call__": [
                    "self",
                    "clf",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_factory_args": [
                    "self"
                ]
            },
            "_ThresholdScorer": {
                "__call__": [
                    "self",
                    "clf",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_factory_args": [
                    "self"
                ]
            }
        },
        "sklearn.metrics.ranking": {
            "auc": [
                "x",
                "y",
                "reorder"
            ],
            "average_precision_score": [
                "y_true",
                "y_score",
                "average",
                "pos_label",
                "sample_weight"
            ],
            "roc_auc_score": [
                "y_true",
                "y_score",
                "average",
                "sample_weight",
                "max_fpr"
            ],
            "_binary_clf_curve": [
                "y_true",
                "y_score",
                "pos_label",
                "sample_weight"
            ],
            "precision_recall_curve": [
                "y_true",
                "probas_pred",
                "pos_label",
                "sample_weight"
            ],
            "roc_curve": [
                "y_true",
                "y_score",
                "pos_label",
                "sample_weight",
                "drop_intermediate"
            ],
            "label_ranking_average_precision_score": [
                "y_true",
                "y_score",
                "sample_weight"
            ],
            "coverage_error": [
                "y_true",
                "y_score",
                "sample_weight"
            ],
            "label_ranking_loss": [
                "y_true",
                "y_score",
                "sample_weight"
            ]
        },
        "sklearn.metrics.tests.test_score_objects": {
            "_make_estimators": [
                "X_train",
                "y_train",
                "y_ml_train"
            ],
            "setup_module": [],
            "teardown_module": [],
            "test_all_scorers_repr": [],
            "check_scoring_validator_for_single_metric_usecases": [
                "scoring_validator"
            ],
            "check_multimetric_scoring_single_metric_wrapper": [],
            "test_check_scoring_and_check_multimetric_scoring": [],
            "test_check_scoring_gridsearchcv": [],
            "test_make_scorer": [],
            "test_classification_scores": [],
            "test_regression_scorers": [],
            "test_thresholded_scorers": [],
            "test_thresholded_scorers_multilabel_indicator_data": [],
            "test_supervised_cluster_scorers": [],
            "test_raises_on_score_list": [],
            "test_scorer_sample_weight": [],
            "check_scorer_memmap": [
                "scorer_name"
            ],
            "test_scorer_memmap_input": [
                "name"
            ],
            "test_scoring_is_not_metric": [],
            "EstimatorWithoutFit": {},
            "EstimatorWithFit": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "EstimatorWithFitAndScore": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "EstimatorWithFitAndPredict": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "DummyScorer": {
                "__call__": [
                    "self",
                    "est",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.metrics.tests": {},
        "sklearn.metrics.tests.test_classification": {
            "make_prediction": [
                "dataset",
                "binary"
            ],
            "test_classification_report_dictionary_output": [],
            "test_multilabel_accuracy_score_subset_accuracy": [],
            "test_precision_recall_f1_score_binary": [],
            "test_precision_recall_f_binary_single_class": [],
            "test_precision_recall_f_extra_labels": [],
            "test_precision_recall_f_ignored_labels": [],
            "test_average_precision_score_score_non_binary_class": [],
            "test_average_precision_score_duplicate_values": [],
            "test_average_precision_score_tied_values": [],
            "test_precision_recall_fscore_support_errors": [],
            "test_precision_recall_f_unused_pos_label": [],
            "test_confusion_matrix_binary": [],
            "test_multilabel_confusion_matrix_binary": [],
            "test_multilabel_confusion_matrix_multiclass": [],
            "test_multilabel_confusion_matrix_multilabel": [],
            "test_multilabel_confusion_matrix_errors": [],
            "test_cohen_kappa": [],
            "test_matthews_corrcoef_nan": [],
            "test_matthews_corrcoef_against_numpy_corrcoef": [],
            "test_matthews_corrcoef_against_jurman": [],
            "test_matthews_corrcoef": [],
            "test_matthews_corrcoef_multiclass": [],
            "test_matthews_corrcoef_overflow": [
                "n_points"
            ],
            "test_precision_recall_f1_score_multiclass": [],
            "test_precision_refcall_f1_score_multilabel_unordered_labels": [
                "average"
            ],
            "test_precision_recall_f1_score_binary_averaged": [],
            "test_zero_precision_recall": [],
            "test_confusion_matrix_multiclass_subset_labels": [],
            "test_confusion_matrix_dtype": [],
            "test_classification_report_multiclass": [],
            "test_classification_report_multiclass_balanced": [],
            "test_classification_report_multiclass_with_label_detection": [],
            "test_classification_report_multiclass_with_digits": [],
            "test_classification_report_multiclass_with_string_label": [],
            "test_classification_report_multiclass_with_unicode_label": [],
            "test_classification_report_multiclass_with_long_string_label": [],
            "test_classification_report_labels_target_names_unequal_length": [],
            "test_classification_report_no_labels_target_names_unequal_length": [],
            "test_multilabel_classification_report": [],
            "test_multilabel_zero_one_loss_subset": [],
            "test_multilabel_hamming_loss": [],
            "test_jaccard_score_validation": [],
            "test_multilabel_jaccard_score": [
                "recwarn"
            ],
            "test_multiclass_jaccard_score": [
                "recwarn"
            ],
            "test_average_binary_jaccard_score": [
                "recwarn"
            ],
            "test_precision_recall_f1_score_multilabel_1": [],
            "test_precision_recall_f1_score_multilabel_2": [],
            "test_precision_recall_f1_score_with_an_empty_prediction": [],
            "test_precision_recall_f1_no_labels": [
                "beta",
                "average"
            ],
            "test_precision_recall_f1_no_labels_average_none": [],
            "test_prf_warnings": [],
            "test_recall_warnings": [],
            "test_precision_warnings": [],
            "test_fscore_warnings": [],
            "test_prf_average_binary_data_non_binary": [],
            "test__check_targets": [],
            "test__check_targets_multiclass_with_both_y_true_and_y_pred_binary": [],
            "test_hinge_loss_binary": [],
            "test_hinge_loss_multiclass": [],
            "test_hinge_loss_multiclass_missing_labels_with_labels_none": [],
            "test_hinge_loss_multiclass_with_missing_labels": [],
            "test_hinge_loss_multiclass_invariance_lists": [],
            "test_log_loss": [],
            "test_log_loss_pandas_input": [],
            "test_brier_score_loss": [],
            "test_balanced_accuracy_score_unseen": [],
            "test_balanced_accuracy_score": [
                "y_true",
                "y_pred"
            ],
            "test_multilabel_jaccard_similarity_score_deprecation": []
        },
        "sklearn.metrics.tests.test_regression": {
            "test_regression_metrics": [
                "n_samples"
            ],
            "test_multioutput_regression": [],
            "test_regression_metrics_at_limits": [],
            "test__check_reg_targets": [],
            "test__check_reg_targets_exception": [],
            "test_regression_multioutput_array": [],
            "test_regression_custom_weights": [],
            "test_regression_single_sample": [
                "metric"
            ]
        },
        "sklearn.metrics.tests.test_ranking": {
            "make_prediction": [
                "dataset",
                "binary"
            ],
            "_auc": [
                "y_true",
                "y_score"
            ],
            "_average_precision": [
                "y_true",
                "y_score"
            ],
            "_average_precision_slow": [
                "y_true",
                "y_score"
            ],
            "_partial_roc_auc_score": [
                "y_true",
                "y_predict",
                "max_fpr"
            ],
            "test_roc_curve": [
                "drop"
            ],
            "test_roc_curve_end_points": [],
            "test_roc_returns_consistency": [],
            "test_roc_curve_multi": [],
            "test_roc_curve_confidence": [],
            "test_roc_curve_hard": [],
            "test_roc_curve_one_label": [],
            "test_roc_curve_toydata": [],
            "test_roc_curve_drop_intermediate": [],
            "test_roc_curve_fpr_tpr_increasing": [],
            "test_auc": [],
            "test_auc_duplicate_values": [],
            "test_auc_errors": [],
            "test_deprecated_auc_reorder": [],
            "test_auc_score_non_binary_class": [],
            "test_binary_clf_curve": [],
            "test_precision_recall_curve": [],
            "_test_precision_recall_curve": [
                "y_true",
                "probas_pred"
            ],
            "test_precision_recall_curve_errors": [],
            "test_precision_recall_curve_toydata": [],
            "test_average_precision_constant_values": [],
            "test_average_precision_score_pos_label_errors": [],
            "test_score_scale_invariance": [],
            "check_lrap_toy": [
                "lrap_score"
            ],
            "check_zero_or_all_relevant_labels": [
                "lrap_score"
            ],
            "check_lrap_error_raised": [
                "lrap_score"
            ],
            "check_lrap_only_ties": [
                "lrap_score"
            ],
            "check_lrap_without_tie_and_increasing_score": [
                "lrap_score"
            ],
            "_my_lrap": [
                "y_true",
                "y_score"
            ],
            "check_alternative_lrap_implementation": [
                "lrap_score",
                "n_classes",
                "n_samples",
                "random_state"
            ],
            "test_label_ranking_avp": [
                "check",
                "func"
            ],
            "test_lrap_error_raised": [],
            "test_alternative_lrap_implementation": [
                "n_samples",
                "n_classes",
                "random_state"
            ],
            "test_lrap_sample_weighting_zero_labels": [],
            "test_coverage_error": [],
            "test_coverage_tie_handling": [],
            "test_label_ranking_loss": [],
            "test_ranking_appropriate_input_shape": [],
            "test_ranking_loss_ties_handling": [],
            "test_partial_roc_auc_score": []
        },
        "sklearn.metrics.tests.test_pairwise": {
            "test_pairwise_distances": [],
            "test_pairwise_boolean_distance": [
                "metric"
            ],
            "test_no_data_conversion_warning": [],
            "test_pairwise_precomputed": [
                "func"
            ],
            "test_pairwise_precomputed_non_negative": [],
            "check_pairwise_parallel": [
                "func",
                "metric",
                "kwds"
            ],
            "callable_rbf_kernel": [
                "x",
                "y"
            ],
            "test_pairwise_parallel": [
                "func",
                "metric",
                "kwds"
            ],
            "test_pairwise_callable_nonstrict_metric": [],
            "test_pairwise_kernels": [
                "metric"
            ],
            "test_pairwise_kernels_callable": [],
            "test_pairwise_kernels_filter_param": [],
            "test_paired_distances": [
                "metric",
                "func"
            ],
            "test_paired_distances_callable": [],
            "test_pairwise_distances_argmin_min": [],
            "_reduce_func": [
                "dist",
                "start"
            ],
            "test_pairwise_distances_chunked_reduce": [],
            "test_pairwise_distances_chunked_reduce_valid": [
                "good_reduce"
            ],
            "test_pairwise_distances_chunked_reduce_invalid": [
                "bad_reduce",
                "err_type",
                "message"
            ],
            "check_pairwise_distances_chunked": [
                "X",
                "Y",
                "working_memory",
                "metric"
            ],
            "test_pairwise_distances_chunked_diagonal": [
                "metric"
            ],
            "test_pairwise_distances_chunked": [],
            "test_euclidean_distances_known_result": [
                "x_array_constr",
                "y_array_constr"
            ],
            "test_euclidean_distances_with_norms": [
                "dtype",
                "y_array_constr"
            ],
            "test_euclidean_distances": [
                "dtype",
                "x_array_constr",
                "y_array_constr"
            ],
            "test_euclidean_distances_sym": [
                "dtype",
                "x_array_constr"
            ],
            "test_euclidean_distances_extreme_values": [
                "dtype",
                "eps",
                "rtol",
                "dim"
            ],
            "test_cosine_distances": [],
            "test_haversine_distances": [],
            "test_paired_euclidean_distances": [],
            "test_paired_manhattan_distances": [],
            "test_chi_square_kernel": [],
            "test_kernel_symmetry": [
                "kernel"
            ],
            "test_kernel_sparse": [
                "kernel"
            ],
            "test_linear_kernel": [],
            "test_rbf_kernel": [],
            "test_laplacian_kernel": [],
            "test_pairwise_similarity_sparse_output": [
                "metric",
                "pairwise_func"
            ],
            "test_cosine_similarity": [],
            "test_check_dense_matrices": [],
            "test_check_XB_returned": [],
            "test_check_different_dimensions": [],
            "test_check_invalid_dimensions": [],
            "test_check_sparse_arrays": [],
            "tuplify": [
                "X"
            ],
            "test_check_tuple_input": [],
            "test_check_preserve_type": [],
            "test_pairwise_distances_data_derived_params": [
                "n_jobs",
                "metric",
                "dist_function",
                "y_is_x"
            ]
        },
        "sklearn.metrics.tests.test_common": {
            "precision_recall_curve_padded_thresholds": [],
            "test_symmetry": [],
            "test_sample_order_invariance": [
                "name"
            ],
            "test_sample_order_invariance_multilabel_and_multioutput": [],
            "test_format_invariance_with_1d_vectors": [
                "name"
            ],
            "test_classification_invariance_string_vs_numbers_labels": [
                "name"
            ],
            "test_thresholded_invariance_string_vs_numbers_labels": [
                "name"
            ],
            "test_regression_thresholded_inf_nan_input": [
                "metric"
            ],
            "test_classification_inf_nan_input": [
                "metric"
            ],
            "check_single_sample": [
                "name"
            ],
            "check_single_sample_multioutput": [
                "name"
            ],
            "test_single_sample": [
                "name"
            ],
            "test_single_sample_multioutput": [
                "name"
            ],
            "test_multioutput_number_of_output_differ": [
                "name"
            ],
            "test_multioutput_regression_invariance_to_dimension_shuffling": [
                "name"
            ],
            "test_multilabel_representation_invariance": [],
            "test_raise_value_error_multilabel_sequences": [
                "name"
            ],
            "test_normalize_option_binary_classification": [
                "name"
            ],
            "test_normalize_option_multiclass_classification": [
                "name"
            ],
            "test_normalize_option_multilabel_classification": [],
            "_check_averaging": [
                "metric",
                "y_true",
                "y_pred",
                "y_true_binarize",
                "y_pred_binarize",
                "is_multilabel"
            ],
            "check_averaging": [
                "name",
                "y_true",
                "y_true_binarize",
                "y_pred",
                "y_pred_binarize",
                "y_score"
            ],
            "test_averaging_multiclass": [
                "name"
            ],
            "test_averaging_multilabel": [
                "name"
            ],
            "test_averaging_multilabel_all_zeroes": [
                "name"
            ],
            "test_averaging_binary_multilabel_all_zeroes": [],
            "test_averaging_multilabel_all_ones": [
                "name"
            ],
            "check_sample_weight_invariance": [
                "name",
                "metric",
                "y1",
                "y2"
            ],
            "test_regression_sample_weight_invariance": [
                "name"
            ],
            "test_binary_sample_weight_invariance": [
                "name"
            ],
            "test_multiclass_sample_weight_invariance": [
                "name"
            ],
            "test_multilabel_sample_weight_invariance": [
                "name"
            ],
            "test_no_averaging_labels": [],
            "test_multilabel_label_permutations_invariance": [
                "name"
            ],
            "test_thresholded_multilabel_multioutput_permutations_invariance": [
                "name"
            ]
        },
        "sklearn.metrics.cluster.supervised": {
            "_comb2": [
                "n"
            ],
            "check_clusterings": [
                "labels_true",
                "labels_pred"
            ],
            "_generalized_average": [
                "U",
                "V",
                "average_method"
            ],
            "contingency_matrix": [
                "labels_true",
                "labels_pred",
                "eps",
                "sparse"
            ],
            "adjusted_rand_score": [
                "labels_true",
                "labels_pred"
            ],
            "homogeneity_completeness_v_measure": [
                "labels_true",
                "labels_pred",
                "beta"
            ],
            "homogeneity_score": [
                "labels_true",
                "labels_pred"
            ],
            "completeness_score": [
                "labels_true",
                "labels_pred"
            ],
            "v_measure_score": [
                "labels_true",
                "labels_pred",
                "beta"
            ],
            "mutual_info_score": [
                "labels_true",
                "labels_pred",
                "contingency"
            ],
            "adjusted_mutual_info_score": [
                "labels_true",
                "labels_pred",
                "average_method"
            ],
            "normalized_mutual_info_score": [
                "labels_true",
                "labels_pred",
                "average_method"
            ],
            "fowlkes_mallows_score": [
                "labels_true",
                "labels_pred",
                "sparse"
            ],
            "entropy": [
                "labels"
            ]
        },
        "sklearn.metrics.cluster.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.metrics.cluster": {},
        "sklearn.metrics.cluster.bicluster": {
            "_check_rows_and_columns": [
                "a",
                "b"
            ],
            "_jaccard": [
                "a_rows",
                "a_cols",
                "b_rows",
                "b_cols"
            ],
            "_pairwise_similarity": [
                "a",
                "b",
                "similarity"
            ],
            "consensus_score": [
                "a",
                "b",
                "similarity"
            ]
        },
        "sklearn.metrics.cluster.unsupervised": {
            "check_number_of_labels": [
                "n_labels",
                "n_samples"
            ],
            "silhouette_score": [
                "X",
                "labels",
                "metric",
                "sample_size",
                "random_state"
            ],
            "_silhouette_reduce": [
                "D_chunk",
                "start",
                "labels",
                "label_freqs"
            ],
            "silhouette_samples": [
                "X",
                "labels",
                "metric"
            ],
            "calinski_harabasz_score": [
                "X",
                "labels"
            ],
            "calinski_harabaz_score": [
                "X",
                "labels"
            ],
            "davies_bouldin_score": [
                "X",
                "labels"
            ]
        },
        "sklearn.metrics.cluster.tests.test_supervised": {
            "test_future_warning": [],
            "test_error_messages_on_wrong_input": [],
            "test_generalized_average": [],
            "test_perfect_matches": [],
            "test_homogeneous_but_not_complete_labeling": [],
            "test_complete_but_not_homogeneous_labeling": [],
            "test_not_complete_and_not_homogeneous_labeling": [],
            "test_beta_parameter": [],
            "test_non_consecutive_labels": [],
            "uniform_labelings_scores": [
                "score_func",
                "n_samples",
                "k_range",
                "n_runs",
                "seed"
            ],
            "test_adjustment_for_chance": [],
            "test_adjusted_mutual_info_score": [],
            "test_expected_mutual_info_overflow": [],
            "test_int_overflow_mutual_info_fowlkes_mallows_score": [],
            "test_entropy": [],
            "test_contingency_matrix": [],
            "test_contingency_matrix_sparse": [],
            "test_exactly_zero_info_score": [],
            "test_v_measure_and_mutual_information": [
                "seed"
            ],
            "test_fowlkes_mallows_score": [],
            "test_fowlkes_mallows_score_properties": []
        },
        "sklearn.metrics.cluster.tests": {},
        "sklearn.metrics.cluster.tests.test_bicluster": {
            "test_jaccard": [],
            "test_consensus_score": [],
            "test_consensus_score_issue2445": []
        },
        "sklearn.metrics.cluster.tests.test_common": {
            "test_symmetric_non_symmetric_union": [],
            "test_symmetry": [
                "metric_name",
                "y1",
                "y2"
            ],
            "test_non_symmetry": [
                "metric_name",
                "y1",
                "y2"
            ],
            "test_normalized_output": [
                "metric_name"
            ],
            "test_permute_labels": [
                "metric_name"
            ],
            "test_format_invariance": [
                "metric_name"
            ]
        },
        "sklearn.metrics.cluster.tests.test_unsupervised": {
            "test_silhouette": [],
            "test_cluster_size_1": [],
            "test_silhouette_paper_example": [],
            "test_correct_labelsize": [],
            "test_non_encoded_labels": [],
            "test_non_numpy_labels": [],
            "assert_raises_on_only_one_label": [
                "func"
            ],
            "assert_raises_on_all_points_same_cluster": [
                "func"
            ],
            "test_calinski_harabasz_score": [],
            "test_deprecated_calinski_harabaz_score": [],
            "test_davies_bouldin_score": []
        },
        "sklearn.mixture": {},
        "sklearn.mixture.base": {
            "_check_shape": [
                "param",
                "param_shape",
                "name"
            ],
            "_check_X": [
                "X",
                "n_components",
                "n_features",
                "ensure_min_samples"
            ],
            "BaseMixture": {
                "__init__": [
                    "self",
                    "n_components",
                    "tol",
                    "reg_covar",
                    "max_iter",
                    "n_init",
                    "init_params",
                    "random_state",
                    "warm_start",
                    "verbose",
                    "verbose_interval"
                ],
                "_check_initial_parameters": [
                    "self",
                    "X"
                ],
                "_check_parameters": [
                    "self",
                    "X"
                ],
                "_initialize_parameters": [
                    "self",
                    "X",
                    "random_state"
                ],
                "_initialize": [
                    "self",
                    "X",
                    "resp"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_predict": [
                    "self",
                    "X",
                    "y"
                ],
                "_e_step": [
                    "self",
                    "X"
                ],
                "_m_step": [
                    "self",
                    "X",
                    "log_resp"
                ],
                "_check_is_fitted": [
                    "self"
                ],
                "_get_parameters": [
                    "self"
                ],
                "_set_parameters": [
                    "self",
                    "params"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "sample": [
                    "self",
                    "n_samples"
                ],
                "_estimate_weighted_log_prob": [
                    "self",
                    "X"
                ],
                "_estimate_log_weights": [
                    "self"
                ],
                "_estimate_log_prob": [
                    "self",
                    "X"
                ],
                "_estimate_log_prob_resp": [
                    "self",
                    "X"
                ],
                "_print_verbose_msg_init_beg": [
                    "self",
                    "n_init"
                ],
                "_print_verbose_msg_iter_end": [
                    "self",
                    "n_iter",
                    "diff_ll"
                ],
                "_print_verbose_msg_init_end": [
                    "self",
                    "ll"
                ]
            }
        },
        "sklearn.mixture.bayesian_mixture": {
            "_log_dirichlet_norm": [
                "dirichlet_concentration"
            ],
            "_log_wishart_norm": [
                "degrees_of_freedom",
                "log_det_precisions_chol",
                "n_features"
            ],
            "BayesianGaussianMixture": {
                "__init__": [
                    "self",
                    "n_components",
                    "covariance_type",
                    "tol",
                    "reg_covar",
                    "max_iter",
                    "n_init",
                    "init_params",
                    "weight_concentration_prior_type",
                    "weight_concentration_prior",
                    "mean_precision_prior",
                    "mean_prior",
                    "degrees_of_freedom_prior",
                    "covariance_prior",
                    "random_state",
                    "warm_start",
                    "verbose",
                    "verbose_interval"
                ],
                "_check_parameters": [
                    "self",
                    "X"
                ],
                "_check_weights_parameters": [
                    "self"
                ],
                "_check_means_parameters": [
                    "self",
                    "X"
                ],
                "_check_precision_parameters": [
                    "self",
                    "X"
                ],
                "_checkcovariance_prior_parameter": [
                    "self",
                    "X"
                ],
                "_initialize": [
                    "self",
                    "X",
                    "resp"
                ],
                "_estimate_weights": [
                    "self",
                    "nk"
                ],
                "_estimate_means": [
                    "self",
                    "nk",
                    "xk"
                ],
                "_estimate_precisions": [
                    "self",
                    "nk",
                    "xk",
                    "sk"
                ],
                "_estimate_wishart_full": [
                    "self",
                    "nk",
                    "xk",
                    "sk"
                ],
                "_estimate_wishart_tied": [
                    "self",
                    "nk",
                    "xk",
                    "sk"
                ],
                "_estimate_wishart_diag": [
                    "self",
                    "nk",
                    "xk",
                    "sk"
                ],
                "_estimate_wishart_spherical": [
                    "self",
                    "nk",
                    "xk",
                    "sk"
                ],
                "_check_is_fitted": [
                    "self"
                ],
                "_m_step": [
                    "self",
                    "X",
                    "log_resp"
                ],
                "_estimate_log_weights": [
                    "self"
                ],
                "_estimate_log_prob": [
                    "self",
                    "X"
                ],
                "_compute_lower_bound": [
                    "self",
                    "log_resp",
                    "log_prob_norm"
                ],
                "_get_parameters": [
                    "self"
                ],
                "_set_parameters": [
                    "self",
                    "params"
                ]
            }
        },
        "sklearn.mixture.gaussian_mixture": {
            "_check_weights": [
                "weights",
                "n_components"
            ],
            "_check_means": [
                "means",
                "n_components",
                "n_features"
            ],
            "_check_precision_positivity": [
                "precision",
                "covariance_type"
            ],
            "_check_precision_matrix": [
                "precision",
                "covariance_type"
            ],
            "_check_precisions_full": [
                "precisions",
                "covariance_type"
            ],
            "_check_precisions": [
                "precisions",
                "covariance_type",
                "n_components",
                "n_features"
            ],
            "_estimate_gaussian_covariances_full": [
                "resp",
                "X",
                "nk",
                "means",
                "reg_covar"
            ],
            "_estimate_gaussian_covariances_tied": [
                "resp",
                "X",
                "nk",
                "means",
                "reg_covar"
            ],
            "_estimate_gaussian_covariances_diag": [
                "resp",
                "X",
                "nk",
                "means",
                "reg_covar"
            ],
            "_estimate_gaussian_covariances_spherical": [
                "resp",
                "X",
                "nk",
                "means",
                "reg_covar"
            ],
            "_estimate_gaussian_parameters": [
                "X",
                "resp",
                "reg_covar",
                "covariance_type"
            ],
            "_compute_precision_cholesky": [
                "covariances",
                "covariance_type"
            ],
            "_compute_log_det_cholesky": [
                "matrix_chol",
                "covariance_type",
                "n_features"
            ],
            "_estimate_log_gaussian_prob": [
                "X",
                "means",
                "precisions_chol",
                "covariance_type"
            ],
            "GaussianMixture": {
                "__init__": [
                    "self",
                    "n_components",
                    "covariance_type",
                    "tol",
                    "reg_covar",
                    "max_iter",
                    "n_init",
                    "init_params",
                    "weights_init",
                    "means_init",
                    "precisions_init",
                    "random_state",
                    "warm_start",
                    "verbose",
                    "verbose_interval"
                ],
                "_check_parameters": [
                    "self",
                    "X"
                ],
                "_initialize": [
                    "self",
                    "X",
                    "resp"
                ],
                "_m_step": [
                    "self",
                    "X",
                    "log_resp"
                ],
                "_estimate_log_prob": [
                    "self",
                    "X"
                ],
                "_estimate_log_weights": [
                    "self"
                ],
                "_compute_lower_bound": [
                    "self",
                    "_",
                    "log_prob_norm"
                ],
                "_check_is_fitted": [
                    "self"
                ],
                "_get_parameters": [
                    "self"
                ],
                "_set_parameters": [
                    "self",
                    "params"
                ],
                "_n_parameters": [
                    "self"
                ],
                "bic": [
                    "self",
                    "X"
                ],
                "aic": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.mixture.tests": {},
        "sklearn.mixture.tests.test_mixture": {
            "test_gaussian_mixture_n_iter": [
                "estimator"
            ]
        },
        "sklearn.mixture.tests.test_gaussian_mixture": {
            "generate_data": [
                "n_samples",
                "n_features",
                "weights",
                "means",
                "precisions",
                "covariance_type"
            ],
            "test_gaussian_mixture_attributes": [],
            "test_check_X": [],
            "test_check_weights": [],
            "test_check_means": [],
            "test_check_precisions": [],
            "test_suffstat_sk_full": [],
            "test_suffstat_sk_tied": [],
            "test_suffstat_sk_diag": [],
            "test_gaussian_suffstat_sk_spherical": [],
            "test_compute_log_det_cholesky": [],
            "_naive_lmvnpdf_diag": [
                "X",
                "means",
                "covars"
            ],
            "test_gaussian_mixture_log_probabilities": [],
            "test_gaussian_mixture_estimate_log_prob_resp": [],
            "test_gaussian_mixture_predict_predict_proba": [],
            "test_gaussian_mixture_fit_predict": [
                "seed",
                "max_iter",
                "tol"
            ],
            "test_gaussian_mixture_fit_predict_n_init": [],
            "test_gaussian_mixture_fit": [],
            "test_gaussian_mixture_fit_best_params": [],
            "test_gaussian_mixture_fit_convergence_warning": [],
            "test_multiple_init": [],
            "test_gaussian_mixture_n_parameters": [],
            "test_bic_1d_1component": [],
            "test_gaussian_mixture_aic_bic": [],
            "test_gaussian_mixture_verbose": [],
            "test_warm_start": [
                "seed"
            ],
            "test_convergence_detected_with_warm_start": [],
            "test_score": [],
            "test_score_samples": [],
            "test_monotonic_likelihood": [],
            "test_regularisation": [],
            "test_property": [],
            "test_sample": [],
            "test_init": [],
            "RandomData": {
                "__init__": [
                    "self",
                    "rng",
                    "n_samples",
                    "n_components",
                    "n_features",
                    "scale"
                ]
            }
        },
        "sklearn.mixture.tests.test_bayesian_mixture": {
            "test_log_dirichlet_norm": [],
            "test_log_wishart_norm": [],
            "test_bayesian_mixture_covariance_type": [],
            "test_bayesian_mixture_weight_concentration_prior_type": [],
            "test_bayesian_mixture_weights_prior_initialisation": [],
            "test_bayesian_mixture_mean_prior_initialisation": [],
            "test_bayesian_mixture_precisions_prior_initialisation": [],
            "test_bayesian_mixture_check_is_fitted": [],
            "test_bayesian_mixture_weights": [],
            "test_monotonic_likelihood": [],
            "test_compare_covar_type": [],
            "test_check_covariance_precision": [],
            "test_invariant_translation": [],
            "test_bayesian_mixture_fit_predict": [
                "seed",
                "max_iter",
                "tol"
            ],
            "test_bayesian_mixture_fit_predict_n_init": [],
            "test_bayesian_mixture_predict_predict_proba": []
        },
        "sklearn.__check_build.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.__check_build": {
            "raise_build_error": [
                "e"
            ]
        },
        "sklearn.covariance.graph_lasso_": {
            "_objective": [
                "mle",
                "precision_",
                "alpha"
            ],
            "_dual_gap": [
                "emp_cov",
                "precision_",
                "alpha"
            ],
            "alpha_max": [
                "emp_cov"
            ],
            "graphical_lasso": [
                "emp_cov",
                "alpha",
                "cov_init",
                "mode",
                "tol",
                "enet_tol",
                "max_iter",
                "verbose",
                "return_costs",
                "eps",
                "return_n_iter"
            ],
            "graphical_lasso_path": [
                "X",
                "alphas",
                "cov_init",
                "X_test",
                "mode",
                "tol",
                "enet_tol",
                "max_iter",
                "verbose"
            ],
            "graph_lasso": [
                "emp_cov",
                "alpha",
                "cov_init",
                "mode",
                "tol",
                "enet_tol",
                "max_iter",
                "verbose",
                "return_costs",
                "eps",
                "return_n_iter"
            ],
            "GraphicalLasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "mode",
                    "tol",
                    "enet_tol",
                    "max_iter",
                    "verbose",
                    "assume_centered"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "GraphicalLassoCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "n_refinements",
                    "cv",
                    "tol",
                    "enet_tol",
                    "max_iter",
                    "mode",
                    "n_jobs",
                    "verbose",
                    "assume_centered"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "GraphLasso": {},
            "GraphLassoCV": {}
        },
        "sklearn.covariance": {},
        "sklearn.covariance.shrunk_covariance_": {
            "shrunk_covariance": [
                "emp_cov",
                "shrinkage"
            ],
            "ledoit_wolf_shrinkage": [
                "X",
                "assume_centered",
                "block_size"
            ],
            "ledoit_wolf": [
                "X",
                "assume_centered",
                "block_size"
            ],
            "oas": [
                "X",
                "assume_centered"
            ],
            "ShrunkCovariance": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "shrinkage"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LedoitWolf": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "block_size"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "OAS": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.covariance.empirical_covariance_": {
            "log_likelihood": [
                "emp_cov",
                "precision"
            ],
            "empirical_covariance": [
                "X",
                "assume_centered"
            ],
            "EmpiricalCovariance": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered"
                ],
                "_set_covariance": [
                    "self",
                    "covariance"
                ],
                "get_precision": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "score": [
                    "self",
                    "X_test",
                    "y"
                ],
                "error_norm": [
                    "self",
                    "comp_cov",
                    "norm",
                    "scaling",
                    "squared"
                ],
                "mahalanobis": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.covariance.robust_covariance": {
            "c_step": [
                "X",
                "n_support",
                "remaining_iterations",
                "initial_estimates",
                "verbose",
                "cov_computation_method",
                "random_state"
            ],
            "_c_step": [
                "X",
                "n_support",
                "random_state",
                "remaining_iterations",
                "initial_estimates",
                "verbose",
                "cov_computation_method"
            ],
            "select_candidates": [
                "X",
                "n_support",
                "n_trials",
                "select",
                "n_iter",
                "verbose",
                "cov_computation_method",
                "random_state"
            ],
            "fast_mcd": [
                "X",
                "support_fraction",
                "cov_computation_method",
                "random_state"
            ],
            "MinCovDet": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "support_fraction",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "correct_covariance": [
                    "self",
                    "data"
                ],
                "reweight_covariance": [
                    "self",
                    "data"
                ]
            }
        },
        "sklearn.covariance.elliptic_envelope": {
            "EllipticEnvelope": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "support_fraction",
                    "contamination",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X",
                    "raw_values"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "threshold_": [
                    "self"
                ]
            }
        },
        "sklearn.covariance.tests.test_elliptic_envelope": {
            "test_elliptic_envelope": [],
            "test_score_samples": [],
            "test_raw_values_deprecation": [],
            "test_threshold_deprecation": []
        },
        "sklearn.covariance.tests.test_robust_covariance": {
            "test_mcd": [],
            "test_fast_mcd_on_invalid_input": [],
            "test_mcd_class_on_invalid_input": [],
            "launch_mcd_on_dataset": [
                "n_samples",
                "n_features",
                "n_outliers",
                "tol_loc",
                "tol_cov",
                "tol_support"
            ],
            "test_mcd_issue1127": [],
            "test_mcd_issue3367": [],
            "test_mcd_support_covariance_is_zero": [],
            "test_mcd_increasing_det_warning": []
        },
        "sklearn.covariance.tests.test_graphical_lasso": {
            "test_graphical_lasso": [
                "random_state"
            ],
            "test_graphical_lasso_iris": [],
            "test_graph_lasso_2D": [],
            "test_graphical_lasso_iris_singular": [],
            "test_graphical_lasso_cv": [
                "random_state"
            ]
        },
        "sklearn.covariance.tests": {},
        "sklearn.covariance.tests.test_graph_lasso": {
            "test_graph_lasso": [
                "random_state"
            ],
            "test_graph_lasso_iris": [],
            "test_graph_lasso_iris_singular": [],
            "test_graph_lasso_cv": [
                "random_state"
            ]
        },
        "sklearn.covariance.tests.test_covariance": {
            "test_covariance": [],
            "test_shrunk_covariance": [],
            "test_ledoit_wolf": [],
            "_naive_ledoit_wolf_shrinkage": [
                "X"
            ],
            "test_ledoit_wolf_small": [],
            "test_ledoit_wolf_large": [],
            "test_oas": []
        },
        "sklearn.utils.stats": {
            "_weighted_percentile": [
                "array",
                "sample_weight",
                "percentile"
            ]
        },
        "sklearn.utils.sparsefuncs": {
            "_raise_typeerror": [
                "X"
            ],
            "_raise_error_wrong_axis": [
                "axis"
            ],
            "inplace_csr_column_scale": [
                "X",
                "scale"
            ],
            "inplace_csr_row_scale": [
                "X",
                "scale"
            ],
            "mean_variance_axis": [
                "X",
                "axis"
            ],
            "incr_mean_variance_axis": [
                "X",
                "axis",
                "last_mean",
                "last_var",
                "last_n"
            ],
            "inplace_column_scale": [
                "X",
                "scale"
            ],
            "inplace_row_scale": [
                "X",
                "scale"
            ],
            "inplace_swap_row_csc": [
                "X",
                "m",
                "n"
            ],
            "inplace_swap_row_csr": [
                "X",
                "m",
                "n"
            ],
            "inplace_swap_row": [
                "X",
                "m",
                "n"
            ],
            "inplace_swap_column": [
                "X",
                "m",
                "n"
            ],
            "_minor_reduce": [
                "X",
                "ufunc"
            ],
            "_min_or_max_axis": [
                "X",
                "axis",
                "min_or_max"
            ],
            "_sparse_min_or_max": [
                "X",
                "axis",
                "min_or_max"
            ],
            "_sparse_min_max": [
                "X",
                "axis"
            ],
            "_sparse_nan_min_max": [
                "X",
                "axis"
            ],
            "min_max_axis": [
                "X",
                "axis",
                "ignore_nan"
            ],
            "count_nonzero": [
                "X",
                "axis",
                "sample_weight"
            ],
            "_get_median": [
                "data",
                "n_zeros"
            ],
            "_get_elem_at_rank": [
                "rank",
                "data",
                "n_negative",
                "n_zeros"
            ],
            "csc_median_axis_0": [
                "X"
            ]
        },
        "sklearn.utils.graph": {
            "single_source_shortest_path_length": [
                "graph",
                "source",
                "cutoff"
            ]
        },
        "sklearn.utils._joblib": {},
        "sklearn.utils.fixes": {
            "_parse_version": [
                "version_string"
            ],
            "parallel_helper": [
                "obj",
                "methodname"
            ],
            "_astype_copy_false": [
                "X"
            ],
            "_joblib_parallel_args": []
        },
        "sklearn.utils.mocking": {
            "ArraySlicingWrapper": {
                "__init__": [
                    "self",
                    "array"
                ],
                "__getitem__": [
                    "self",
                    "aslice"
                ]
            },
            "MockDataFrame": {
                "__init__": [
                    "self",
                    "array"
                ],
                "__len__": [
                    "self"
                ],
                "__array__": [
                    "self",
                    "dtype"
                ],
                "__eq__": [
                    "self",
                    "other"
                ],
                "__ne__": [
                    "self",
                    "other"
                ]
            },
            "CheckingClassifier": {
                "__init__": [
                    "self",
                    "check_y",
                    "check_X",
                    "foo_param",
                    "expected_fit_params"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.utils.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.utils.class_weight": {
            "compute_class_weight": [
                "class_weight",
                "classes",
                "y"
            ],
            "compute_sample_weight": [
                "class_weight",
                "y",
                "indices"
            ]
        },
        "sklearn.utils.random": {
            "random_choice_csc": [
                "n_samples",
                "classes",
                "class_probability",
                "random_state"
            ]
        },
        "sklearn.utils.testing": {
            "assert_warns": [
                "warning_class",
                "func"
            ],
            "assert_warns_message": [
                "warning_class",
                "message",
                "func"
            ],
            "assert_warns_div0": [
                "func"
            ],
            "assert_no_warnings": [
                "func"
            ],
            "ignore_warnings": [
                "obj",
                "category"
            ],
            "assert_raise_message": [
                "exceptions",
                "message",
                "function"
            ],
            "assert_allclose_dense_sparse": [
                "x",
                "y",
                "rtol",
                "atol",
                "err_msg"
            ],
            "fake_mldata": [
                "columns_dict",
                "dataname",
                "matfile",
                "ordering"
            ],
            "install_mldata_mock": [
                "mock_datasets"
            ],
            "uninstall_mldata_mock": [],
            "all_estimators": [
                "include_meta_estimators",
                "include_other",
                "type_filter",
                "include_dont_test"
            ],
            "set_random_state": [
                "estimator",
                "random_state"
            ],
            "if_matplotlib": [
                "func"
            ],
            "clean_warning_registry": [],
            "check_skip_network": [],
            "_delete_folder": [
                "folder_path",
                "warn"
            ],
            "create_memmap_backed_data": [
                "data",
                "mmap_mode",
                "return_folder"
            ],
            "_get_args": [
                "function",
                "varargs"
            ],
            "_get_func_name": [
                "func",
                "class_name"
            ],
            "check_docstring_parameters": [
                "func",
                "doc",
                "ignore",
                "class_name"
            ],
            "assert_run_python_script": [
                "source_code",
                "timeout"
            ],
            "close_figure": [
                "fig"
            ],
            "_IgnoreWarnings": {
                "__init__": [
                    "self",
                    "category"
                ],
                "__call__": [
                    "self",
                    "fn"
                ],
                "__repr__": [
                    "self"
                ],
                "__enter__": [
                    "self"
                ],
                "__exit__": [
                    "self"
                ]
            },
            "mock_mldata_urlopen": {
                "__init__": [
                    "self",
                    "mock_datasets"
                ],
                "__call__": [
                    "self",
                    "urlname"
                ]
            },
            "TempMemmap": {
                "__init__": [
                    "self",
                    "data",
                    "mmap_mode"
                ],
                "__enter__": [
                    "self"
                ],
                "__exit__": [
                    "self",
                    "exc_type",
                    "exc_val",
                    "exc_tb"
                ]
            }
        },
        "sklearn.utils": {
            "safe_mask": [
                "X",
                "mask"
            ],
            "axis0_safe_slice": [
                "X",
                "mask",
                "len_mask"
            ],
            "safe_indexing": [
                "X",
                "indices"
            ],
            "resample": [],
            "shuffle": [],
            "safe_sqr": [
                "X",
                "copy"
            ],
            "gen_batches": [
                "n",
                "batch_size",
                "min_batch_size"
            ],
            "gen_even_slices": [
                "n",
                "n_packs",
                "n_samples"
            ],
            "tosequence": [
                "x"
            ],
            "indices_to_mask": [
                "indices",
                "mask_length"
            ],
            "_message_with_time": [
                "source",
                "message",
                "time"
            ],
            "_print_elapsed_time": [
                "source",
                "message"
            ],
            "get_chunk_n_rows": [
                "row_bytes",
                "max_n_rows",
                "working_memory"
            ],
            "is_scalar_nan": [
                "x"
            ],
            "_approximate_mode": [
                "class_counts",
                "n_draws",
                "rng"
            ],
            "check_matplotlib_support": [
                "caller_name"
            ],
            "Memory": {},
            "Parallel": {},
            "Bunch": {
                "__init__": [
                    "self"
                ],
                "__setattr__": [
                    "self",
                    "key",
                    "value"
                ],
                "__dir__": [
                    "self"
                ],
                "__getattr__": [
                    "self",
                    "key"
                ],
                "__setstate__": [
                    "self",
                    "state"
                ]
            }
        },
        "sklearn.utils._show_versions": {
            "_get_sys_info": [],
            "_get_deps_info": [],
            "_get_blas_info": [],
            "show_versions": []
        },
        "sklearn.utils.estimator_checks": {
            "_safe_tags": [
                "estimator",
                "key"
            ],
            "_yield_checks": [
                "name",
                "estimator"
            ],
            "_yield_classifier_checks": [
                "name",
                "classifier"
            ],
            "check_supervised_y_no_nan": [
                "name",
                "estimator_orig"
            ],
            "_yield_regressor_checks": [
                "name",
                "regressor"
            ],
            "_yield_transformer_checks": [
                "name",
                "transformer"
            ],
            "_yield_clustering_checks": [
                "name",
                "clusterer"
            ],
            "_yield_outliers_checks": [
                "name",
                "estimator"
            ],
            "_yield_all_checks": [
                "name",
                "estimator"
            ],
            "check_estimator": [
                "Estimator"
            ],
            "_boston_subset": [
                "n_samples"
            ],
            "set_checking_parameters": [
                "estimator"
            ],
            "_is_pairwise": [
                "estimator"
            ],
            "_is_pairwise_metric": [
                "estimator"
            ],
            "pairwise_estimator_convert_X": [
                "X",
                "estimator",
                "kernel"
            ],
            "_generate_sparse_matrix": [
                "X_csr"
            ],
            "check_estimator_sparse_data": [
                "name",
                "estimator_orig"
            ],
            "check_sample_weights_pandas_series": [
                "name",
                "estimator_orig"
            ],
            "check_sample_weights_list": [
                "name",
                "estimator_orig"
            ],
            "check_sample_weights_invariance": [
                "name",
                "estimator_orig"
            ],
            "check_dtype_object": [
                "name",
                "estimator_orig"
            ],
            "check_complex_data": [
                "name",
                "estimator_orig"
            ],
            "check_dict_unchanged": [
                "name",
                "estimator_orig"
            ],
            "is_public_parameter": [
                "attr"
            ],
            "check_dont_overwrite_parameters": [
                "name",
                "estimator_orig"
            ],
            "check_fit2d_predict1d": [
                "name",
                "estimator_orig"
            ],
            "_apply_on_subsets": [
                "func",
                "X"
            ],
            "check_methods_subset_invariance": [
                "name",
                "estimator_orig"
            ],
            "check_fit2d_1sample": [
                "name",
                "estimator_orig"
            ],
            "check_fit2d_1feature": [
                "name",
                "estimator_orig"
            ],
            "check_fit1d": [
                "name",
                "estimator_orig"
            ],
            "check_transformer_general": [
                "name",
                "transformer",
                "readonly_memmap"
            ],
            "check_transformer_data_not_an_array": [
                "name",
                "transformer"
            ],
            "check_transformers_unfitted": [
                "name",
                "transformer"
            ],
            "_check_transformer": [
                "name",
                "transformer_orig",
                "X",
                "y"
            ],
            "check_pipeline_consistency": [
                "name",
                "estimator_orig"
            ],
            "check_fit_score_takes_y": [
                "name",
                "estimator_orig"
            ],
            "check_estimators_dtypes": [
                "name",
                "estimator_orig"
            ],
            "check_estimators_empty_data_messages": [
                "name",
                "estimator_orig"
            ],
            "check_estimators_nan_inf": [
                "name",
                "estimator_orig"
            ],
            "check_estimators_pickle": [
                "name",
                "estimator_orig"
            ],
            "check_estimators_partial_fit_n_features": [
                "name",
                "estimator_orig"
            ],
            "check_clustering": [
                "name",
                "clusterer_orig",
                "readonly_memmap"
            ],
            "check_clusterer_compute_labels_predict": [
                "name",
                "clusterer_orig"
            ],
            "check_classifiers_one_label": [
                "name",
                "classifier_orig"
            ],
            "check_classifiers_train": [
                "name",
                "classifier_orig",
                "readonly_memmap"
            ],
            "check_outlier_corruption": [
                "num_outliers",
                "expected_outliers",
                "decision"
            ],
            "check_outliers_train": [
                "name",
                "estimator_orig",
                "readonly_memmap"
            ],
            "check_estimators_fit_returns_self": [
                "name",
                "estimator_orig",
                "readonly_memmap"
            ],
            "check_estimators_unfitted": [
                "name",
                "estimator_orig"
            ],
            "check_supervised_y_2d": [
                "name",
                "estimator_orig"
            ],
            "check_classifiers_predictions": [
                "X",
                "y",
                "name",
                "classifier_orig"
            ],
            "choose_check_classifiers_labels": [
                "name",
                "y",
                "y_names"
            ],
            "check_classifiers_classes": [
                "name",
                "classifier_orig"
            ],
            "check_regressors_int": [
                "name",
                "regressor_orig"
            ],
            "check_regressors_train": [
                "name",
                "regressor_orig",
                "readonly_memmap"
            ],
            "check_regressors_no_decision_function": [
                "name",
                "regressor_orig"
            ],
            "check_class_weight_classifiers": [
                "name",
                "classifier_orig"
            ],
            "check_class_weight_balanced_classifiers": [
                "name",
                "classifier_orig",
                "X_train",
                "y_train",
                "X_test",
                "y_test",
                "weights"
            ],
            "check_class_weight_balanced_linear_classifier": [
                "name",
                "Classifier"
            ],
            "check_estimators_overwrite_params": [
                "name",
                "estimator_orig"
            ],
            "check_no_attributes_set_in_init": [
                "name",
                "estimator"
            ],
            "check_sparsify_coefficients": [
                "name",
                "estimator_orig"
            ],
            "check_classifier_data_not_an_array": [
                "name",
                "estimator_orig"
            ],
            "check_regressor_data_not_an_array": [
                "name",
                "estimator_orig"
            ],
            "check_estimators_data_not_an_array": [
                "name",
                "estimator_orig",
                "X",
                "y"
            ],
            "check_parameters_default_constructible": [
                "name",
                "Estimator"
            ],
            "multioutput_estimator_convert_y_2d": [
                "estimator",
                "y"
            ],
            "check_non_transformer_estimators_n_iter": [
                "name",
                "estimator_orig"
            ],
            "check_transformer_n_iter": [
                "name",
                "estimator_orig"
            ],
            "check_get_params_invariance": [
                "name",
                "estimator_orig"
            ],
            "check_set_params": [
                "name",
                "estimator_orig"
            ],
            "check_classifiers_regression_target": [
                "name",
                "estimator_orig"
            ],
            "check_decision_proba_consistency": [
                "name",
                "estimator_orig"
            ],
            "check_outliers_fit_predict": [
                "name",
                "estimator_orig"
            ],
            "check_fit_idempotent": [
                "name",
                "estimator_orig"
            ],
            "NotAnArray": {
                "__init__": [
                    "self",
                    "data"
                ],
                "__array__": [
                    "self",
                    "dtype"
                ]
            }
        },
        "sklearn.utils.extmath": {
            "squared_norm": [
                "x"
            ],
            "row_norms": [
                "X",
                "squared"
            ],
            "fast_logdet": [
                "A"
            ],
            "density": [
                "w"
            ],
            "safe_sparse_dot": [
                "a",
                "b",
                "dense_output"
            ],
            "randomized_range_finder": [
                "A",
                "size",
                "n_iter",
                "power_iteration_normalizer",
                "random_state"
            ],
            "randomized_svd": [
                "M",
                "n_components",
                "n_oversamples",
                "n_iter",
                "power_iteration_normalizer",
                "transpose",
                "flip_sign",
                "random_state"
            ],
            "weighted_mode": [
                "a",
                "w",
                "axis"
            ],
            "cartesian": [
                "arrays",
                "out"
            ],
            "svd_flip": [
                "u",
                "v",
                "u_based_decision"
            ],
            "log_logistic": [
                "X",
                "out"
            ],
            "softmax": [
                "X",
                "copy"
            ],
            "safe_min": [
                "X"
            ],
            "make_nonnegative": [
                "X",
                "min_value"
            ],
            "_safe_accumulator_op": [
                "op",
                "x"
            ],
            "_incremental_mean_and_var": [
                "X",
                "last_mean",
                "last_variance",
                "last_sample_count"
            ],
            "_deterministic_vector_sign_flip": [
                "u"
            ],
            "stable_cumsum": [
                "arr",
                "axis",
                "rtol",
                "atol"
            ]
        },
        "sklearn.utils._pprint": {
            "_changed_params": [
                "estimator"
            ],
            "_safe_repr": [
                "object",
                "context",
                "maxlevels",
                "level",
                "changed_only"
            ],
            "KeyValTuple": {
                "__repr__": [
                    "self"
                ]
            },
            "KeyValTupleParam": {},
            "_EstimatorPrettyPrinter": {
                "__init__": [
                    "self",
                    "indent",
                    "width",
                    "depth",
                    "stream"
                ],
                "format": [
                    "self",
                    "object",
                    "context",
                    "maxlevels",
                    "level"
                ],
                "_pprint_estimator": [
                    "self",
                    "object",
                    "stream",
                    "indent",
                    "allowance",
                    "context",
                    "level"
                ],
                "_format_dict_items": [
                    "self",
                    "items",
                    "stream",
                    "indent",
                    "allowance",
                    "context",
                    "level"
                ],
                "_format_params": [
                    "self",
                    "items",
                    "stream",
                    "indent",
                    "allowance",
                    "context",
                    "level"
                ],
                "_format_params_or_dict_items": [
                    "self",
                    "object",
                    "stream",
                    "indent",
                    "allowance",
                    "context",
                    "level",
                    "is_dict"
                ],
                "_format_items": [
                    "self",
                    "items",
                    "stream",
                    "indent",
                    "allowance",
                    "context",
                    "level"
                ],
                "_pprint_key_val_tuple": [
                    "self",
                    "object",
                    "stream",
                    "indent",
                    "allowance",
                    "context",
                    "level"
                ]
            }
        },
        "sklearn.utils.multiclass": {
            "_unique_multiclass": [
                "y"
            ],
            "_unique_indicator": [
                "y"
            ],
            "unique_labels": [],
            "_is_integral_float": [
                "y"
            ],
            "is_multilabel": [
                "y"
            ],
            "check_classification_targets": [
                "y"
            ],
            "type_of_target": [
                "y"
            ],
            "_check_partial_fit_first_call": [
                "clf",
                "classes"
            ],
            "class_distribution": [
                "y",
                "sample_weight"
            ],
            "_ovr_decision_function": [
                "predictions",
                "confidences",
                "n_classes"
            ]
        },
        "sklearn.utils.deprecation": {
            "_is_deprecated": [
                "func"
            ],
            "deprecated": {
                "__init__": [
                    "self",
                    "extra"
                ],
                "__call__": [
                    "self",
                    "obj"
                ],
                "_decorate_class": [
                    "self",
                    "cls"
                ],
                "_decorate_fun": [
                    "self",
                    "fun"
                ],
                "_decorate_property": [
                    "self",
                    "prop"
                ],
                "_update_doc": [
                    "self",
                    "olddoc"
                ]
            }
        },
        "sklearn.utils.validation": {
            "_assert_all_finite": [
                "X",
                "allow_nan"
            ],
            "assert_all_finite": [
                "X",
                "allow_nan"
            ],
            "as_float_array": [
                "X",
                "copy",
                "force_all_finite"
            ],
            "_is_arraylike": [
                "x"
            ],
            "_num_samples": [
                "x"
            ],
            "check_memory": [
                "memory"
            ],
            "check_consistent_length": [],
            "indexable": [],
            "_ensure_sparse_format": [
                "spmatrix",
                "accept_sparse",
                "dtype",
                "copy",
                "force_all_finite",
                "accept_large_sparse"
            ],
            "_ensure_no_complex_data": [
                "array"
            ],
            "check_array": [
                "array",
                "accept_sparse",
                "accept_large_sparse",
                "dtype",
                "order",
                "copy",
                "force_all_finite",
                "ensure_2d",
                "allow_nd",
                "ensure_min_samples",
                "ensure_min_features",
                "warn_on_dtype",
                "estimator"
            ],
            "_check_large_sparse": [
                "X",
                "accept_large_sparse"
            ],
            "check_X_y": [
                "X",
                "y",
                "accept_sparse",
                "accept_large_sparse",
                "dtype",
                "order",
                "copy",
                "force_all_finite",
                "ensure_2d",
                "allow_nd",
                "multi_output",
                "ensure_min_samples",
                "ensure_min_features",
                "y_numeric",
                "warn_on_dtype",
                "estimator"
            ],
            "column_or_1d": [
                "y",
                "warn"
            ],
            "check_random_state": [
                "seed"
            ],
            "has_fit_parameter": [
                "estimator",
                "parameter"
            ],
            "check_symmetric": [
                "array",
                "tol",
                "raise_warning",
                "raise_exception"
            ],
            "check_is_fitted": [
                "estimator",
                "attributes",
                "msg",
                "all_or_any"
            ],
            "check_non_negative": [
                "X",
                "whom"
            ],
            "check_scalar": [
                "x",
                "name",
                "target_type",
                "min_val",
                "max_val"
            ]
        },
        "sklearn.utils.optimize": {
            "_line_search_wolfe12": [
                "f",
                "fprime",
                "xk",
                "pk",
                "gfk",
                "old_fval",
                "old_old_fval"
            ],
            "_cg": [
                "fhess_p",
                "fgrad",
                "maxiter",
                "tol"
            ],
            "newton_cg": [
                "grad_hess",
                "func",
                "grad",
                "x0",
                "args",
                "tol",
                "maxiter",
                "maxinner",
                "line_search",
                "warn"
            ],
            "_LineSearchError": {}
        },
        "sklearn.utils.linear_assignment_": {
            "linear_assignment": [
                "X"
            ],
            "_hungarian": [
                "cost_matrix"
            ],
            "_step1": [
                "state"
            ],
            "_step3": [
                "state"
            ],
            "_step4": [
                "state"
            ],
            "_step5": [
                "state"
            ],
            "_step6": [
                "state"
            ],
            "_HungarianState": {
                "__init__": [
                    "self",
                    "cost_matrix"
                ],
                "_clear_covers": [
                    "self"
                ]
            }
        },
        "sklearn.utils.metaestimators": {
            "if_delegate_has_method": [
                "delegate"
            ],
            "_safe_split": [
                "estimator",
                "X",
                "y",
                "indices",
                "train_indices"
            ],
            "_BaseComposition": {
                "__init__": [
                    "self"
                ],
                "_get_params": [
                    "self",
                    "attr",
                    "deep"
                ],
                "_set_params": [
                    "self",
                    "attr"
                ],
                "_replace_estimator": [
                    "self",
                    "attr",
                    "name",
                    "new_val"
                ],
                "_validate_names": [
                    "self",
                    "names"
                ]
            },
            "_IffHasAttrDescriptor": {
                "__init__": [
                    "self",
                    "fn",
                    "delegate_names",
                    "attribute_name"
                ],
                "__get__": [
                    "self",
                    "obj",
                    "type"
                ]
            }
        },
        "sklearn.utils._unittest_backport": {
            "_is_subtype": [
                "expected",
                "basetype"
            ],
            "_BaseTestCaseContext": {
                "__init__": [
                    "self",
                    "test_case"
                ],
                "_raiseFailure": [
                    "self",
                    "standardMsg"
                ]
            },
            "_AssertRaisesBaseContext": {
                "__init__": [
                    "self",
                    "expected",
                    "test_case",
                    "expected_regex"
                ],
                "handle": [
                    "self",
                    "name",
                    "args",
                    "kwargs"
                ]
            },
            "_AssertRaisesContext": {
                "__enter__": [
                    "self"
                ],
                "__exit__": [
                    "self",
                    "exc_type",
                    "exc_value",
                    "tb"
                ]
            },
            "TestCase": {
                "_formatMessage": [
                    "self",
                    "msg",
                    "standardMsg"
                ],
                "assertRaises": [
                    "self",
                    "expected_exception"
                ],
                "assertRaisesRegex": [
                    "self",
                    "expected_exception",
                    "expected_regex"
                ]
            }
        },
        "sklearn.utils.tests.test_metaestimators": {
            "test_delegated_docstring": [],
            "test_if_delegate_has_method": [],
            "Prefix": {
                "func": [
                    "self"
                ]
            },
            "MockMetaEstimator": {
                "func": [
                    "self"
                ]
            },
            "MetaEst": {
                "__init__": [
                    "self",
                    "sub_est",
                    "better_sub_est"
                ],
                "predict": [
                    "self"
                ]
            },
            "MetaEstTestTuple": {
                "predict": [
                    "self"
                ]
            },
            "MetaEstTestList": {
                "predict": [
                    "self"
                ]
            },
            "HasPredict": {
                "predict": [
                    "self"
                ]
            },
            "HasNoPredict": {}
        },
        "sklearn.utils.tests.test_murmurhash": {
            "test_mmhash3_int": [],
            "test_mmhash3_int_array": [],
            "test_mmhash3_bytes": [],
            "test_mmhash3_unicode": [],
            "test_no_collision_on_byte_range": [],
            "test_uniform_distribution": []
        },
        "sklearn.utils.tests.test_pprint": {
            "test_basic": [],
            "test_changed_only": [],
            "test_pipeline": [],
            "test_deeply_nested": [],
            "test_gridsearch": [],
            "test_gridsearch_pipeline": [],
            "test_n_max_elements_to_show": [],
            "test_bruteforce_ellipsis": [],
            "test_builtin_prettyprinter": [],
            "LogisticRegression": {
                "__init__": [
                    "self",
                    "penalty",
                    "dual",
                    "tol",
                    "C",
                    "fit_intercept",
                    "intercept_scaling",
                    "class_weight",
                    "random_state",
                    "solver",
                    "max_iter",
                    "multi_class",
                    "verbose",
                    "warm_start",
                    "n_jobs",
                    "l1_ratio"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "StandardScaler": {
                "__init__": [
                    "self",
                    "copy",
                    "with_mean",
                    "with_std"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ]
            },
            "RFE": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_features_to_select",
                    "step",
                    "verbose"
                ]
            },
            "GridSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "param_grid",
                    "scoring",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch",
                    "error_score",
                    "return_train_score"
                ]
            },
            "CountVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "encoding",
                    "decode_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "analyzer",
                    "max_df",
                    "min_df",
                    "max_features",
                    "vocabulary",
                    "binary",
                    "dtype"
                ]
            },
            "Pipeline": {
                "__init__": [
                    "self",
                    "steps",
                    "memory"
                ]
            },
            "SVC": {
                "__init__": [
                    "self",
                    "C",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "probability",
                    "tol",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "decision_function_shape",
                    "random_state"
                ]
            },
            "PCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "copy",
                    "whiten",
                    "svd_solver",
                    "tol",
                    "iterated_power",
                    "random_state"
                ]
            },
            "NMF": {
                "__init__": [
                    "self",
                    "n_components",
                    "init",
                    "solver",
                    "beta_loss",
                    "tol",
                    "max_iter",
                    "random_state",
                    "alpha",
                    "l1_ratio",
                    "verbose",
                    "shuffle"
                ]
            },
            "SimpleImputer": {
                "__init__": [
                    "self",
                    "missing_values",
                    "strategy",
                    "fill_value",
                    "verbose",
                    "copy"
                ]
            }
        },
        "sklearn.utils.tests.test_multiclass": {
            "test_unique_labels": [],
            "test_unique_labels_non_specific": [],
            "test_unique_labels_mixed_types": [],
            "test_is_multilabel": [],
            "test_check_classification_targets": [],
            "test_type_of_target": [],
            "test_class_distribution": [],
            "test_safe_split_with_precomputed_kernel": [],
            "test_ovr_decision_function": [],
            "NotAnArray": {
                "__init__": [
                    "self",
                    "data"
                ],
                "__array__": [
                    "self",
                    "dtype"
                ]
            }
        },
        "sklearn.utils.tests.test_extmath": {
            "test_density": [],
            "test_uniform_weights": [],
            "test_random_weights": [],
            "check_randomized_svd_low_rank": [
                "dtype"
            ],
            "test_randomized_svd_low_rank_all_dtypes": [
                "dtype"
            ],
            "test_row_norms": [
                "dtype"
            ],
            "test_randomized_svd_low_rank_with_noise": [],
            "test_randomized_svd_infinite_rank": [],
            "test_randomized_svd_transpose_consistency": [],
            "test_randomized_svd_power_iteration_normalizer": [],
            "test_randomized_svd_sparse_warnings": [],
            "test_svd_flip": [],
            "test_randomized_svd_sign_flip": [],
            "test_randomized_svd_sign_flip_with_transpose": [],
            "test_cartesian": [],
            "test_logistic_sigmoid": [],
            "test_incremental_variance_update_formulas": [],
            "test_incremental_mean_and_variance_ignore_nan": [],
            "test_incremental_variance_numerical_stability": [],
            "test_incremental_variance_ddof": [],
            "test_vector_sign_flip": [],
            "test_softmax": [],
            "test_stable_cumsum": []
        },
        "sklearn.utils.tests.test_random": {
            "test_invalid_sample_without_replacement_algorithm": [],
            "test_sample_without_replacement_algorithms": [],
            "check_edge_case_of_sample_int": [
                "sample_without_replacement"
            ],
            "check_sample_int": [
                "sample_without_replacement"
            ],
            "check_sample_int_distribution": [
                "sample_without_replacement"
            ],
            "test_random_choice_csc": [
                "n_samples",
                "random_state"
            ],
            "test_random_choice_csc_errors": [],
            "test_our_rand_r": []
        },
        "sklearn.utils.tests": {},
        "sklearn.utils.tests.test_utils": {
            "test_make_rng": [],
            "test_deprecated": [],
            "test_resample": [],
            "test_resample_stratified": [],
            "test_resample_stratified_replace": [],
            "test_resample_stratify_2dy": [],
            "test_resample_stratify_sparse_error": [],
            "test_safe_mask": [],
            "test_column_or_1d": [],
            "test_safe_indexing": [],
            "test_safe_indexing_pandas": [],
            "test_safe_indexing_mock_pandas": [],
            "test_shuffle_on_ndim_equals_three": [],
            "test_shuffle_dont_convert_to_array": [],
            "test_gen_even_slices": [],
            "test_get_chunk_n_rows": [
                "row_bytes",
                "max_n_rows",
                "working_memory",
                "expected",
                "warning"
            ],
            "test_message_with_time": [
                "source",
                "message",
                "is_long",
                "time",
                "time_str"
            ],
            "test_print_elapsed_time": [
                "message",
                "expected",
                "capsys",
                "monkeypatch"
            ],
            "test_is_scalar_nan": [
                "value",
                "result"
            ],
            "dummy_func": [],
            "test_deprecation_joblib_api": [
                "tmpdir"
            ]
        },
        "sklearn.utils.tests.test_cython_blas": {
            "_no_op": [
                "x"
            ],
            "test_dot": [
                "dtype"
            ],
            "test_asum": [
                "dtype"
            ],
            "test_axpy": [
                "dtype"
            ],
            "test_nrm2": [
                "dtype"
            ],
            "test_copy": [
                "dtype"
            ],
            "test_scal": [
                "dtype"
            ],
            "test_rotg": [
                "dtype"
            ],
            "test_rot": [
                "dtype"
            ],
            "test_gemv": [
                "dtype",
                "opA",
                "transA",
                "order"
            ],
            "test_ger": [
                "dtype",
                "order"
            ],
            "test_gemm": [
                "dtype",
                "opA",
                "transA",
                "opB",
                "transB",
                "order"
            ]
        },
        "sklearn.utils.tests.test_estimator_checks": {
            "test_check_fit_score_takes_y_works_on_deprecated_fit": [],
            "test_check_estimator": [],
            "test_check_outlier_corruption": [],
            "test_check_estimator_transformer_no_mixin": [],
            "test_check_estimator_clones": [],
            "test_check_estimators_unfitted": [],
            "test_check_no_attributes_set_in_init": [],
            "test_check_estimator_pairwise": [],
            "run_tests_without_pytest": [],
            "test_check_class_weight_balanced_linear_classifier": [],
            "CorrectNotFittedError": {},
            "BaseBadClassifier": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "ChangesDict": {
                "__init__": [
                    "self",
                    "key"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "SetsWrongAttribute": {
                "__init__": [
                    "self",
                    "acceptable_key"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "ChangesWrongAttribute": {
                "__init__": [
                    "self",
                    "wrong_attribute"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "ChangesUnderscoreAttribute": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RaisesErrorInSetParams": {
                "__init__": [
                    "self",
                    "p"
                ],
                "set_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "ModifiesValueInsteadOfRaisingError": {
                "__init__": [
                    "self",
                    "p"
                ],
                "set_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "ModifiesAnotherValue": {
                "__init__": [
                    "self",
                    "a",
                    "b"
                ],
                "set_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "NoCheckinPredict": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "NoSparseClassifier": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "CorrectNotFittedErrorClassifier": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "NoSampleWeightPandasSeriesType": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "BadBalancedWeightsClassifier": {
                "__init__": [
                    "self",
                    "class_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "BadTransformerWithoutMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "NotInvariantPredict": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "LargeSparseNotSupportedClassifier": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SparseTransformer": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.utils.tests.test_fast_dict": {
            "test_int_float_dict": [],
            "test_int_float_dict_argmin": []
        },
        "sklearn.utils.tests.test_shortest_path": {
            "floyd_warshall_slow": [
                "graph",
                "directed"
            ],
            "generate_graph": [
                "N"
            ],
            "test_floyd_warshall": [],
            "test_dijkstra": [],
            "test_shortest_path": [],
            "test_dijkstra_bug_fix": []
        },
        "sklearn.utils.tests.test_testing": {
            "test_assert_less": [],
            "test_assert_greater": [],
            "test_assert_less_equal": [],
            "test_assert_greater_equal": [],
            "test_set_random_state": [],
            "test_assert_allclose_dense_sparse": [],
            "test_assert_raises_msg": [],
            "test_assert_raise_message": [],
            "test_ignore_warning": [],
            "f_ok": [
                "a",
                "b"
            ],
            "f_bad_sections": [
                "a",
                "b"
            ],
            "f_bad_order": [
                "b",
                "a"
            ],
            "f_missing": [
                "a",
                "b"
            ],
            "f_check_param_definition": [
                "a",
                "b",
                "c",
                "d",
                "e"
            ],
            "test_check_docstring_parameters": [],
            "check_memmap": [
                "input_array",
                "mmap_data",
                "mmap_mode"
            ],
            "test_tempmemmap": [
                "monkeypatch"
            ],
            "test_create_memmap_backed_data": [
                "monkeypatch"
            ],
            "TestWarns": {
                "test_warn": [
                    "self"
                ],
                "test_warn_wrong_warning": [
                    "self"
                ]
            },
            "Klass": {
                "f_missing": [
                    "self",
                    "X",
                    "y"
                ],
                "f_bad_sections": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "MockEst": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X"
                ]
            },
            "MockMetaEstimator": {
                "__init__": [
                    "self",
                    "delegate"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RegistrationCounter": {
                "__init__": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "to_register_func"
                ]
            }
        },
        "sklearn.utils.tests.test_optimize": {
            "test_newton_cg": []
        },
        "sklearn.utils.tests.test_show_versions": {
            "test_get_sys_info": [],
            "test_get_deps_info": [],
            "test_show_versions_with_blas": [
                "capsys"
            ]
        },
        "sklearn.utils.tests.test_linear_assignment": {
            "test_hungarian": []
        },
        "sklearn.utils.tests.test_deprecation": {
            "mock_function": [],
            "test_deprecated": [],
            "test_is_deprecated": [],
            "test_pickle": [],
            "MockClass1": {},
            "MockClass2": {
                "method": [
                    "self"
                ]
            },
            "MockClass3": {
                "__init__": [
                    "self"
                ]
            },
            "MockClass4": {}
        },
        "sklearn.utils.tests.test_validation": {
            "test_as_float_array": [],
            "test_as_float_array_nan": [
                "X"
            ],
            "test_np_matrix": [],
            "test_memmap": [],
            "test_ordering": [],
            "test_check_array_force_all_finite_valid": [
                "value",
                "force_all_finite",
                "retype"
            ],
            "test_check_array_force_all_finiteinvalid": [
                "value",
                "force_all_finite",
                "match_msg",
                "retype"
            ],
            "test_check_array_force_all_finite_object": [],
            "test_check_array": [],
            "test_check_array_pandas_dtype_object_conversion": [],
            "test_check_array_on_mock_dataframe": [],
            "test_check_array_dtype_stability": [],
            "test_check_array_dtype_warning": [],
            "test_check_array_warn_on_dtype_deprecation": [],
            "test_check_array_accept_sparse_type_exception": [],
            "test_check_array_accept_sparse_no_exception": [],
            "X_64bit": [
                "request"
            ],
            "test_check_array_accept_large_sparse_no_exception": [
                "X_64bit"
            ],
            "test_check_array_accept_large_sparse_raise_exception": [
                "X_64bit"
            ],
            "test_check_array_min_samples_and_features_messages": [],
            "test_check_array_complex_data_error": [],
            "test_has_fit_parameter": [],
            "test_check_symmetric": [],
            "test_check_is_fitted": [],
            "test_check_consistent_length": [],
            "test_check_dataframe_fit_attribute": [],
            "test_suppress_validation": [],
            "test_check_array_series": [],
            "test_check_dataframe_warns_on_dtype": [],
            "test_check_memory": [],
            "test_check_array_memmap": [
                "copy"
            ],
            "test_check_non_negative": [
                "retype"
            ],
            "test_check_X_y_informative_error": [],
            "test_retrieve_samples_from_non_standard_shape": [],
            "test_check_scalar_valid": [
                "x",
                "target_type",
                "min_val",
                "max_val"
            ],
            "test_check_scalar_invalid": [
                "x",
                "target_name",
                "target_type",
                "min_val",
                "max_val",
                "err_msg"
            ],
            "DummyMemory": {
                "cache": [
                    "self",
                    "func"
                ]
            },
            "WrongDummyMemory": {}
        },
        "sklearn.utils.tests.test_fixes": {
            "test_masked_array_obj_dtype_pickleable": [],
            "test_joblib_parallel_args": [
                "monkeypatch",
                "joblib_version"
            ],
            "test_object_dtype_isnan": [
                "dtype",
                "val"
            ]
        },
        "sklearn.utils.tests.test_class_weight": {
            "test_compute_class_weight": [],
            "test_compute_class_weight_not_present": [],
            "test_compute_class_weight_dict": [],
            "test_compute_class_weight_invariance": [],
            "test_compute_class_weight_balanced_negative": [],
            "test_compute_class_weight_balanced_unordered": [],
            "test_compute_class_weight_default": [],
            "test_compute_sample_weight": [],
            "test_compute_sample_weight_with_subsample": [],
            "test_compute_sample_weight_errors": [],
            "test_compute_sample_weight_more_than_32": []
        },
        "sklearn.utils.tests.test_sparsefuncs": {
            "test_mean_variance_axis0": [],
            "test_mean_variance_axis1": [],
            "test_incr_mean_variance_axis": [],
            "test_incr_mean_variance_axis_ignore_nan": [
                "axis",
                "sparse_constructor"
            ],
            "test_mean_variance_illegal_axis": [],
            "test_densify_rows": [],
            "test_inplace_column_scale": [],
            "test_inplace_row_scale": [],
            "test_inplace_swap_row": [],
            "test_inplace_swap_column": [],
            "test_min_max": [
                "dtype",
                "axis",
                "sparse_format",
                "missing_values",
                "min_func",
                "max_func",
                "ignore_nan"
            ],
            "test_min_max_axis_errors": [],
            "test_count_nonzero": [],
            "test_csc_row_median": [],
            "test_inplace_normalize": []
        },
        "sklearn.utils.tests.test_seq_dataset": {
            "assert_csr_equal_values": [
                "current",
                "expected"
            ],
            "make_dense_dataset_32": [],
            "make_dense_dataset_64": [],
            "make_sparse_dataset_32": [],
            "make_sparse_dataset_64": [],
            "test_seq_dataset_basic_iteration": [
                "dataset_constructor"
            ],
            "test_seq_dataset_shuffle": [
                "make_dense_dataset",
                "make_sparse_dataset"
            ],
            "test_fused_types_consistency": [
                "make_dataset_32",
                "make_dataset_64"
            ],
            "test_buffer_dtype_mismatch_error": []
        },
        "sklearn.tests.test_metaestimators": {
            "test_metaestimator_delegation": [],
            "DelegatorData": {
                "__init__": [
                    "self",
                    "name",
                    "construct",
                    "skip_methods",
                    "fit_args"
                ]
            }
        },
        "sklearn.tests.test_check_build": {
            "test_raise_build_error": []
        },
        "sklearn.tests.test_docstring_parameters": {
            "test_docstring_parameters": [],
            "test_tabs": []
        },
        "sklearn.tests.test_pipeline": {
            "test_pipeline_init": [],
            "test_pipeline_init_tuple": [],
            "test_pipeline_methods_anova": [],
            "test_pipeline_fit_params": [],
            "test_pipeline_sample_weight_supported": [],
            "test_pipeline_sample_weight_unsupported": [],
            "test_pipeline_raise_set_params_error": [],
            "test_pipeline_methods_pca_svm": [],
            "test_pipeline_methods_preprocessing_svm": [],
            "test_fit_predict_on_pipeline": [],
            "test_fit_predict_on_pipeline_without_fit_predict": [],
            "test_fit_predict_with_intermediate_fit_params": [],
            "test_predict_with_predict_params": [],
            "test_feature_union": [],
            "test_make_union": [],
            "test_make_union_kwargs": [],
            "test_pipeline_transform": [],
            "test_pipeline_fit_transform": [],
            "test_pipeline_slice": [],
            "test_pipeline_index": [],
            "test_set_pipeline_steps": [],
            "test_pipeline_named_steps": [],
            "test_pipeline_correctly_adjusts_steps": [
                "passthrough"
            ],
            "test_set_pipeline_step_passthrough": [
                "passthrough"
            ],
            "test_pipeline_ducktyping": [],
            "test_make_pipeline": [],
            "test_feature_union_weights": [],
            "test_feature_union_parallel": [],
            "test_feature_union_feature_names": [],
            "test_classes_property": [],
            "test_set_feature_union_steps": [],
            "test_set_feature_union_step_drop": [
                "drop"
            ],
            "test_step_name_validation": [],
            "test_set_params_nested_pipeline": [],
            "test_pipeline_wrong_memory": [],
            "test_pipeline_with_cache_attribute": [],
            "test_pipeline_memory": [],
            "test_make_pipeline_memory": [],
            "test_pipeline_param_error": [],
            "test_verbose": [
                "est",
                "method",
                "pattern",
                "capsys"
            ],
            "NoFit": {
                "__init__": [
                    "self",
                    "a",
                    "b"
                ]
            },
            "NoTrans": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ]
            },
            "NoInvTransf": {
                "transform": [
                    "self",
                    "X"
                ]
            },
            "Transf": {
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            },
            "TransfFitParams": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "Mult": {
                "__init__": [
                    "self",
                    "mult"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "FitParamT": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "should_succeed"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "fit_predict": [
                    "self",
                    "X",
                    "y",
                    "should_succeed"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "DummyTransf": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "DummyEstimatorParams": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X",
                    "got_attribute"
                ]
            },
            "DummyMemory": {
                "cache": [
                    "self",
                    "func"
                ]
            },
            "WrongDummyMemory": {}
        },
        "sklearn.tests.test_impute": {
            "_check_statistics": [
                "X",
                "X_true",
                "strategy",
                "statistics",
                "missing_values"
            ],
            "test_imputation_shape": [],
            "test_imputation_error_invalid_strategy": [
                "strategy"
            ],
            "test_imputation_deletion_warning": [
                "strategy"
            ],
            "test_imputation_error_sparse_0": [
                "strategy"
            ],
            "safe_median": [
                "arr"
            ],
            "safe_mean": [
                "arr"
            ],
            "test_imputation_mean_median": [],
            "test_imputation_median_special_cases": [],
            "test_imputation_mean_median_error_invalid_type": [
                "strategy",
                "dtype"
            ],
            "test_imputation_const_mostf_error_invalid_types": [
                "strategy",
                "dtype"
            ],
            "test_imputation_most_frequent": [],
            "test_imputation_most_frequent_objects": [
                "marker"
            ],
            "test_imputation_most_frequent_pandas": [
                "dtype"
            ],
            "test_imputation_constant_error_invalid_type": [
                "X_data",
                "missing_value"
            ],
            "test_imputation_constant_integer": [],
            "test_imputation_constant_float": [
                "array_constructor"
            ],
            "test_imputation_constant_object": [
                "marker"
            ],
            "test_imputation_constant_pandas": [
                "dtype"
            ],
            "test_imputation_pipeline_grid_search": [],
            "test_imputation_copy": [],
            "test_iterative_imputer_zero_iters": [],
            "test_iterative_imputer_verbose": [],
            "test_iterative_imputer_all_missing": [],
            "test_iterative_imputer_imputation_order": [
                "imputation_order"
            ],
            "test_iterative_imputer_estimators": [
                "estimator"
            ],
            "test_iterative_imputer_clip": [],
            "test_iterative_imputer_clip_truncnorm": [],
            "test_iterative_imputer_truncated_normal_posterior": [],
            "test_iterative_imputer_missing_at_transform": [
                "strategy"
            ],
            "test_iterative_imputer_transform_stochasticity": [],
            "test_iterative_imputer_no_missing": [],
            "test_iterative_imputer_rank_one": [],
            "test_iterative_imputer_transform_recovery": [
                "rank"
            ],
            "test_iterative_imputer_additive_matrix": [],
            "test_iterative_imputer_error_param": [
                "max_iter",
                "tol",
                "error_type",
                "warning"
            ],
            "test_iterative_imputer_early_stopping": [],
            "test_missing_indicator_error": [
                "X_fit",
                "X_trans",
                "params",
                "msg_err"
            ],
            "test_missing_indicator_new": [
                "missing_values",
                "arr_type",
                "dtype",
                "param_features",
                "n_features",
                "features_indices"
            ],
            "test_missing_indicator_raise_on_sparse_with_missing_0": [
                "arr_type"
            ],
            "test_missing_indicator_sparse_param": [
                "arr_type",
                "missing_values",
                "param_sparse"
            ],
            "test_missing_indicator_string": [],
            "test_missing_indicator_with_imputer": [
                "X",
                "missing_values",
                "X_trans_exp"
            ],
            "test_inconsistent_dtype_X_missing_values": [
                "imputer_constructor",
                "imputer_missing_values",
                "missing_value",
                "err_msg"
            ],
            "test_missing_indicator_no_missing": [],
            "test_missing_indicator_sparse_no_explicit_zeros": [],
            "test_imputers_add_indicator": [
                "marker",
                "imputer_constructor"
            ],
            "test_imputer_without_indicator": [
                "imputer_constructor"
            ],
            "test_simple_imputation_add_indicator_sparse_matrix": [
                "arr_type"
            ]
        },
        "sklearn.tests.test_multiclass": {
            "test_ovr_exceptions": [],
            "test_check_classification_targets": [],
            "test_ovr_fit_predict": [],
            "test_ovr_partial_fit": [],
            "test_ovr_partial_fit_exceptions": [],
            "test_ovr_ovo_regressor": [],
            "test_ovr_fit_predict_sparse": [],
            "test_ovr_always_present": [],
            "test_ovr_multiclass": [],
            "test_ovr_binary": [],
            "test_ovr_multilabel": [],
            "test_ovr_fit_predict_svc": [],
            "test_ovr_multilabel_dataset": [],
            "test_ovr_multilabel_predict_proba": [],
            "test_ovr_single_label_predict_proba": [],
            "test_ovr_multilabel_decision_function": [],
            "test_ovr_single_label_decision_function": [],
            "test_ovr_gridsearch": [],
            "test_ovr_pipeline": [],
            "test_ovr_coef_": [],
            "test_ovr_coef_exceptions": [],
            "test_ovo_exceptions": [],
            "test_ovo_fit_on_list": [],
            "test_ovo_fit_predict": [],
            "test_ovo_partial_fit_predict": [],
            "test_ovo_decision_function": [],
            "test_ovo_gridsearch": [],
            "test_ovo_ties": [],
            "test_ovo_ties2": [],
            "test_ovo_string_y": [],
            "test_ovo_one_class": [],
            "test_ovo_float_y": [],
            "test_ecoc_exceptions": [],
            "test_ecoc_fit_predict": [],
            "test_ecoc_gridsearch": [],
            "test_ecoc_float_y": [],
            "test_pairwise_indices": [],
            "test_pairwise_attribute": [],
            "test_pairwise_cross_val_score": []
        },
        "sklearn.tests.test_config": {
            "test_config_context": [],
            "test_config_context_exception": [],
            "test_set_config": []
        },
        "sklearn.tests.test_base": {
            "test_clone": [],
            "test_clone_2": [],
            "test_clone_buggy": [],
            "test_clone_empty_array": [],
            "test_clone_nan": [],
            "test_clone_sparse_matrices": [],
            "test_clone_estimator_types": [],
            "test_repr": [],
            "test_str": [],
            "test_get_params": [],
            "test_is_classifier": [],
            "test_set_params": [],
            "test_set_params_passes_all_parameters": [],
            "test_set_params_updates_valid_params": [],
            "test_score_sample_weight": [],
            "test_clone_pandas_dataframe": [],
            "test_pickle_version_warning_is_not_raised_with_matching_version": [],
            "test_pickle_version_warning_is_issued_upon_different_version": [],
            "test_pickle_version_warning_is_issued_when_no_version_info_in_pickle": [],
            "test_pickle_version_no_warning_is_issued_with_non_sklearn_estimator": [],
            "test_pickling_when_getstate_is_overwritten_by_mixin": [],
            "test_pickling_when_getstate_is_overwritten_by_mixin_outside_of_sklearn": [],
            "test_pickling_works_when_getstate_is_overwritten_in_the_child_class": [],
            "test_tag_inheritance": [],
            "test_regressormixin_score_multioutput": [],
            "MyEstimator": {
                "__init__": [
                    "self",
                    "l1",
                    "empty"
                ]
            },
            "K": {
                "__init__": [
                    "self",
                    "c",
                    "d"
                ]
            },
            "T": {
                "__init__": [
                    "self",
                    "a",
                    "b"
                ]
            },
            "NaNTag": {
                "_more_tags": [
                    "self"
                ]
            },
            "NoNaNTag": {
                "_more_tags": [
                    "self"
                ]
            },
            "OverrideTag": {
                "_more_tags": [
                    "self"
                ]
            },
            "DiamondOverwriteTag": {},
            "ModifyInitParams": {
                "__init__": [
                    "self",
                    "a"
                ]
            },
            "Buggy": {
                "__init__": [
                    "self",
                    "a"
                ]
            },
            "NoEstimator": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "VargEstimator": {
                "__init__": [
                    "self"
                ]
            },
            "TreeBadVersion": {
                "__getstate__": [
                    "self"
                ]
            },
            "TreeNoVersion": {
                "__getstate__": [
                    "self"
                ]
            },
            "DontPickleAttributeMixin": {
                "__getstate__": [
                    "self"
                ],
                "__setstate__": [
                    "self",
                    "state"
                ]
            },
            "MultiInheritanceEstimator": {
                "__init__": [
                    "self",
                    "attribute_pickled"
                ]
            },
            "SingleInheritanceEstimator": {
                "__init__": [
                    "self",
                    "attribute_pickled"
                ],
                "__getstate__": [
                    "self"
                ]
            }
        },
        "sklearn.tests": {},
        "sklearn.tests.test_isotonic": {
            "test_permutation_invariance": [],
            "test_check_increasing_small_number_of_samples": [],
            "test_check_increasing_up": [],
            "test_check_increasing_up_extreme": [],
            "test_check_increasing_down": [],
            "test_check_increasing_down_extreme": [],
            "test_check_ci_warn": [],
            "test_isotonic_regression": [],
            "test_isotonic_regression_ties_min": [],
            "test_isotonic_regression_ties_max": [],
            "test_isotonic_regression_ties_secondary_": [],
            "test_isotonic_regression_with_ties_in_differently_sized_groups": [],
            "test_isotonic_regression_reversed": [],
            "test_isotonic_regression_auto_decreasing": [],
            "test_isotonic_regression_auto_increasing": [],
            "test_assert_raises_exceptions": [],
            "test_isotonic_sample_weight_parameter_default_value": [],
            "test_isotonic_min_max_boundaries": [],
            "test_isotonic_sample_weight": [],
            "test_isotonic_regression_oob_raise": [],
            "test_isotonic_regression_oob_clip": [],
            "test_isotonic_regression_oob_nan": [],
            "test_isotonic_regression_oob_bad": [],
            "test_isotonic_regression_oob_bad_after": [],
            "test_isotonic_regression_pickle": [],
            "test_isotonic_duplicate_min_entry": [],
            "test_isotonic_ymin_ymax": [],
            "test_isotonic_zero_weight_loop": [],
            "test_fast_predict": [],
            "test_isotonic_copy_before_fit": [],
            "test_isotonic_dtype": [],
            "test_make_unique_dtype": []
        },
        "sklearn.tests.test_dummy": {
            "_check_predict_proba": [
                "clf",
                "X",
                "y"
            ],
            "_check_behavior_2d": [
                "clf"
            ],
            "_check_behavior_2d_for_constant": [
                "clf"
            ],
            "_check_equality_regressor": [
                "statistic",
                "y_learn",
                "y_pred_learn",
                "y_test",
                "y_pred_test"
            ],
            "test_most_frequent_and_prior_strategy": [],
            "test_most_frequent_and_prior_strategy_with_2d_column_y": [],
            "test_most_frequent_and_prior_strategy_multioutput": [],
            "test_stratified_strategy": [],
            "test_stratified_strategy_multioutput": [],
            "test_uniform_strategy": [],
            "test_uniform_strategy_multioutput": [],
            "test_string_labels": [],
            "test_classifier_score_with_None": [
                "y",
                "y_test"
            ],
            "test_classifier_prediction_independent_of_X": [
                "strategy"
            ],
            "test_classifier_exceptions": [],
            "test_mean_strategy_regressor": [],
            "test_mean_strategy_multioutput_regressor": [],
            "test_regressor_exceptions": [],
            "test_median_strategy_regressor": [],
            "test_median_strategy_multioutput_regressor": [],
            "test_quantile_strategy_regressor": [],
            "test_quantile_strategy_multioutput_regressor": [],
            "test_quantile_invalid": [],
            "test_quantile_strategy_empty_train": [],
            "test_constant_strategy_regressor": [],
            "test_constant_strategy_multioutput_regressor": [],
            "test_y_mean_attribute_regressor": [],
            "test_unknown_strategey_regressor": [],
            "test_constants_not_specified_regressor": [],
            "test_constant_size_multioutput_regressor": [],
            "test_constant_strategy": [],
            "test_constant_strategy_multioutput": [],
            "test_constant_strategy_exceptions": [],
            "test_classification_sample_weight": [],
            "test_constant_strategy_sparse_target": [],
            "test_uniform_strategy_sparse_target_warning": [],
            "test_stratified_strategy_sparse_target": [],
            "test_most_frequent_and_prior_strategy_sparse_target": [],
            "test_dummy_regressor_sample_weight": [
                "n_samples"
            ],
            "test_dummy_regressor_on_3D_array": [],
            "test_dummy_classifier_on_3D_array": [],
            "test_dummy_regressor_return_std": [],
            "test_regressor_score_with_None": [
                "y",
                "y_test"
            ],
            "test_regressor_prediction_independent_of_X": [
                "strategy"
            ],
            "test_dtype_of_classifier_probas": [
                "strategy"
            ]
        },
        "sklearn.tests.test_multioutput": {
            "test_multi_target_regression": [],
            "test_multi_target_regression_partial_fit": [],
            "test_multi_target_regression_one_target": [],
            "test_multi_target_sparse_regression": [],
            "test_multi_target_sample_weights_api": [],
            "test_multi_target_sample_weight_partial_fit": [],
            "test_multi_target_sample_weights": [],
            "test_multi_output_classification_partial_fit_parallelism": [],
            "test_multi_output_predict_proba": [],
            "test_multi_output_classification_partial_fit": [],
            "test_multi_output_classification_partial_fit_no_first_classes_exception": [],
            "test_multi_output_classification": [],
            "test_multiclass_multioutput_estimator": [],
            "test_multiclass_multioutput_estimator_predict_proba": [],
            "test_multi_output_classification_sample_weights": [],
            "test_multi_output_classification_partial_fit_sample_weights": [],
            "test_multi_output_exceptions": [],
            "generate_multilabel_dataset_with_correlations": [],
            "test_classifier_chain_fit_and_predict_with_linear_svc": [],
            "test_classifier_chain_fit_and_predict_with_sparse_data": [],
            "test_classifier_chain_vs_independent_models": [],
            "test_base_chain_fit_and_predict": [],
            "test_base_chain_fit_and_predict_with_sparse_data_and_cv": [],
            "test_base_chain_random_order": [],
            "test_base_chain_crossval_fit_and_predict": []
        },
        "sklearn.tests.test_discriminant_analysis": {
            "test_lda_predict": [],
            "test_lda_predict_proba": [
                "solver",
                "n_classes"
            ],
            "test_lda_priors": [],
            "test_lda_coefs": [],
            "test_lda_transform": [],
            "test_lda_explained_variance_ratio": [],
            "test_lda_orthogonality": [],
            "test_lda_scaling": [],
            "test_lda_store_covariance": [],
            "test_lda_dimension_warning": [
                "n_classes",
                "n_features"
            ],
            "test_lda_dtype_match": [
                "data_type",
                "expected_type"
            ],
            "test_lda_numeric_consistency_float32_float64": [],
            "test_qda": [],
            "test_qda_priors": [],
            "test_qda_store_covariance": [],
            "test_qda_regularization": [],
            "test_covariance": [],
            "test_raises_value_error_on_same_number_of_classes_and_samples": [
                "solver"
            ]
        },
        "sklearn.tests.test_init": {
            "test_import_skl": []
        },
        "sklearn.tests.test_kernel_ridge": {
            "test_kernel_ridge": [],
            "test_kernel_ridge_csr": [],
            "test_kernel_ridge_csc": [],
            "test_kernel_ridge_singular_kernel": [],
            "test_kernel_ridge_precomputed": [],
            "test_kernel_ridge_precomputed_kernel_unchanged": [],
            "test_kernel_ridge_sample_weights": [],
            "test_kernel_ridge_multi_output": []
        },
        "sklearn.tests.test_calibration": {
            "test_calibration": [],
            "test_sample_weight": [],
            "test_calibration_multiclass": [],
            "test_calibration_prefit": [],
            "test_sigmoid_calibration": [],
            "test_calibration_curve": [],
            "test_calibration_nan_imputer": [],
            "test_calibration_prob_sum": [],
            "test_calibration_less_classes": [],
            "test_calibration_accepts_ndarray": [
                "X"
            ]
        },
        "sklearn.tests.test_kernel_approximation": {
            "test_additive_chi2_sampler": [],
            "test_skewed_chi2_sampler": [],
            "test_rbf_sampler": [],
            "test_input_validation": [],
            "test_nystroem_approximation": [],
            "test_nystroem_default_parameters": [],
            "test_nystroem_singular_kernel": [],
            "test_nystroem_poly_kernel_params": [],
            "test_nystroem_callable": []
        },
        "sklearn.tests.test_random_projection": {
            "make_sparse_random_data": [
                "n_samples",
                "n_features",
                "n_nonzeros"
            ],
            "densify": [
                "matrix"
            ],
            "test_invalid_jl_domain": [],
            "test_input_size_jl_min_dim": [],
            "check_input_size_random_matrix": [
                "random_matrix"
            ],
            "check_size_generated": [
                "random_matrix"
            ],
            "check_zero_mean_and_unit_norm": [
                "random_matrix"
            ],
            "check_input_with_sparse_random_matrix": [
                "random_matrix"
            ],
            "test_basic_property_of_random_matrix": [
                "random_matrix"
            ],
            "test_basic_property_of_sparse_random_matrix": [
                "random_matrix"
            ],
            "test_gaussian_random_matrix": [],
            "test_sparse_random_matrix": [],
            "test_sparse_random_projection_transformer_invalid_density": [],
            "test_random_projection_transformer_invalid_input": [],
            "test_try_to_transform_before_fit": [],
            "test_too_many_samples_to_find_a_safe_embedding": [],
            "test_random_projection_embedding_quality": [],
            "test_SparseRandomProjection_output_representation": [],
            "test_correct_RandomProjection_dimensions_embedding": [],
            "test_warning_n_components_greater_than_n_features": [],
            "test_works_with_sparse_data": []
        },
        "sklearn.tests.test_site_joblib": {
            "test_old_pickle": [
                "tmpdir"
            ]
        },
        "sklearn.tests.test_naive_bayes": {
            "test_gnb": [],
            "test_gnb_prior": [],
            "test_gnb_sample_weight": [],
            "test_gnb_neg_priors": [],
            "test_gnb_priors": [],
            "test_gnb_priors_sum_isclose": [],
            "test_gnb_wrong_nb_priors": [],
            "test_gnb_prior_greater_one": [],
            "test_gnb_prior_large_bias": [],
            "test_check_update_with_no_data": [],
            "test_gnb_pfit_wrong_nb_features": [],
            "test_discrete_prior": [],
            "test_mnnb": [
                "kind"
            ],
            "check_partial_fit": [
                "cls"
            ],
            "test_mnb_prior_unobserved_targets": [],
            "test_discretenb_partial_fit": [
                "cls"
            ],
            "test_gnb_partial_fit": [],
            "test_discretenb_pickle": [
                "cls"
            ],
            "test_input_check_fit": [
                "cls"
            ],
            "test_input_check_partial_fit": [
                "cls"
            ],
            "test_discretenb_predict_proba": [],
            "test_discretenb_uniform_prior": [
                "cls"
            ],
            "test_discretenb_provide_prior": [
                "cls"
            ],
            "test_discretenb_provide_prior_with_partial_fit": [
                "cls"
            ],
            "test_sample_weight_multiclass": [
                "cls"
            ],
            "check_sample_weight_multiclass": [
                "cls"
            ],
            "test_sample_weight_mnb": [],
            "test_coef_intercept_shape": [],
            "test_check_accuracy_on_digits": [],
            "test_feature_log_prob_bnb": [],
            "test_bnb": [],
            "test_cnb": [],
            "test_naive_bayes_scale_invariance": [],
            "test_alpha": [],
            "test_alpha_vector": []
        },
        "sklearn.tests.test_common": {
            "test_all_estimator_no_base_class": [],
            "test_parameters_default_constructible": [
                "name",
                "Estimator"
            ],
            "_tested_estimators": [],
            "_generate_checks_per_estimator": [
                "check_generator",
                "estimators"
            ],
            "_rename_partial": [
                "val"
            ],
            "test_estimators": [
                "estimator",
                "check"
            ],
            "test_no_attributes_set_in_init": [
                "name",
                "estimator"
            ],
            "test_configure": [],
            "_tested_linear_classifiers": [],
            "test_class_weight_balanced_linear_classifiers": [
                "name",
                "Classifier"
            ],
            "test_import_all_consistency": [],
            "test_root_import_all_completeness": [],
            "test_all_tests_are_importable": []
        },
        "sklearn.feature_selection.univariate_selection": {
            "_clean_nans": [
                "scores"
            ],
            "f_oneway": [],
            "f_classif": [
                "X",
                "y"
            ],
            "_chisquare": [
                "f_obs",
                "f_exp"
            ],
            "chi2": [
                "X",
                "y"
            ],
            "f_regression": [
                "X",
                "y",
                "center"
            ],
            "_BaseFilter": {
                "__init__": [
                    "self",
                    "score_func"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_check_params": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SelectPercentile": {
                "__init__": [
                    "self",
                    "score_func",
                    "percentile"
                ],
                "_check_params": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectKBest": {
                "__init__": [
                    "self",
                    "score_func",
                    "k"
                ],
                "_check_params": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectFpr": {
                "__init__": [
                    "self",
                    "score_func",
                    "alpha"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectFdr": {
                "__init__": [
                    "self",
                    "score_func",
                    "alpha"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectFwe": {
                "__init__": [
                    "self",
                    "score_func",
                    "alpha"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "GenericUnivariateSelect": {
                "__init__": [
                    "self",
                    "score_func",
                    "mode",
                    "param"
                ],
                "_make_selector": [
                    "self"
                ],
                "_check_params": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ]
            }
        },
        "sklearn.feature_selection.rfe": {
            "_rfe_single_fit": [
                "rfe",
                "estimator",
                "X",
                "y",
                "train",
                "test",
                "scorer"
            ],
            "RFE": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_features_to_select",
                    "step",
                    "verbose"
                ],
                "_estimator_type": [
                    "self"
                ],
                "classes_": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "step_score"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "RFECV": {
                "__init__": [
                    "self",
                    "estimator",
                    "step",
                    "min_features_to_select",
                    "cv",
                    "scoring",
                    "verbose",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            }
        },
        "sklearn.feature_selection": {},
        "sklearn.feature_selection.mutual_info_": {
            "_compute_mi_cc": [
                "x",
                "y",
                "n_neighbors"
            ],
            "_compute_mi_cd": [
                "c",
                "d",
                "n_neighbors"
            ],
            "_compute_mi": [
                "x",
                "y",
                "x_discrete",
                "y_discrete",
                "n_neighbors"
            ],
            "_iterate_columns": [
                "X",
                "columns"
            ],
            "_estimate_mi": [
                "X",
                "y",
                "discrete_features",
                "discrete_target",
                "n_neighbors",
                "copy",
                "random_state"
            ],
            "mutual_info_regression": [
                "X",
                "y",
                "discrete_features",
                "n_neighbors",
                "copy",
                "random_state"
            ],
            "mutual_info_classif": [
                "X",
                "y",
                "discrete_features",
                "n_neighbors",
                "copy",
                "random_state"
            ]
        },
        "sklearn.feature_selection.base": {
            "SelectorMixin": {
                "get_support": [
                    "self",
                    "indices"
                ],
                "_get_support_mask": [
                    "self"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.feature_selection.from_model": {
            "_get_feature_importances": [
                "estimator",
                "norm_order"
            ],
            "_calculate_threshold": [
                "estimator",
                "importances",
                "threshold"
            ],
            "SelectFromModel": {
                "__init__": [
                    "self",
                    "estimator",
                    "threshold",
                    "prefit",
                    "norm_order",
                    "max_features"
                ],
                "_get_support_mask": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "threshold_": [
                    "self"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.feature_selection.variance_threshold": {
            "VarianceThreshold": {
                "__init__": [
                    "self",
                    "threshold"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ]
            }
        },
        "sklearn.feature_selection.tests.test_from_model": {
            "test_invalid_input": [],
            "test_input_estimator_unchanged": [],
            "test_max_features_error": [
                "max_features",
                "err_type",
                "err_msg"
            ],
            "test_max_features_dim": [
                "max_features"
            ],
            "test_max_features": [],
            "test_max_features_tiebreak": [],
            "test_threshold_and_max_features": [],
            "test_feature_importances": [],
            "test_sample_weight": [],
            "test_coef_default_threshold": [],
            "test_2d_coef": [],
            "test_partial_fit": [],
            "test_calling_fit_reinitializes": [],
            "test_prefit": [],
            "test_threshold_string": [],
            "test_threshold_without_refitting": [],
            "FixedImportanceEstimator": {
                "__init__": [
                    "self",
                    "importances"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.feature_selection.tests.test_rfe": {
            "test_rfe_features_importance": [],
            "test_rfe": [],
            "test_rfe_mockclassifier": [],
            "test_rfecv": [],
            "test_rfecv_mockclassifier": [],
            "test_rfecv_verbose_output": [],
            "test_rfecv_grid_scores_size": [],
            "test_rfe_estimator_tags": [],
            "test_rfe_min_step": [],
            "test_number_of_subsets_of_features": [],
            "test_rfe_cv_n_jobs": [],
            "test_rfe_cv_groups": [],
            "MockClassifier": {
                "__init__": [
                    "self",
                    "foo_param"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ]
            }
        },
        "sklearn.feature_selection.tests.test_mutual_info": {
            "test_compute_mi_dd": [],
            "test_compute_mi_cc": [],
            "test_compute_mi_cd": [],
            "test_compute_mi_cd_unique_label": [],
            "test_mutual_info_classif_discrete": [],
            "test_mutual_info_regression": [],
            "test_mutual_info_classif_mixed": [],
            "test_mutual_info_options": []
        },
        "sklearn.feature_selection.tests.test_base": {
            "test_transform_dense": [],
            "test_transform_sparse": [],
            "test_inverse_transform_dense": [],
            "test_inverse_transform_sparse": [],
            "test_get_support": [],
            "StepSelector": {
                "__init__": [
                    "self",
                    "step"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ]
            }
        },
        "sklearn.feature_selection.tests": {},
        "sklearn.feature_selection.tests.test_feature_select": {
            "test_f_oneway_vs_scipy_stats": [],
            "test_f_oneway_ints": [],
            "test_f_classif": [],
            "test_f_regression": [],
            "test_f_regression_input_dtype": [],
            "test_f_regression_center": [],
            "test_f_classif_multi_class": [],
            "test_select_percentile_classif": [],
            "test_select_percentile_classif_sparse": [],
            "test_select_kbest_classif": [],
            "test_select_kbest_all": [],
            "test_select_kbest_zero": [],
            "test_select_heuristics_classif": [],
            "assert_best_scores_kept": [
                "score_filter"
            ],
            "test_select_percentile_regression": [],
            "test_select_percentile_regression_full": [],
            "test_invalid_percentile": [],
            "test_select_kbest_regression": [],
            "test_select_heuristics_regression": [],
            "test_boundary_case_ch2": [],
            "test_select_fdr_regression": [],
            "test_select_fwe_regression": [],
            "test_selectkbest_tiebreaking": [],
            "test_selectpercentile_tiebreaking": [],
            "test_tied_pvalues": [],
            "test_scorefunc_multilabel": [],
            "test_tied_scores": [],
            "test_nans": [],
            "test_score_func_error": [],
            "test_invalid_k": [],
            "test_f_classif_constant_feature": [],
            "test_no_feature_selected": [],
            "test_mutual_info_classif": [],
            "test_mutual_info_regression": []
        },
        "sklearn.feature_selection.tests.test_chi2": {
            "mkchi2": [
                "k"
            ],
            "test_chi2": [],
            "test_chi2_coo": [],
            "test_chi2_negative": [],
            "test_chi2_unused_feature": [],
            "test_chisquare": []
        },
        "sklearn.feature_selection.tests.test_variance_threshold": {
            "test_zero_variance": [],
            "test_variance_threshold": []
        },
        "sklearn._build_utils.openmp_helpers": {
            "get_openmp_flag": [
                "compiler"
            ],
            "check_openmp_support": []
        },
        "sklearn._build_utils": {
            "get_blas_info": [],
            "build_from_c_and_cpp_files": [
                "extensions"
            ],
            "maybe_cythonize_extensions": [
                "top_path",
                "config"
            ]
        },
        "sklearn.linear_model.passive_aggressive": {
            "PassiveAggressiveClassifier": {
                "__init__": [
                    "self",
                    "C",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "shuffle",
                    "verbose",
                    "loss",
                    "n_jobs",
                    "random_state",
                    "warm_start",
                    "class_weight",
                    "average"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init"
                ]
            },
            "PassiveAggressiveRegressor": {
                "__init__": [
                    "self",
                    "C",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "shuffle",
                    "verbose",
                    "loss",
                    "epsilon",
                    "random_state",
                    "warm_start",
                    "average"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init"
                ]
            }
        },
        "sklearn.linear_model.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.linear_model": {},
        "sklearn.linear_model.perceptron": {
            "Perceptron": {
                "__init__": [
                    "self",
                    "penalty",
                    "alpha",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "shuffle",
                    "verbose",
                    "eta0",
                    "n_jobs",
                    "random_state",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "class_weight",
                    "warm_start"
                ]
            }
        },
        "sklearn.linear_model.logistic": {
            "_intercept_dot": [
                "w",
                "X",
                "y"
            ],
            "_logistic_loss_and_grad": [
                "w",
                "X",
                "y",
                "alpha",
                "sample_weight"
            ],
            "_logistic_loss": [
                "w",
                "X",
                "y",
                "alpha",
                "sample_weight"
            ],
            "_logistic_grad_hess": [
                "w",
                "X",
                "y",
                "alpha",
                "sample_weight"
            ],
            "_multinomial_loss": [
                "w",
                "X",
                "Y",
                "alpha",
                "sample_weight"
            ],
            "_multinomial_loss_grad": [
                "w",
                "X",
                "Y",
                "alpha",
                "sample_weight"
            ],
            "_multinomial_grad_hess": [
                "w",
                "X",
                "Y",
                "alpha",
                "sample_weight"
            ],
            "_check_solver": [
                "solver",
                "penalty",
                "dual"
            ],
            "_check_multi_class": [
                "multi_class",
                "solver",
                "n_classes"
            ],
            "logistic_regression_path": [
                "X",
                "y",
                "pos_class",
                "Cs",
                "fit_intercept",
                "max_iter",
                "tol",
                "verbose",
                "solver",
                "coef",
                "class_weight",
                "dual",
                "penalty",
                "intercept_scaling",
                "multi_class",
                "random_state",
                "check_input",
                "max_squared_sum",
                "sample_weight",
                "l1_ratio"
            ],
            "_logistic_regression_path": [
                "X",
                "y",
                "pos_class",
                "Cs",
                "fit_intercept",
                "max_iter",
                "tol",
                "verbose",
                "solver",
                "coef",
                "class_weight",
                "dual",
                "penalty",
                "intercept_scaling",
                "multi_class",
                "random_state",
                "check_input",
                "max_squared_sum",
                "sample_weight",
                "l1_ratio"
            ],
            "_log_reg_scoring_path": [
                "X",
                "y",
                "train",
                "test",
                "pos_class",
                "Cs",
                "scoring",
                "fit_intercept",
                "max_iter",
                "tol",
                "class_weight",
                "verbose",
                "solver",
                "penalty",
                "dual",
                "intercept_scaling",
                "multi_class",
                "random_state",
                "max_squared_sum",
                "sample_weight",
                "l1_ratio"
            ],
            "LogisticRegression": {
                "__init__": [
                    "self",
                    "penalty",
                    "dual",
                    "tol",
                    "C",
                    "fit_intercept",
                    "intercept_scaling",
                    "class_weight",
                    "random_state",
                    "solver",
                    "max_iter",
                    "multi_class",
                    "verbose",
                    "warm_start",
                    "n_jobs",
                    "l1_ratio"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "LogisticRegressionCV": {
                "__init__": [
                    "self",
                    "Cs",
                    "fit_intercept",
                    "cv",
                    "dual",
                    "penalty",
                    "scoring",
                    "solver",
                    "tol",
                    "max_iter",
                    "class_weight",
                    "n_jobs",
                    "verbose",
                    "refit",
                    "intercept_scaling",
                    "multi_class",
                    "random_state",
                    "l1_ratios"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            }
        },
        "sklearn.linear_model.huber": {
            "_huber_loss_and_gradient": [
                "w",
                "X",
                "y",
                "epsilon",
                "alpha",
                "sample_weight"
            ],
            "HuberRegressor": {
                "__init__": [
                    "self",
                    "epsilon",
                    "max_iter",
                    "alpha",
                    "warm_start",
                    "fit_intercept",
                    "tol"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            }
        },
        "sklearn.linear_model.stochastic_gradient": {
            "_prepare_fit_binary": [
                "est",
                "y",
                "i"
            ],
            "fit_binary": [
                "est",
                "i",
                "X",
                "y",
                "alpha",
                "C",
                "learning_rate",
                "max_iter",
                "pos_weight",
                "neg_weight",
                "sample_weight",
                "validation_mask",
                "random_state"
            ],
            "_ValidationScoreCallback": {
                "__init__": [
                    "self",
                    "estimator",
                    "X_val",
                    "y_val",
                    "sample_weight_val",
                    "classes"
                ],
                "__call__": [
                    "self",
                    "coef",
                    "intercept"
                ]
            },
            "BaseSGD": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "C",
                    "l1_ratio",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "warm_start",
                    "average"
                ],
                "set_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_params": [
                    "self",
                    "set_max_iter",
                    "for_partial_fit"
                ],
                "_get_loss_function": [
                    "self",
                    "loss"
                ],
                "_get_learning_rate_type": [
                    "self",
                    "learning_rate"
                ],
                "_get_penalty_type": [
                    "self",
                    "penalty"
                ],
                "_validate_sample_weight": [
                    "self",
                    "sample_weight",
                    "n_samples"
                ],
                "_allocate_parameter_mem": [
                    "self",
                    "n_classes",
                    "n_features",
                    "coef_init",
                    "intercept_init"
                ],
                "_make_validation_split": [
                    "self",
                    "y"
                ],
                "_make_validation_score_cb": [
                    "self",
                    "validation_mask",
                    "X",
                    "y",
                    "sample_weight",
                    "classes"
                ]
            },
            "BaseSGDClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "n_jobs",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "class_weight",
                    "warm_start",
                    "average"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "max_iter",
                    "classes",
                    "sample_weight",
                    "coef_init",
                    "intercept_init"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "coef_init",
                    "intercept_init",
                    "sample_weight"
                ],
                "_fit_binary": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "sample_weight",
                    "learning_rate",
                    "max_iter"
                ],
                "_fit_multiclass": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "learning_rate",
                    "sample_weight",
                    "max_iter"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init",
                    "sample_weight"
                ]
            },
            "SGDClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "n_jobs",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "class_weight",
                    "warm_start",
                    "average"
                ],
                "_check_proba": [
                    "self"
                ],
                "predict_proba": [
                    "self"
                ],
                "_predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self"
                ],
                "_predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "BaseSGDRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "warm_start",
                    "average"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "max_iter",
                    "sample_weight",
                    "coef_init",
                    "intercept_init"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "coef_init",
                    "intercept_init",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init",
                    "sample_weight"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_fit_regressor": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "sample_weight",
                    "max_iter"
                ]
            },
            "SGDRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "max_iter",
                    "tol",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "early_stopping",
                    "validation_fraction",
                    "n_iter_no_change",
                    "warm_start",
                    "average"
                ]
            }
        },
        "sklearn.linear_model.bayes": {
            "BayesianRidge": {
                "__init__": [
                    "self",
                    "n_iter",
                    "tol",
                    "alpha_1",
                    "alpha_2",
                    "lambda_1",
                    "lambda_2",
                    "compute_score",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X",
                    "return_std"
                ],
                "_update_coef_": [
                    "self",
                    "X",
                    "y",
                    "n_samples",
                    "n_features",
                    "XT_y",
                    "U",
                    "Vh",
                    "eigen_vals_",
                    "alpha_",
                    "lambda_"
                ],
                "_log_marginal_likelihood": [
                    "self",
                    "n_samples",
                    "n_features",
                    "eigen_vals",
                    "alpha_",
                    "lambda_",
                    "coef",
                    "rmse"
                ]
            },
            "ARDRegression": {
                "__init__": [
                    "self",
                    "n_iter",
                    "tol",
                    "alpha_1",
                    "alpha_2",
                    "lambda_1",
                    "lambda_2",
                    "compute_score",
                    "threshold_lambda",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X",
                    "return_std"
                ]
            }
        },
        "sklearn.linear_model.ridge": {
            "_solve_sparse_cg": [
                "X",
                "y",
                "alpha",
                "max_iter",
                "tol",
                "verbose",
                "X_offset",
                "X_scale"
            ],
            "_solve_lsqr": [
                "X",
                "y",
                "alpha",
                "max_iter",
                "tol"
            ],
            "_solve_cholesky": [
                "X",
                "y",
                "alpha"
            ],
            "_solve_cholesky_kernel": [
                "K",
                "y",
                "alpha",
                "sample_weight",
                "copy"
            ],
            "_solve_svd": [
                "X",
                "y",
                "alpha"
            ],
            "ridge_regression": [
                "X",
                "y",
                "alpha",
                "sample_weight",
                "solver",
                "max_iter",
                "tol",
                "verbose",
                "random_state",
                "return_n_iter",
                "return_intercept"
            ],
            "_ridge_regression": [
                "X",
                "y",
                "alpha",
                "sample_weight",
                "solver",
                "max_iter",
                "tol",
                "verbose",
                "random_state",
                "return_n_iter",
                "return_intercept",
                "X_scale",
                "X_offset"
            ],
            "_BaseRidge": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "solver",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "Ridge": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "solver",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "RidgeClassifier": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "class_weight",
                    "solver",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "classes_": [
                    "self"
                ]
            },
            "_RidgeGCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "scoring",
                    "copy_X",
                    "gcv_mode",
                    "store_cv_values"
                ],
                "_pre_compute": [
                    "self",
                    "X",
                    "y",
                    "centered_kernel"
                ],
                "_decomp_diag": [
                    "self",
                    "v_prime",
                    "Q"
                ],
                "_diag_dot": [
                    "self",
                    "D",
                    "B"
                ],
                "_errors_and_values_helper": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "Q",
                    "QT_y"
                ],
                "_errors": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "Q",
                    "QT_y"
                ],
                "_values": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "Q",
                    "QT_y"
                ],
                "_pre_compute_svd": [
                    "self",
                    "X",
                    "y",
                    "centered_kernel"
                ],
                "_errors_and_values_svd_helper": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "U",
                    "UT_y"
                ],
                "_errors_svd": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "U",
                    "UT_y"
                ],
                "_values_svd": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "U",
                    "UT_y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "_BaseRidgeCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "scoring",
                    "cv",
                    "gcv_mode",
                    "store_cv_values"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "RidgeCV": {},
            "RidgeClassifierCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "scoring",
                    "cv",
                    "class_weight",
                    "store_cv_values"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "classes_": [
                    "self"
                ]
            }
        },
        "sklearn.linear_model.least_angle": {
            "lars_path": [
                "X",
                "y",
                "Xy",
                "Gram",
                "max_iter",
                "alpha_min",
                "method",
                "copy_X",
                "eps",
                "copy_Gram",
                "verbose",
                "return_path",
                "return_n_iter",
                "positive"
            ],
            "lars_path_gram": [
                "Xy",
                "Gram",
                "n_samples",
                "max_iter",
                "alpha_min",
                "method",
                "copy_X",
                "eps",
                "copy_Gram",
                "verbose",
                "return_path",
                "return_n_iter",
                "positive"
            ],
            "_lars_path_solver": [
                "X",
                "y",
                "Xy",
                "Gram",
                "n_samples",
                "max_iter",
                "alpha_min",
                "method",
                "copy_X",
                "eps",
                "copy_Gram",
                "verbose",
                "return_path",
                "return_n_iter",
                "positive"
            ],
            "_check_copy_and_writeable": [
                "array",
                "copy"
            ],
            "_lars_path_residues": [
                "X_train",
                "y_train",
                "X_test",
                "y_test",
                "Gram",
                "copy",
                "method",
                "verbose",
                "fit_intercept",
                "normalize",
                "max_iter",
                "eps",
                "positive"
            ],
            "Lars": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "n_nonzero_coefs",
                    "eps",
                    "copy_X",
                    "fit_path",
                    "positive"
                ],
                "_get_gram": [
                    "precompute",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "max_iter",
                    "alpha",
                    "fit_path",
                    "Xy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "Xy"
                ]
            },
            "LassoLars": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "eps",
                    "copy_X",
                    "fit_path",
                    "positive"
                ]
            },
            "LarsCV": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "verbose",
                    "max_iter",
                    "normalize",
                    "precompute",
                    "cv",
                    "max_n_alphas",
                    "n_jobs",
                    "eps",
                    "copy_X",
                    "positive"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LassoLarsCV": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "verbose",
                    "max_iter",
                    "normalize",
                    "precompute",
                    "cv",
                    "max_n_alphas",
                    "n_jobs",
                    "eps",
                    "copy_X",
                    "positive"
                ]
            },
            "LassoLarsIC": {
                "__init__": [
                    "self",
                    "criterion",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "eps",
                    "copy_X",
                    "positive"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "copy_X"
                ]
            }
        },
        "sklearn.linear_model.base": {
            "make_dataset": [
                "X",
                "y",
                "sample_weight",
                "random_state"
            ],
            "_preprocess_data": [
                "X",
                "y",
                "fit_intercept",
                "normalize",
                "copy",
                "sample_weight",
                "return_mean",
                "check_input"
            ],
            "_rescale_data": [
                "X",
                "y",
                "sample_weight"
            ],
            "_pre_fit": [
                "X",
                "y",
                "Xy",
                "precompute",
                "normalize",
                "fit_intercept",
                "copy",
                "check_input"
            ],
            "LinearModel": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_set_intercept": [
                    "self",
                    "X_offset",
                    "y_offset",
                    "X_scale"
                ]
            },
            "LinearClassifierMixin": {
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_predict_proba_lr": [
                    "self",
                    "X"
                ]
            },
            "SparseCoefMixin": {
                "densify": [
                    "self"
                ],
                "sparsify": [
                    "self"
                ]
            },
            "LinearRegression": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            }
        },
        "sklearn.linear_model.omp": {
            "_cholesky_omp": [
                "X",
                "y",
                "n_nonzero_coefs",
                "tol",
                "copy_X",
                "return_path"
            ],
            "_gram_omp": [
                "Gram",
                "Xy",
                "n_nonzero_coefs",
                "tol_0",
                "tol",
                "copy_Gram",
                "copy_Xy",
                "return_path"
            ],
            "orthogonal_mp": [
                "X",
                "y",
                "n_nonzero_coefs",
                "tol",
                "precompute",
                "copy_X",
                "return_path",
                "return_n_iter"
            ],
            "orthogonal_mp_gram": [
                "Gram",
                "Xy",
                "n_nonzero_coefs",
                "tol",
                "norms_squared",
                "copy_Gram",
                "copy_Xy",
                "return_path",
                "return_n_iter"
            ],
            "_omp_path_residues": [
                "X_train",
                "y_train",
                "X_test",
                "y_test",
                "copy",
                "fit_intercept",
                "normalize",
                "max_iter"
            ],
            "OrthogonalMatchingPursuit": {
                "__init__": [
                    "self",
                    "n_nonzero_coefs",
                    "tol",
                    "fit_intercept",
                    "normalize",
                    "precompute"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "OrthogonalMatchingPursuitCV": {
                "__init__": [
                    "self",
                    "copy",
                    "fit_intercept",
                    "normalize",
                    "max_iter",
                    "cv",
                    "n_jobs",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.linear_model.sag": {
            "get_auto_step_size": [
                "max_squared_sum",
                "alpha_scaled",
                "loss",
                "fit_intercept",
                "n_samples",
                "is_saga"
            ],
            "sag_solver": [
                "X",
                "y",
                "sample_weight",
                "loss",
                "alpha",
                "beta",
                "max_iter",
                "tol",
                "verbose",
                "random_state",
                "check_input",
                "max_squared_sum",
                "warm_start_mem",
                "is_saga"
            ]
        },
        "sklearn.linear_model.theil_sen": {
            "_modified_weiszfeld_step": [
                "X",
                "x_old"
            ],
            "_spatial_median": [
                "X",
                "max_iter",
                "tol"
            ],
            "_breakdown_point": [
                "n_samples",
                "n_subsamples"
            ],
            "_lstsq": [
                "X",
                "y",
                "indices",
                "fit_intercept"
            ],
            "TheilSenRegressor": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "copy_X",
                    "max_subpopulation",
                    "n_subsamples",
                    "max_iter",
                    "tol",
                    "random_state",
                    "n_jobs",
                    "verbose"
                ],
                "_check_subparams": [
                    "self",
                    "n_samples",
                    "n_features"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.linear_model.coordinate_descent": {
            "_alpha_grid": [
                "X",
                "y",
                "Xy",
                "l1_ratio",
                "fit_intercept",
                "eps",
                "n_alphas",
                "normalize",
                "copy_X"
            ],
            "lasso_path": [
                "X",
                "y",
                "eps",
                "n_alphas",
                "alphas",
                "precompute",
                "Xy",
                "copy_X",
                "coef_init",
                "verbose",
                "return_n_iter",
                "positive"
            ],
            "enet_path": [
                "X",
                "y",
                "l1_ratio",
                "eps",
                "n_alphas",
                "alphas",
                "precompute",
                "Xy",
                "copy_X",
                "coef_init",
                "verbose",
                "return_n_iter",
                "positive",
                "check_input"
            ],
            "_path_residuals": [
                "X",
                "y",
                "train",
                "test",
                "path",
                "path_params",
                "alphas",
                "l1_ratio",
                "X_order",
                "dtype"
            ],
            "ElasticNet": {
                "__init__": [
                    "self",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "copy_X",
                    "tol",
                    "warm_start",
                    "positive",
                    "random_state",
                    "selection"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "check_input"
                ],
                "sparse_coef_": [
                    "self"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ]
            },
            "Lasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "warm_start",
                    "positive",
                    "random_state",
                    "selection"
                ]
            },
            "LinearModelCV": {
                "__init__": [
                    "self",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "tol",
                    "copy_X",
                    "cv",
                    "verbose",
                    "n_jobs",
                    "positive",
                    "random_state",
                    "selection"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LassoCV": {
                "__init__": [
                    "self",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "tol",
                    "copy_X",
                    "cv",
                    "verbose",
                    "n_jobs",
                    "positive",
                    "random_state",
                    "selection"
                ]
            },
            "ElasticNetCV": {
                "__init__": [
                    "self",
                    "l1_ratio",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "tol",
                    "cv",
                    "copy_X",
                    "verbose",
                    "n_jobs",
                    "positive",
                    "random_state",
                    "selection"
                ]
            },
            "MultiTaskElasticNet": {
                "__init__": [
                    "self",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "warm_start",
                    "random_state",
                    "selection"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MultiTaskLasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "warm_start",
                    "random_state",
                    "selection"
                ]
            },
            "MultiTaskElasticNetCV": {
                "__init__": [
                    "self",
                    "l1_ratio",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "max_iter",
                    "tol",
                    "cv",
                    "copy_X",
                    "verbose",
                    "n_jobs",
                    "random_state",
                    "selection"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MultiTaskLassoCV": {
                "__init__": [
                    "self",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "max_iter",
                    "tol",
                    "copy_X",
                    "cv",
                    "verbose",
                    "n_jobs",
                    "random_state",
                    "selection"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.linear_model.ransac": {
            "_dynamic_max_trials": [
                "n_inliers",
                "n_samples",
                "min_samples",
                "probability"
            ],
            "RANSACRegressor": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "min_samples",
                    "residual_threshold",
                    "is_data_valid",
                    "is_model_valid",
                    "max_trials",
                    "max_skips",
                    "stop_n_inliers",
                    "stop_score",
                    "stop_probability",
                    "loss",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.linear_model.tests.test_ridge": {
            "test_ridge": [
                "solver"
            ],
            "test_primal_dual_relationship": [],
            "test_ridge_singular": [],
            "test_ridge_regression_sample_weights": [],
            "test_ridge_regression_convergence_fail": [],
            "test_ridge_sample_weights": [],
            "test_ridge_shapes": [],
            "test_ridge_intercept": [],
            "test_toy_ridge_object": [],
            "test_ridge_vs_lstsq": [],
            "test_ridge_individual_penalties": [],
            "_test_ridge_loo": [
                "filter_"
            ],
            "_test_ridge_cv_normalize": [
                "filter_"
            ],
            "_test_ridge_cv": [
                "filter_"
            ],
            "_test_ridge_diabetes": [
                "filter_"
            ],
            "_test_multi_ridge_diabetes": [
                "filter_"
            ],
            "_test_ridge_classifiers": [
                "filter_"
            ],
            "_test_tolerance": [
                "filter_"
            ],
            "check_dense_sparse": [
                "test_func"
            ],
            "test_dense_sparse": [
                "test_func"
            ],
            "test_ridge_cv_sparse_svd": [],
            "test_ridge_sparse_svd": [],
            "test_class_weights": [],
            "test_class_weight_vs_sample_weight": [
                "reg"
            ],
            "test_class_weights_cv": [],
            "test_ridgecv_store_cv_values": [],
            "test_ridge_classifier_cv_store_cv_values": [],
            "test_ridgecv_sample_weight": [],
            "test_raises_value_error_if_sample_weights_greater_than_1d": [],
            "test_sparse_design_with_sample_weights": [],
            "test_ridgecv_int_alphas": [],
            "test_ridgecv_negative_alphas": [],
            "test_raises_value_error_if_solver_not_supported": [],
            "test_sparse_cg_max_iter": [],
            "test_n_iter": [],
            "test_ridge_fit_intercept_sparse": [],
            "test_ridge_regression_check_arguments_validity": [
                "return_intercept",
                "sample_weight",
                "arr_type",
                "solver"
            ],
            "test_errors_and_values_helper": [],
            "test_errors_and_values_svd_helper": [],
            "test_ridge_classifier_no_support_multilabel": [],
            "test_dtype_match": [],
            "test_dtype_match_cholesky": []
        },
        "sklearn.linear_model.tests.test_sparse_coordinate_descent": {
            "test_sparse_coef": [],
            "test_normalize_option": [],
            "test_lasso_zero": [],
            "test_enet_toy_list_input": [],
            "test_enet_toy_explicit_sparse_input": [],
            "make_sparse_data": [
                "n_samples",
                "n_features",
                "n_informative",
                "seed",
                "positive",
                "n_targets"
            ],
            "_test_sparse_enet_not_as_toy_dataset": [
                "alpha",
                "fit_intercept",
                "positive"
            ],
            "test_sparse_enet_not_as_toy_dataset": [],
            "test_sparse_lasso_not_as_toy_dataset": [],
            "test_enet_multitarget": [],
            "test_path_parameters": [],
            "test_same_output_sparse_dense_lasso_and_enet_cv": [],
            "test_same_multiple_output_sparse_dense": [],
            "test_sparse_enet_coordinate_descent": []
        },
        "sklearn.linear_model.tests.test_ransac": {
            "test_ransac_inliers_outliers": [],
            "test_ransac_is_data_valid": [],
            "test_ransac_is_model_valid": [],
            "test_ransac_max_trials": [],
            "test_ransac_stop_n_inliers": [],
            "test_ransac_stop_score": [],
            "test_ransac_score": [],
            "test_ransac_predict": [],
            "test_ransac_resid_thresh_no_inliers": [],
            "test_ransac_no_valid_data": [],
            "test_ransac_no_valid_model": [],
            "test_ransac_exceed_max_skips": [],
            "test_ransac_warn_exceed_max_skips": [],
            "test_ransac_sparse_coo": [],
            "test_ransac_sparse_csr": [],
            "test_ransac_sparse_csc": [],
            "test_ransac_none_estimator": [],
            "test_ransac_min_n_samples": [],
            "test_ransac_multi_dimensional_targets": [],
            "test_ransac_residual_loss": [],
            "test_ransac_default_residual_threshold": [],
            "test_ransac_dynamic_max_trials": [],
            "test_ransac_fit_sample_weight": []
        },
        "sklearn.linear_model.tests.test_huber": {
            "make_regression_with_outliers": [
                "n_samples",
                "n_features"
            ],
            "test_huber_equals_lr_for_high_epsilon": [],
            "test_huber_max_iter": [],
            "test_huber_gradient": [],
            "test_huber_sample_weights": [],
            "test_huber_sparse": [],
            "test_huber_scaling_invariant": [],
            "test_huber_and_sgd_same_results": [],
            "test_huber_warm_start": [],
            "test_huber_better_r2_score": [],
            "test_huber_bool": []
        },
        "sklearn.linear_model.tests.test_base": {
            "test_linear_regression": [],
            "test_linear_regression_sample_weights": [],
            "test_raises_value_error_if_sample_weights_greater_than_1d": [],
            "test_fit_intercept": [],
            "test_linear_regression_sparse": [
                "random_state"
            ],
            "test_linear_regression_sparse_equal_dense": [
                "normalize",
                "fit_intercept"
            ],
            "test_linear_regression_multiple_outcome": [
                "random_state"
            ],
            "test_linear_regression_sparse_multiple_outcome": [
                "random_state"
            ],
            "test_preprocess_data": [],
            "test_preprocess_data_multioutput": [],
            "test_preprocess_data_weighted": [],
            "test_sparse_preprocess_data_with_return_mean": [],
            "test_csr_preprocess_data": [],
            "test_preprocess_copy_data_no_checks": [
                "is_sparse",
                "to_copy"
            ],
            "test_dtype_preprocess_data": [],
            "test_rescale_data": [],
            "test_fused_types_make_dataset": []
        },
        "sklearn.linear_model.tests.test_coordinate_descent": {
            "test_lasso_zero": [],
            "test_lasso_toy": [],
            "test_enet_toy": [],
            "build_dataset": [
                "n_samples",
                "n_features",
                "n_informative_features",
                "n_targets"
            ],
            "test_lasso_cv": [],
            "test_lasso_cv_with_some_model_selection": [],
            "test_lasso_cv_positive_constraint": [],
            "test_lasso_path_return_models_vs_new_return_gives_same_coefficients": [],
            "test_enet_path": [],
            "test_path_parameters": [],
            "test_warm_start": [],
            "test_lasso_alpha_warning": [],
            "test_lasso_positive_constraint": [],
            "test_enet_positive_constraint": [],
            "test_enet_cv_positive_constraint": [],
            "test_uniform_targets": [],
            "test_multi_task_lasso_and_enet": [],
            "test_lasso_readonly_data": [],
            "test_multi_task_lasso_readonly_data": [],
            "test_enet_multitarget": [],
            "test_multioutput_enetcv_error": [],
            "test_multitask_enet_and_lasso_cv": [],
            "test_1d_multioutput_enet_and_multitask_enet_cv": [],
            "test_1d_multioutput_lasso_and_multitask_lasso_cv": [],
            "test_sparse_input_dtype_enet_and_lassocv": [],
            "test_precompute_invalid_argument": [],
            "test_warm_start_convergence": [],
            "test_warm_start_convergence_with_regularizer_decrement": [],
            "test_random_descent": [],
            "test_enet_path_positive": [],
            "test_sparse_dense_descent_paths": [],
            "test_check_input_false": [],
            "test_enet_copy_X_True": [
                "check_input"
            ],
            "test_enet_copy_X_False_check_input_False": [],
            "test_overrided_gram_matrix": [],
            "test_lasso_non_float_y": [
                "model"
            ],
            "test_enet_float_precision": [],
            "test_enet_l1_ratio": [],
            "test_coef_shape_not_zero": [],
            "test_warm_start_multitask_lasso": [],
            "test_enet_coordinate_descent": [
                "klass",
                "n_classes",
                "kwargs"
            ],
            "test_convergence_warnings": [],
            "test_sparse_input_convergence_warning": []
        },
        "sklearn.linear_model.tests.test_theil_sen": {
            "no_stdout_stderr": [],
            "gen_toy_problem_1d": [
                "intercept"
            ],
            "gen_toy_problem_2d": [],
            "gen_toy_problem_4d": [],
            "test_modweiszfeld_step_1d": [],
            "test_modweiszfeld_step_2d": [],
            "test_spatial_median_1d": [],
            "test_spatial_median_2d": [],
            "test_theil_sen_1d": [],
            "test_theil_sen_1d_no_intercept": [],
            "test_theil_sen_2d": [],
            "test_calc_breakdown_point": [],
            "test_checksubparams_negative_subpopulation": [],
            "test_checksubparams_too_few_subsamples": [],
            "test_checksubparams_too_many_subsamples": [],
            "test_checksubparams_n_subsamples_if_less_samples_than_features": [],
            "test_subpopulation": [],
            "test_subsamples": [],
            "test_verbosity": [],
            "test_theil_sen_parallel": [],
            "test_less_samples_than_features": []
        },
        "sklearn.linear_model.tests": {},
        "sklearn.linear_model.tests.test_sag": {
            "log_dloss": [
                "p",
                "y"
            ],
            "log_loss": [
                "p",
                "y"
            ],
            "squared_dloss": [
                "p",
                "y"
            ],
            "squared_loss": [
                "p",
                "y"
            ],
            "get_pobj": [
                "w",
                "alpha",
                "myX",
                "myy",
                "loss"
            ],
            "sag": [
                "X",
                "y",
                "step_size",
                "alpha",
                "n_iter",
                "dloss",
                "sparse",
                "sample_weight",
                "fit_intercept",
                "saga"
            ],
            "sag_sparse": [
                "X",
                "y",
                "step_size",
                "alpha",
                "n_iter",
                "dloss",
                "sample_weight",
                "sparse",
                "fit_intercept",
                "saga"
            ],
            "get_step_size": [
                "X",
                "alpha",
                "fit_intercept",
                "classification"
            ],
            "test_classifier_matching": [],
            "test_regressor_matching": [],
            "test_sag_pobj_matches_logistic_regression": [],
            "test_sag_pobj_matches_ridge_regression": [],
            "test_sag_regressor_computed_correctly": [],
            "test_get_auto_step_size": [],
            "test_sag_regressor": [],
            "test_sag_classifier_computed_correctly": [],
            "test_sag_multiclass_computed_correctly": [],
            "test_classifier_results": [],
            "test_binary_classifier_class_weight": [],
            "test_multiclass_classifier_class_weight": [],
            "test_classifier_single_class": [],
            "test_step_size_alpha_error": [],
            "test_multinomial_loss": [],
            "test_multinomial_loss_ground_truth": [],
            "test_sag_classifier_raises_error": [
                "solver"
            ]
        },
        "sklearn.linear_model.tests.test_sgd": {
            "_update_kwargs": [
                "kwargs"
            ],
            "SGDClassifier": [],
            "SGDRegressor": [],
            "SparseSGDClassifier": [],
            "SparseSGDRegressor": [],
            "asgd": [
                "klass",
                "X",
                "y",
                "eta",
                "alpha",
                "weight_init",
                "intercept_init"
            ],
            "test_sgd_bad_alpha": [
                "klass"
            ],
            "test_sgd_bad_penalty": [
                "klass"
            ],
            "test_sgd_bad_loss": [
                "klass"
            ],
            "_test_warm_start": [
                "klass",
                "X",
                "Y",
                "lr"
            ],
            "test_warm_start": [
                "klass",
                "lr"
            ],
            "test_input_format": [
                "klass"
            ],
            "test_clone": [
                "klass"
            ],
            "test_plain_has_no_average_attr": [
                "klass"
            ],
            "test_late_onset_averaging_not_reached": [
                "klass"
            ],
            "test_late_onset_averaging_reached": [
                "klass"
            ],
            "test_sgd_bad_alpha_for_optimal_learning_rate": [
                "klass"
            ],
            "test_early_stopping": [
                "klass"
            ],
            "test_adaptive_longer_than_constant": [
                "klass"
            ],
            "test_validation_set_not_used_for_training": [
                "klass"
            ],
            "test_n_iter_no_change": [
                "klass"
            ],
            "test_not_enough_sample_for_early_stopping": [
                "klass"
            ],
            "test_sgd_clf": [
                "klass"
            ],
            "test_sgd_bad_l1_ratio": [
                "klass"
            ],
            "test_sgd_bad_learning_rate_schedule": [
                "klass"
            ],
            "test_sgd_bad_eta0": [
                "klass"
            ],
            "test_sgd_max_iter_param": [
                "klass"
            ],
            "test_sgd_shuffle_param": [
                "klass"
            ],
            "test_sgd_early_stopping_param": [
                "klass"
            ],
            "test_sgd_validation_fraction": [
                "klass"
            ],
            "test_sgd_n_iter_no_change": [
                "klass"
            ],
            "test_argument_coef": [
                "klass"
            ],
            "test_provide_coef": [
                "klass"
            ],
            "test_set_intercept": [
                "klass"
            ],
            "test_sgd_early_stopping_with_partial_fit": [
                "klass"
            ],
            "test_set_intercept_binary": [
                "klass"
            ],
            "test_average_binary_computed_correctly": [
                "klass"
            ],
            "test_set_intercept_to_intercept": [
                "klass"
            ],
            "test_sgd_at_least_two_labels": [
                "klass"
            ],
            "test_partial_fit_weight_class_balanced": [
                "klass"
            ],
            "test_sgd_multiclass": [
                "klass"
            ],
            "test_sgd_multiclass_average": [
                "klass"
            ],
            "test_sgd_multiclass_with_init_coef": [
                "klass"
            ],
            "test_sgd_multiclass_njobs": [
                "klass"
            ],
            "test_set_coef_multiclass": [
                "klass"
            ],
            "test_sgd_predict_proba_method_access": [
                "klass"
            ],
            "test_sgd_proba": [
                "klass"
            ],
            "test_sgd_l1": [
                "klass"
            ],
            "test_class_weights": [
                "klass"
            ],
            "test_equal_class_weight": [
                "klass"
            ],
            "test_wrong_class_weight_label": [
                "klass"
            ],
            "test_wrong_class_weight_format": [
                "klass"
            ],
            "test_weights_multiplied": [
                "klass"
            ],
            "test_balanced_weight": [
                "klass"
            ],
            "test_sample_weights": [
                "klass"
            ],
            "test_wrong_sample_weights": [
                "klass"
            ],
            "test_partial_fit_exception": [
                "klass"
            ],
            "test_partial_fit_binary": [
                "klass"
            ],
            "test_partial_fit_multiclass": [
                "klass"
            ],
            "test_partial_fit_multiclass_average": [
                "klass"
            ],
            "test_fit_then_partial_fit": [
                "klass"
            ],
            "test_partial_fit_equal_fit_classif": [
                "klass",
                "lr"
            ],
            "test_regression_losses": [
                "klass"
            ],
            "test_warm_start_multiclass": [
                "klass"
            ],
            "test_multiple_fit": [
                "klass"
            ],
            "test_sgd_reg": [
                "klass"
            ],
            "test_sgd_averaged_computed_correctly": [
                "klass"
            ],
            "test_sgd_averaged_partial_fit": [
                "klass"
            ],
            "test_average_sparse": [
                "klass"
            ],
            "test_sgd_least_squares_fit": [
                "klass"
            ],
            "test_sgd_epsilon_insensitive": [
                "klass"
            ],
            "test_sgd_huber_fit": [
                "klass"
            ],
            "test_elasticnet_convergence": [
                "klass"
            ],
            "test_partial_fit": [
                "klass"
            ],
            "test_partial_fit_equal_fit": [
                "klass",
                "lr"
            ],
            "test_loss_function_epsilon": [
                "klass"
            ],
            "test_l1_ratio": [],
            "test_underflow_or_overlow": [],
            "test_numerical_stability_large_gradient": [],
            "test_large_regularization": [
                "penalty"
            ],
            "test_tol_parameter": [],
            "_test_gradient_common": [
                "loss_function",
                "cases"
            ],
            "test_gradient_hinge": [],
            "test_gradient_squared_hinge": [],
            "test_gradient_log": [],
            "test_gradient_squared_loss": [],
            "test_gradient_huber": [],
            "test_gradient_modified_huber": [],
            "test_gradient_epsilon_insensitive": [],
            "test_gradient_squared_epsilon_insensitive": [],
            "test_multi_thread_multi_class_and_early_stopping": [],
            "test_multi_core_gridsearch_and_early_stopping": [],
            "test_SGDClassifier_fit_for_all_backends": [
                "backend"
            ],
            "_SparseSGDClassifier": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "_SparseSGDRegressor": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.linear_model.tests.test_omp": {
            "test_correct_shapes": [],
            "test_correct_shapes_gram": [],
            "test_n_nonzero_coefs": [],
            "test_tol": [],
            "test_with_without_gram": [],
            "test_with_without_gram_tol": [],
            "test_unreachable_accuracy": [],
            "test_bad_input": [],
            "test_perfect_signal_recovery": [],
            "test_orthogonal_mp_gram_readonly": [],
            "test_estimator": [],
            "test_identical_regressors": [],
            "test_swapped_regressors": [],
            "test_no_atoms": [],
            "test_omp_path": [],
            "test_omp_return_path_prop_with_gram": [],
            "test_omp_cv": [],
            "test_omp_reaches_least_squares": []
        },
        "sklearn.linear_model.tests.test_perceptron": {
            "test_perceptron_accuracy": [],
            "test_perceptron_correctness": [],
            "test_undefined_methods": [],
            "MyPerceptron": {
                "__init__": [
                    "self",
                    "n_iter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "project": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.linear_model.tests.test_passive_aggressive": {
            "test_classifier_accuracy": [],
            "test_classifier_partial_fit": [],
            "test_classifier_refit": [],
            "test_classifier_correctness": [
                "loss"
            ],
            "test_classifier_undefined_methods": [],
            "test_class_weights": [],
            "test_partial_fit_weight_class_balanced": [],
            "test_equal_class_weight": [],
            "test_wrong_class_weight_label": [],
            "test_wrong_class_weight_format": [],
            "test_regressor_mse": [],
            "test_regressor_partial_fit": [],
            "test_regressor_correctness": [
                "loss"
            ],
            "test_regressor_undefined_methods": [],
            "MyPassiveAggressive": {
                "__init__": [
                    "self",
                    "C",
                    "epsilon",
                    "loss",
                    "fit_intercept",
                    "n_iter",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "project": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.linear_model.tests.test_least_angle": {
            "test_simple": [],
            "test_simple_precomputed": [],
            "_assert_same_lars_path_result": [
                "output1",
                "output2"
            ],
            "test_lars_path_gram_equivalent": [
                "method",
                "return_path"
            ],
            "test_x_none_gram_none_raises_value_error": [],
            "test_all_precomputed": [],
            "test_lars_lstsq": [],
            "test_lasso_gives_lstsq_solution": [],
            "test_collinearity": [],
            "test_no_path": [],
            "test_no_path_precomputed": [],
            "test_no_path_all_precomputed": [],
            "test_lars_precompute": [
                "classifier"
            ],
            "test_singular_matrix": [],
            "test_rank_deficient_design": [],
            "test_lasso_lars_vs_lasso_cd": [],
            "test_lasso_lars_vs_lasso_cd_early_stopping": [],
            "test_lasso_lars_path_length": [],
            "test_lasso_lars_vs_lasso_cd_ill_conditioned": [],
            "test_lasso_lars_vs_lasso_cd_ill_conditioned2": [],
            "test_lars_add_features": [],
            "test_lars_n_nonzero_coefs": [
                "verbose"
            ],
            "test_multitarget": [],
            "test_lars_cv": [],
            "test_lars_cv_max_iter": [],
            "test_lasso_lars_ic": [],
            "test_lars_path_readonly_data": [],
            "test_lars_path_positive_constraint": [],
            "test_estimatorclasses_positive_constraint": [],
            "test_lasso_lars_vs_lasso_cd_positive": [],
            "test_lasso_lars_vs_R_implementation": [],
            "test_lasso_lars_copyX_behaviour": [
                "copy_X"
            ],
            "test_lasso_lars_fit_copyX_behaviour": [
                "copy_X"
            ]
        },
        "sklearn.linear_model.tests.test_bayes": {
            "test_n_iter": [],
            "test_bayesian_ridge_scores": [],
            "test_bayesian_ridge_score_values": [],
            "test_bayesian_ridge_parameter": [],
            "test_bayesian_sample_weights": [],
            "test_toy_bayesian_ridge_object": [],
            "test_prediction_bayesian_ridge_ard_with_constant_input": [],
            "test_std_bayesian_ridge_ard_with_constant_input": [],
            "test_update_of_sigma_in_ard": [],
            "test_toy_ard_object": [],
            "test_return_std": []
        },
        "sklearn.linear_model.tests.test_logistic": {
            "check_predictions": [
                "clf",
                "X",
                "y"
            ],
            "test_predict_2_classes": [],
            "test_error": [],
            "test_logistic_cv_mock_scorer": [],
            "test_logistic_cv_score_does_not_warn_by_default": [],
            "test_lr_liblinear_warning": [],
            "test_predict_3_classes": [],
            "test_predict_iris": [],
            "test_multinomial_validation": [
                "solver"
            ],
            "test_check_solver_option": [
                "LR"
            ],
            "test_logistic_regression_warnings": [
                "model",
                "params",
                "warn_solver"
            ],
            "test_multinomial_binary": [
                "solver"
            ],
            "test_multinomial_binary_probabilities": [],
            "test_sparsify": [],
            "test_inconsistent_input": [],
            "test_write_parameters": [],
            "test_nan": [],
            "test_consistency_path": [],
            "test_logistic_regression_path_convergence_fail": [],
            "test_liblinear_dual_random_state": [],
            "test_logistic_loss_and_grad": [],
            "test_logistic_grad_hess": [],
            "test_logistic_cv": [],
            "test_logistic_cv_multinomial_score": [
                "scoring",
                "multiclass_agg_list"
            ],
            "test_multinomial_logistic_regression_string_inputs": [],
            "test_logistic_cv_sparse": [],
            "test_intercept_logistic_helper": [],
            "test_ovr_multinomial_iris": [],
            "test_logistic_regression_solvers": [],
            "test_logistic_regression_solvers_multiclass": [],
            "test_logistic_regressioncv_class_weights": [],
            "test_logistic_regression_sample_weights": [],
            "_compute_class_weight_dictionary": [
                "y"
            ],
            "test_logistic_regression_class_weights": [],
            "test_logistic_regression_multinomial": [],
            "test_multinomial_grad_hess": [],
            "test_liblinear_decision_function_zero": [],
            "test_liblinear_logregcv_sparse": [],
            "test_saga_sparse": [],
            "test_logreg_intercept_scaling": [],
            "test_logreg_intercept_scaling_zero": [],
            "test_logreg_l1": [],
            "test_logreg_l1_sparse_data": [],
            "test_logistic_regression_cv_refit": [
                "random_seed",
                "penalty"
            ],
            "test_logreg_predict_proba_multinomial": [],
            "test_max_iter": [],
            "test_n_iter": [
                "solver"
            ],
            "test_warm_start": [
                "solver",
                "warm_start",
                "fit_intercept",
                "multi_class"
            ],
            "test_saga_vs_liblinear": [],
            "test_dtype_match": [
                "solver",
                "multi_class"
            ],
            "test_warm_start_converge_LR": [],
            "test_elastic_net_coeffs": [],
            "test_elastic_net_l1_l2_equivalence": [
                "C",
                "penalty",
                "l1_ratio"
            ],
            "test_elastic_net_vs_l1_l2": [
                "C"
            ],
            "test_LogisticRegression_elastic_net_objective": [
                "C",
                "l1_ratio"
            ],
            "test_LogisticRegressionCV_GridSearchCV_elastic_net": [
                "multi_class"
            ],
            "test_LogisticRegressionCV_GridSearchCV_elastic_net_ovr": [],
            "test_LogisticRegressionCV_no_refit": [
                "multi_class"
            ],
            "test_LogisticRegressionCV_elasticnet_attribute_shapes": [],
            "test_l1_ratio_param": [
                "l1_ratio"
            ],
            "test_l1_ratios_param": [
                "l1_ratios"
            ],
            "test_elastic_net_versus_sgd": [
                "C",
                "l1_ratio"
            ],
            "test_logistic_regression_path_coefs_multinomial": [],
            "test_logistic_regression_multi_class_auto": [
                "est",
                "solver"
            ],
            "test_logistic_regression_path_deprecation": [],
            "test_penalty_none": [
                "solver"
            ]
        },
        "sklearn.neural_network._base": {
            "identity": [
                "X"
            ],
            "logistic": [
                "X"
            ],
            "tanh": [
                "X"
            ],
            "relu": [
                "X"
            ],
            "softmax": [
                "X"
            ],
            "inplace_identity_derivative": [
                "Z",
                "delta"
            ],
            "inplace_logistic_derivative": [
                "Z",
                "delta"
            ],
            "inplace_tanh_derivative": [
                "Z",
                "delta"
            ],
            "inplace_relu_derivative": [
                "Z",
                "delta"
            ],
            "squared_loss": [
                "y_true",
                "y_pred"
            ],
            "log_loss": [
                "y_true",
                "y_prob"
            ],
            "binary_log_loss": [
                "y_true",
                "y_prob"
            ]
        },
        "sklearn.neural_network": {},
        "sklearn.neural_network._stochastic_optimizers": {
            "BaseOptimizer": {
                "__init__": [
                    "self",
                    "params",
                    "learning_rate_init"
                ],
                "update_params": [
                    "self",
                    "grads"
                ],
                "iteration_ends": [
                    "self",
                    "time_step"
                ],
                "trigger_stopping": [
                    "self",
                    "msg",
                    "verbose"
                ]
            },
            "SGDOptimizer": {
                "__init__": [
                    "self",
                    "params",
                    "learning_rate_init",
                    "lr_schedule",
                    "momentum",
                    "nesterov",
                    "power_t"
                ],
                "iteration_ends": [
                    "self",
                    "time_step"
                ],
                "trigger_stopping": [
                    "self",
                    "msg",
                    "verbose"
                ],
                "_get_updates": [
                    "self",
                    "grads"
                ]
            },
            "AdamOptimizer": {
                "__init__": [
                    "self",
                    "params",
                    "learning_rate_init",
                    "beta_1",
                    "beta_2",
                    "epsilon"
                ],
                "_get_updates": [
                    "self",
                    "grads"
                ]
            }
        },
        "sklearn.neural_network.rbm": {
            "BernoulliRBM": {
                "__init__": [
                    "self",
                    "n_components",
                    "learning_rate",
                    "batch_size",
                    "n_iter",
                    "verbose",
                    "random_state"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_mean_hiddens": [
                    "self",
                    "v"
                ],
                "_sample_hiddens": [
                    "self",
                    "v",
                    "rng"
                ],
                "_sample_visibles": [
                    "self",
                    "h",
                    "rng"
                ],
                "_free_energy": [
                    "self",
                    "v"
                ],
                "gibbs": [
                    "self",
                    "v"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "v_pos",
                    "rng"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.neural_network.multilayer_perceptron": {
            "_pack": [
                "coefs_",
                "intercepts_"
            ],
            "BaseMultilayerPerceptron": {
                "__init__": [
                    "self",
                    "hidden_layer_sizes",
                    "activation",
                    "solver",
                    "alpha",
                    "batch_size",
                    "learning_rate",
                    "learning_rate_init",
                    "power_t",
                    "max_iter",
                    "loss",
                    "shuffle",
                    "random_state",
                    "tol",
                    "verbose",
                    "warm_start",
                    "momentum",
                    "nesterovs_momentum",
                    "early_stopping",
                    "validation_fraction",
                    "beta_1",
                    "beta_2",
                    "epsilon",
                    "n_iter_no_change"
                ],
                "_unpack": [
                    "self",
                    "packed_parameters"
                ],
                "_forward_pass": [
                    "self",
                    "activations"
                ],
                "_compute_loss_grad": [
                    "self",
                    "layer",
                    "n_samples",
                    "activations",
                    "deltas",
                    "coef_grads",
                    "intercept_grads"
                ],
                "_loss_grad_lbfgs": [
                    "self",
                    "packed_coef_inter",
                    "X",
                    "y",
                    "activations",
                    "deltas",
                    "coef_grads",
                    "intercept_grads"
                ],
                "_backprop": [
                    "self",
                    "X",
                    "y",
                    "activations",
                    "deltas",
                    "coef_grads",
                    "intercept_grads"
                ],
                "_initialize": [
                    "self",
                    "y",
                    "layer_units"
                ],
                "_init_coef": [
                    "self",
                    "fan_in",
                    "fan_out"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "incremental"
                ],
                "_validate_hyperparameters": [
                    "self"
                ],
                "_fit_lbfgs": [
                    "self",
                    "X",
                    "y",
                    "activations",
                    "deltas",
                    "coef_grads",
                    "intercept_grads",
                    "layer_units"
                ],
                "_fit_stochastic": [
                    "self",
                    "X",
                    "y",
                    "activations",
                    "deltas",
                    "coef_grads",
                    "intercept_grads",
                    "layer_units",
                    "incremental"
                ],
                "_update_no_improvement_count": [
                    "self",
                    "early_stopping",
                    "X_val",
                    "y_val"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_predict": [
                    "self",
                    "X"
                ]
            },
            "MLPClassifier": {
                "__init__": [
                    "self",
                    "hidden_layer_sizes",
                    "activation",
                    "solver",
                    "alpha",
                    "batch_size",
                    "learning_rate",
                    "learning_rate_init",
                    "power_t",
                    "max_iter",
                    "shuffle",
                    "random_state",
                    "tol",
                    "verbose",
                    "warm_start",
                    "momentum",
                    "nesterovs_momentum",
                    "early_stopping",
                    "validation_fraction",
                    "beta_1",
                    "beta_2",
                    "epsilon",
                    "n_iter_no_change"
                ],
                "_validate_input": [
                    "self",
                    "X",
                    "y",
                    "incremental"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "MLPRegressor": {
                "__init__": [
                    "self",
                    "hidden_layer_sizes",
                    "activation",
                    "solver",
                    "alpha",
                    "batch_size",
                    "learning_rate",
                    "learning_rate_init",
                    "power_t",
                    "max_iter",
                    "shuffle",
                    "random_state",
                    "tol",
                    "verbose",
                    "warm_start",
                    "momentum",
                    "nesterovs_momentum",
                    "early_stopping",
                    "validation_fraction",
                    "beta_1",
                    "beta_2",
                    "epsilon",
                    "n_iter_no_change"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_validate_input": [
                    "self",
                    "X",
                    "y",
                    "incremental"
                ]
            }
        },
        "sklearn.neural_network.tests.test_stochastic_optimizers": {
            "test_base_optimizer": [],
            "test_sgd_optimizer_no_momentum": [],
            "test_sgd_optimizer_momentum": [],
            "test_sgd_optimizer_trigger_stopping": [],
            "test_sgd_optimizer_nesterovs_momentum": [],
            "test_adam_optimizer": []
        },
        "sklearn.neural_network.tests": {},
        "sklearn.neural_network.tests.test_rbm": {
            "test_fit": [],
            "test_partial_fit": [],
            "test_transform": [],
            "test_small_sparse": [],
            "test_small_sparse_partial_fit": [],
            "test_sample_hiddens": [],
            "test_fit_gibbs": [],
            "test_fit_gibbs_sparse": [],
            "test_gibbs_smoke": [],
            "test_score_samples": [],
            "test_rbm_verbose": [],
            "test_sparse_and_verbose": []
        },
        "sklearn.neural_network.tests.test_mlp": {
            "test_alpha": [],
            "test_fit": [],
            "test_gradient": [],
            "test_lbfgs_classification": [],
            "test_lbfgs_regression": [],
            "test_learning_rate_warmstart": [],
            "test_multilabel_classification": [],
            "test_multioutput_regression": [],
            "test_partial_fit_classes_error": [],
            "test_partial_fit_classification": [],
            "test_partial_fit_unseen_classes": [],
            "test_partial_fit_regression": [],
            "test_partial_fit_errors": [],
            "test_params_errors": [],
            "test_predict_proba_binary": [],
            "test_predict_proba_multiclass": [],
            "test_predict_proba_multilabel": [],
            "test_shuffle": [],
            "test_sparse_matrices": [],
            "test_tolerance": [],
            "test_verbose_sgd": [],
            "test_early_stopping": [],
            "test_adaptive_learning_rate": [],
            "test_warm_start": [],
            "test_n_iter_no_change": [],
            "test_n_iter_no_change_inf": [],
            "test_early_stopping_stratified": []
        },
        "sklearn.neighbors.classification": {
            "KNeighborsClassifier": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric",
                    "metric_params",
                    "n_jobs"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "RadiusNeighborsClassifier": {
                "__init__": [
                    "self",
                    "radius",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric",
                    "outlier_label",
                    "metric_params",
                    "n_jobs"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.neighbors.graph": {
            "_check_params": [
                "X",
                "metric",
                "p",
                "metric_params"
            ],
            "_query_include_self": [
                "X",
                "include_self"
            ],
            "kneighbors_graph": [
                "X",
                "n_neighbors",
                "mode",
                "metric",
                "p",
                "metric_params",
                "include_self",
                "n_jobs"
            ],
            "radius_neighbors_graph": [
                "X",
                "radius",
                "mode",
                "metric",
                "p",
                "metric_params",
                "include_self",
                "n_jobs"
            ]
        },
        "sklearn.neighbors.kde": {
            "KernelDensity": {
                "__init__": [
                    "self",
                    "bandwidth",
                    "algorithm",
                    "kernel",
                    "metric",
                    "atol",
                    "rtol",
                    "breadth_first",
                    "leaf_size",
                    "metric_params"
                ],
                "_choose_algorithm": [
                    "self",
                    "algorithm",
                    "metric"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "sample": [
                    "self",
                    "n_samples",
                    "random_state"
                ]
            }
        },
        "sklearn.neighbors.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.neighbors.nca": {
            "NeighborhoodComponentsAnalysis": {
                "__init__": [
                    "self",
                    "n_components",
                    "init",
                    "warm_start",
                    "max_iter",
                    "tol",
                    "callback",
                    "verbose",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_validate_params": [
                    "self",
                    "X",
                    "y"
                ],
                "_initialize": [
                    "self",
                    "X",
                    "y",
                    "init"
                ],
                "_callback": [
                    "self",
                    "transformation"
                ],
                "_loss_grad_lbfgs": [
                    "self",
                    "transformation",
                    "X",
                    "same_class_mask",
                    "sign"
                ]
            }
        },
        "sklearn.neighbors": {},
        "sklearn.neighbors.regression": {
            "KNeighborsRegressor": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric",
                    "metric_params",
                    "n_jobs"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "RadiusNeighborsRegressor": {
                "__init__": [
                    "self",
                    "radius",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric",
                    "metric_params",
                    "n_jobs"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.neighbors.unsupervised": {
            "NearestNeighbors": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "radius",
                    "algorithm",
                    "leaf_size",
                    "metric",
                    "p",
                    "metric_params",
                    "n_jobs"
                ]
            }
        },
        "sklearn.neighbors.nearest_centroid": {
            "NearestCentroid": {
                "__init__": [
                    "self",
                    "metric",
                    "shrink_threshold"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.neighbors.base": {
            "_check_weights": [
                "weights"
            ],
            "_get_weights": [
                "dist",
                "weights"
            ],
            "_tree_query_parallel_helper": [
                "tree",
                "data",
                "n_neighbors",
                "return_distance"
            ],
            "_tree_query_radius_parallel_helper": [
                "tree",
                "data",
                "radius",
                "return_distance"
            ],
            "NeighborsBase": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "radius",
                    "algorithm",
                    "leaf_size",
                    "metric",
                    "p",
                    "metric_params",
                    "n_jobs"
                ],
                "_check_algorithm_metric": [
                    "self"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "_pairwise": [
                    "self"
                ]
            },
            "KNeighborsMixin": {
                "_kneighbors_reduce_func": [
                    "self",
                    "dist",
                    "start",
                    "n_neighbors",
                    "return_distance"
                ],
                "kneighbors": [
                    "self",
                    "X",
                    "n_neighbors",
                    "return_distance"
                ],
                "kneighbors_graph": [
                    "self",
                    "X",
                    "n_neighbors",
                    "mode"
                ]
            },
            "RadiusNeighborsMixin": {
                "_radius_neighbors_reduce_func": [
                    "self",
                    "dist",
                    "start",
                    "radius",
                    "return_distance"
                ],
                "radius_neighbors": [
                    "self",
                    "X",
                    "radius",
                    "return_distance"
                ],
                "radius_neighbors_graph": [
                    "self",
                    "X",
                    "radius",
                    "mode"
                ]
            },
            "SupervisedFloatMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SupervisedIntegerMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "UnsupervisedMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.neighbors.lof": {
            "LocalOutlierFactor": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "algorithm",
                    "leaf_size",
                    "metric",
                    "p",
                    "metric_params",
                    "contamination",
                    "novelty",
                    "n_jobs"
                ],
                "fit_predict": [
                    "self"
                ],
                "_fit_predict": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self"
                ],
                "_predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self"
                ],
                "_score_samples": [
                    "self",
                    "X"
                ],
                "_local_reachability_density": [
                    "self",
                    "distances_X",
                    "neighbors_indices"
                ]
            }
        },
        "sklearn.neighbors.tests.test_nca": {
            "test_simple_example": [],
            "test_toy_example_collapse_points": [],
            "test_finite_differences": [],
            "test_params_validation": [],
            "test_transformation_dimensions": [],
            "test_n_components": [],
            "test_init_transformation": [],
            "test_auto_init": [
                "n_samples",
                "n_features",
                "n_classes",
                "n_components"
            ],
            "test_warm_start_validation": [],
            "test_warm_start_effectiveness": [],
            "test_verbose": [
                "init_name",
                "capsys"
            ],
            "test_no_verbose": [
                "capsys"
            ],
            "test_singleton_class": [],
            "test_one_class": [],
            "test_callback": [
                "capsys"
            ],
            "test_expected_transformation_shape": [],
            "test_convergence_warning": []
        },
        "sklearn.neighbors.tests.test_nearest_centroid": {
            "test_classification_toy": [],
            "test_precomputed": [],
            "test_iris": [],
            "test_iris_shrinkage": [],
            "test_pickle": [],
            "test_shrinkage_correct": [],
            "test_shrinkage_threshold_decoded_y": [],
            "test_predict_translated_data": [],
            "test_manhattan_metric": []
        },
        "sklearn.neighbors.tests.test_kde": {
            "compute_kernel_slow": [
                "Y",
                "X",
                "kernel",
                "h"
            ],
            "check_results": [
                "kernel",
                "bandwidth",
                "atol",
                "rtol",
                "X",
                "Y",
                "dens_true"
            ],
            "test_kernel_density": [
                "kernel",
                "bandwidth"
            ],
            "test_kernel_density_sampling": [
                "n_samples",
                "n_features"
            ],
            "test_kde_algorithm_metric_choice": [
                "algorithm",
                "metric"
            ],
            "test_kde_score": [
                "n_samples",
                "n_features"
            ],
            "test_kde_badargs": [],
            "test_kde_pipeline_gridsearch": [],
            "test_kde_sample_weights": [],
            "test_pickling": [
                "tmpdir"
            ]
        },
        "sklearn.neighbors.tests.test_quad_tree": {
            "test_quadtree_boundary_computation": [],
            "test_quadtree_similar_point": [],
            "test_quad_tree_pickle": [
                "n_dimensions",
                "protocol"
            ],
            "test_qt_insert_duplicate": [
                "n_dimensions"
            ],
            "test_summarize": []
        },
        "sklearn.neighbors.tests": {},
        "sklearn.neighbors.tests.test_ball_tree": {
            "dist_func": [
                "x1",
                "x2",
                "p"
            ],
            "brute_force_neighbors": [
                "X",
                "Y",
                "k",
                "metric"
            ],
            "test_ball_tree_query": [
                "metric",
                "k",
                "dualtree",
                "breadth_first"
            ],
            "test_ball_tree_query_metrics": [
                "metric"
            ],
            "test_ball_tree_query_radius": [
                "n_samples",
                "n_features"
            ],
            "test_ball_tree_query_radius_distance": [
                "n_samples",
                "n_features"
            ],
            "compute_kernel_slow": [
                "Y",
                "X",
                "kernel",
                "h"
            ],
            "test_ball_tree_kde": [
                "kernel",
                "h",
                "rtol",
                "atol",
                "breadth_first",
                "n_samples",
                "n_features"
            ],
            "test_gaussian_kde": [
                "n_samples"
            ],
            "test_ball_tree_two_point": [
                "n_samples",
                "n_features"
            ],
            "test_ball_tree_pickle": [],
            "test_neighbors_heap": [
                "n_pts",
                "n_nbrs"
            ],
            "test_node_heap": [
                "n_nodes"
            ],
            "test_simultaneous_sort": [
                "n_rows",
                "n_pts"
            ],
            "test_query_haversine": []
        },
        "sklearn.neighbors.tests.test_lof": {
            "test_lof": [],
            "test_lof_performance": [],
            "test_lof_values": [],
            "test_lof_precomputed": [
                "random_state"
            ],
            "test_n_neighbors_attribute": [],
            "test_score_samples": [],
            "test_contamination": [],
            "test_novelty_errors": [],
            "test_novelty_training_scores": [],
            "test_hasattr_prediction": [],
            "test_novelty_true_common_tests": [],
            "test_contamination_future_warning": [],
            "test_predicted_outlier_number": []
        },
        "sklearn.neighbors.tests.test_dist_metrics": {
            "dist_func": [
                "x1",
                "x2",
                "p"
            ],
            "test_cdist": [
                "metric"
            ],
            "test_cdist_bool_metric": [
                "metric"
            ],
            "check_cdist": [
                "metric",
                "kwargs",
                "D_true"
            ],
            "check_cdist_bool": [
                "metric",
                "D_true"
            ],
            "test_pdist": [
                "metric"
            ],
            "test_pdist_bool_metrics": [
                "metric"
            ],
            "check_pdist": [
                "metric",
                "kwargs",
                "D_true"
            ],
            "check_pdist_bool": [
                "metric",
                "D_true"
            ],
            "test_pickle": [
                "metric"
            ],
            "test_pickle_bool_metrics": [
                "metric"
            ],
            "check_pickle": [
                "metric",
                "kwargs"
            ],
            "test_haversine_metric": [],
            "test_pyfunc_metric": [],
            "test_bad_pyfunc_metric": [],
            "test_input_data_size": []
        },
        "sklearn.neighbors.tests.test_neighbors": {
            "_weight_func": [
                "dist"
            ],
            "test_unsupervised_kneighbors": [
                "n_samples",
                "n_features",
                "n_query_pts",
                "n_neighbors"
            ],
            "test_unsupervised_inputs": [],
            "test_n_neighbors_datatype": [],
            "test_not_fitted_error_gets_raised": [],
            "test_precomputed": [
                "random_state"
            ],
            "test_precomputed_cross_validation": [],
            "test_unsupervised_radius_neighbors": [
                "n_samples",
                "n_features",
                "n_query_pts",
                "radius",
                "random_state"
            ],
            "test_kneighbors_classifier": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_kneighbors_classifier_float_labels": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_kneighbors_classifier_predict_proba": [],
            "test_radius_neighbors_classifier": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "radius",
                "random_state"
            ],
            "test_radius_neighbors_classifier_when_no_neighbors": [],
            "test_radius_neighbors_classifier_outlier_labeling": [],
            "test_radius_neighbors_classifier_zero_distance": [],
            "test_neighbors_regressors_zero_distance": [],
            "test_radius_neighbors_boundary_handling": [],
            "test_RadiusNeighborsClassifier_multioutput": [],
            "test_kneighbors_classifier_sparse": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_KNeighborsClassifier_multioutput": [],
            "test_kneighbors_regressor": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_KNeighborsRegressor_multioutput_uniform_weight": [],
            "test_kneighbors_regressor_multioutput": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_radius_neighbors_regressor": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "radius",
                "random_state"
            ],
            "test_RadiusNeighborsRegressor_multioutput_with_uniform_weight": [],
            "test_RadiusNeighborsRegressor_multioutput": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_kneighbors_regressor_sparse": [
                "n_samples",
                "n_features",
                "n_test_pts",
                "n_neighbors",
                "random_state"
            ],
            "test_neighbors_iris": [],
            "test_neighbors_digits": [],
            "test_kneighbors_graph": [],
            "test_kneighbors_graph_sparse": [
                "seed"
            ],
            "test_radius_neighbors_graph": [],
            "test_radius_neighbors_graph_sparse": [
                "seed"
            ],
            "test_neighbors_badargs": [],
            "test_neighbors_metrics": [
                "n_samples",
                "n_features",
                "n_query_pts",
                "n_neighbors"
            ],
            "test_callable_metric": [],
            "test_valid_brute_metric_for_auto_algorithm": [],
            "test_metric_params_interface": [],
            "test_predict_sparse_ball_kd_tree": [],
            "test_non_euclidean_kneighbors": [],
            "check_object_arrays": [
                "nparray",
                "list_check"
            ],
            "test_k_and_radius_neighbors_train_is_not_query": [],
            "test_k_and_radius_neighbors_X_None": [],
            "test_k_and_radius_neighbors_duplicates": [],
            "test_include_self_neighbors_graph": [],
            "test_same_knn_parallel": [
                "algorithm"
            ],
            "test_same_radius_neighbors_parallel": [
                "algorithm"
            ],
            "test_knn_forcing_backend": [
                "backend",
                "algorithm"
            ],
            "test_dtype_convert": [],
            "test_sparse_metric_callable": [],
            "test_pairwise_boolean_distance": []
        },
        "sklearn.neighbors.tests.test_kd_tree": {
            "brute_force_neighbors": [
                "X",
                "Y",
                "k",
                "metric"
            ],
            "check_neighbors": [
                "dualtree",
                "breadth_first",
                "k",
                "metric",
                "X",
                "Y",
                "kwargs"
            ],
            "test_kd_tree_query": [
                "metric",
                "k",
                "dualtree",
                "breadth_first"
            ],
            "test_kd_tree_query_radius": [
                "n_samples",
                "n_features"
            ],
            "test_kd_tree_query_radius_distance": [
                "n_samples",
                "n_features"
            ],
            "compute_kernel_slow": [
                "Y",
                "X",
                "kernel",
                "h"
            ],
            "check_results": [
                "kernel",
                "h",
                "atol",
                "rtol",
                "breadth_first",
                "Y",
                "kdt",
                "dens_true"
            ],
            "test_kd_tree_kde": [
                "kernel",
                "h"
            ],
            "test_gaussian_kde": [
                "n_samples"
            ],
            "test_kd_tree_two_point": [
                "dualtree"
            ],
            "test_kd_tree_pickle": [
                "protocol"
            ],
            "test_neighbors_heap": [
                "n_pts",
                "n_nbrs"
            ],
            "test_node_heap": [
                "n_nodes"
            ],
            "test_simultaneous_sort": [
                "n_rows",
                "n_pts"
            ]
        },
        "sklearn.compose": {},
        "sklearn.compose._column_transformer": {
            "_check_X": [
                "X"
            ],
            "_check_key_type": [
                "key",
                "superclass"
            ],
            "_get_column": [
                "X",
                "key"
            ],
            "_get_column_indices": [
                "X",
                "key"
            ],
            "_is_empty_column_selection": [
                "column"
            ],
            "_validate_transformers": [
                "transformers"
            ],
            "_is_deprecated_tuple_order": [
                "tuples"
            ],
            "_get_transformer_list": [
                "estimators"
            ],
            "make_column_transformer": [],
            "ColumnTransformer": {
                "__init__": [
                    "self",
                    "transformers",
                    "remainder",
                    "sparse_threshold",
                    "n_jobs",
                    "transformer_weights",
                    "verbose"
                ],
                "_transformers": [
                    "self",
                    "value"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ],
                "_iter": [
                    "self",
                    "fitted",
                    "replace_strings"
                ],
                "_validate_transformers": [
                    "self"
                ],
                "_validate_column_callables": [
                    "self",
                    "X"
                ],
                "_validate_remainder": [
                    "self",
                    "X"
                ],
                "named_transformers_": [
                    "self"
                ],
                "get_feature_names": [
                    "self"
                ],
                "_update_fitted_transformers": [
                    "self",
                    "transformers"
                ],
                "_validate_output": [
                    "self",
                    "result"
                ],
                "_log_message": [
                    "self",
                    "name",
                    "idx",
                    "total"
                ],
                "_fit_transform": [
                    "self",
                    "X",
                    "y",
                    "func",
                    "fitted"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_hstack": [
                    "self",
                    "Xs"
                ]
            }
        },
        "sklearn.compose._target": {
            "TransformedTargetRegressor": {
                "__init__": [
                    "self",
                    "regressor",
                    "transformer",
                    "func",
                    "inverse_func",
                    "check_inverse"
                ],
                "_fit_transformer": [
                    "self",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.compose.tests.test_target": {
            "test_transform_target_regressor_error": [],
            "test_transform_target_regressor_invertible": [],
            "_check_standard_scaled": [
                "y",
                "y_pred"
            ],
            "_check_shifted_by_one": [
                "y",
                "y_pred"
            ],
            "test_transform_target_regressor_functions": [],
            "test_transform_target_regressor_functions_multioutput": [],
            "test_transform_target_regressor_1d_transformer": [
                "X",
                "y"
            ],
            "test_transform_target_regressor_2d_transformer": [
                "X",
                "y"
            ],
            "test_transform_target_regressor_2d_transformer_multioutput": [],
            "test_transform_target_regressor_multi_to_single": [],
            "test_transform_target_regressor_ensure_y_array": [],
            "test_transform_target_regressor_count_fit": [
                "check_inverse"
            ],
            "DummyCheckerArrayTransformer": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            },
            "DummyCheckerListRegressor": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "DummyTransformer": {
                "__init__": [
                    "self",
                    "fit_counter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.compose.tests.test_column_transformer": {
            "test_column_transformer": [],
            "test_column_transformer_dataframe": [],
            "test_column_transformer_empty_columns": [
                "pandas",
                "column"
            ],
            "test_column_transformer_sparse_array": [],
            "test_column_transformer_list": [],
            "test_column_transformer_sparse_stacking": [],
            "test_column_transformer_mixed_cols_sparse": [],
            "test_column_transformer_sparse_threshold": [],
            "test_column_transformer_error_msg_1D": [],
            "test_2D_transformer_output": [],
            "test_2D_transformer_output_pandas": [],
            "test_column_transformer_invalid_columns": [
                "remainder"
            ],
            "test_column_transformer_invalid_transformer": [],
            "test_make_column_transformer": [],
            "test_make_column_transformer_pandas": [],
            "test_make_column_transformer_kwargs": [],
            "test_make_column_transformer_remainder_transformer": [],
            "test_column_transformer_get_set_params": [],
            "test_column_transformer_named_estimators": [],
            "test_column_transformer_cloning": [],
            "test_column_transformer_get_feature_names": [],
            "test_column_transformer_special_strings": [],
            "test_column_transformer_remainder": [],
            "test_column_transformer_remainder_numpy": [
                "key"
            ],
            "test_column_transformer_remainder_pandas": [
                "key"
            ],
            "test_column_transformer_remainder_transformer": [
                "key"
            ],
            "test_column_transformer_no_remaining_remainder_transformer": [],
            "test_column_transformer_drops_all_remainder_transformer": [],
            "test_column_transformer_sparse_remainder_transformer": [],
            "test_column_transformer_drop_all_sparse_remainder_transformer": [],
            "test_column_transformer_get_set_params_with_remainder": [],
            "test_column_transformer_no_estimators": [],
            "test_column_transformer_verbose": [
                "est",
                "pattern",
                "method",
                "capsys"
            ],
            "test_column_transformer_no_estimators_set_params": [],
            "test_column_transformer_callable_specifier": [],
            "test_column_transformer_negative_column_indexes": [],
            "Trans": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "DoubleTrans": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "SparseMatrixTrans": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "TransNo2D": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "TransRaise": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.compose.tests": {},
        "sklearn.datasets.california_housing": {
            "fetch_california_housing": [
                "data_home",
                "download_if_missing",
                "return_X_y"
            ]
        },
        "sklearn.datasets.lfw": {
            "scale_face": [
                "face"
            ],
            "_check_fetch_lfw": [
                "data_home",
                "funneled",
                "download_if_missing"
            ],
            "_load_imgs": [
                "file_paths",
                "slice_",
                "color",
                "resize"
            ],
            "_fetch_lfw_people": [
                "data_folder_path",
                "slice_",
                "color",
                "resize",
                "min_faces_per_person"
            ],
            "fetch_lfw_people": [
                "data_home",
                "funneled",
                "resize",
                "min_faces_per_person",
                "color",
                "slice_",
                "download_if_missing",
                "return_X_y"
            ],
            "_fetch_lfw_pairs": [
                "index_file_path",
                "data_folder_path",
                "slice_",
                "color",
                "resize"
            ],
            "fetch_lfw_pairs": [
                "subset",
                "data_home",
                "funneled",
                "resize",
                "color",
                "slice_",
                "download_if_missing"
            ]
        },
        "sklearn.datasets.covtype": {
            "fetch_covtype": [
                "data_home",
                "download_if_missing",
                "random_state",
                "shuffle",
                "return_X_y"
            ]
        },
        "sklearn.datasets.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.datasets.twenty_newsgroups": {
            "download_20newsgroups": [
                "target_dir",
                "cache_path"
            ],
            "_download_20newsgroups": [
                "target_dir",
                "cache_path"
            ],
            "strip_newsgroup_header": [
                "text"
            ],
            "strip_newsgroup_quoting": [
                "text"
            ],
            "strip_newsgroup_footer": [
                "text"
            ],
            "fetch_20newsgroups": [
                "data_home",
                "subset",
                "categories",
                "shuffle",
                "random_state",
                "remove",
                "download_if_missing"
            ],
            "fetch_20newsgroups_vectorized": [
                "subset",
                "remove",
                "data_home",
                "download_if_missing",
                "return_X_y"
            ]
        },
        "sklearn.datasets.samples_generator": {
            "_generate_hypercube": [
                "samples",
                "dimensions",
                "rng"
            ],
            "make_classification": [
                "n_samples",
                "n_features",
                "n_informative",
                "n_redundant",
                "n_repeated",
                "n_classes",
                "n_clusters_per_class",
                "weights",
                "flip_y",
                "class_sep",
                "hypercube",
                "shift",
                "scale",
                "shuffle",
                "random_state"
            ],
            "make_multilabel_classification": [
                "n_samples",
                "n_features",
                "n_classes",
                "n_labels",
                "length",
                "allow_unlabeled",
                "sparse",
                "return_indicator",
                "return_distributions",
                "random_state"
            ],
            "make_hastie_10_2": [
                "n_samples",
                "random_state"
            ],
            "make_regression": [
                "n_samples",
                "n_features",
                "n_informative",
                "n_targets",
                "bias",
                "effective_rank",
                "tail_strength",
                "noise",
                "shuffle",
                "coef",
                "random_state"
            ],
            "make_circles": [
                "n_samples",
                "shuffle",
                "noise",
                "random_state",
                "factor"
            ],
            "make_moons": [
                "n_samples",
                "shuffle",
                "noise",
                "random_state"
            ],
            "make_blobs": [
                "n_samples",
                "n_features",
                "centers",
                "cluster_std",
                "center_box",
                "shuffle",
                "random_state"
            ],
            "make_friedman1": [
                "n_samples",
                "n_features",
                "noise",
                "random_state"
            ],
            "make_friedman2": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_friedman3": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_low_rank_matrix": [
                "n_samples",
                "n_features",
                "effective_rank",
                "tail_strength",
                "random_state"
            ],
            "make_sparse_coded_signal": [
                "n_samples",
                "n_components",
                "n_features",
                "n_nonzero_coefs",
                "random_state"
            ],
            "make_sparse_uncorrelated": [
                "n_samples",
                "n_features",
                "random_state"
            ],
            "make_spd_matrix": [
                "n_dim",
                "random_state"
            ],
            "make_sparse_spd_matrix": [
                "dim",
                "alpha",
                "norm_diag",
                "smallest_coef",
                "largest_coef",
                "random_state"
            ],
            "make_swiss_roll": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_s_curve": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_gaussian_quantiles": [
                "mean",
                "cov",
                "n_samples",
                "n_features",
                "n_classes",
                "shuffle",
                "random_state"
            ],
            "_shuffle": [
                "data",
                "random_state"
            ],
            "make_biclusters": [
                "shape",
                "n_clusters",
                "noise",
                "minval",
                "maxval",
                "shuffle",
                "random_state"
            ],
            "make_checkerboard": [
                "shape",
                "n_clusters",
                "noise",
                "minval",
                "maxval",
                "shuffle",
                "random_state"
            ]
        },
        "sklearn.datasets": {},
        "sklearn.datasets.mldata": {
            "mldata_filename": [
                "dataname"
            ],
            "fetch_mldata": [
                "dataname",
                "target_name",
                "data_name",
                "transpose_data",
                "data_home"
            ],
            "setup_module": [
                "module"
            ],
            "teardown_module": [
                "module"
            ]
        },
        "sklearn.datasets.kddcup99": {
            "fetch_kddcup99": [
                "subset",
                "data_home",
                "shuffle",
                "random_state",
                "percent10",
                "download_if_missing",
                "return_X_y"
            ],
            "_fetch_brute_kddcup99": [
                "data_home",
                "download_if_missing",
                "percent10"
            ],
            "_mkdirp": [
                "d"
            ]
        },
        "sklearn.datasets.olivetti_faces": {
            "fetch_olivetti_faces": [
                "data_home",
                "shuffle",
                "random_state",
                "download_if_missing"
            ]
        },
        "sklearn.datasets.base": {
            "get_data_home": [
                "data_home"
            ],
            "clear_data_home": [
                "data_home"
            ],
            "load_files": [
                "container_path",
                "description",
                "categories",
                "load_content",
                "shuffle",
                "encoding",
                "decode_error",
                "random_state"
            ],
            "load_data": [
                "module_path",
                "data_file_name"
            ],
            "load_wine": [
                "return_X_y"
            ],
            "load_iris": [
                "return_X_y"
            ],
            "load_breast_cancer": [
                "return_X_y"
            ],
            "load_digits": [
                "n_class",
                "return_X_y"
            ],
            "load_diabetes": [
                "return_X_y"
            ],
            "load_linnerud": [
                "return_X_y"
            ],
            "load_boston": [
                "return_X_y"
            ],
            "load_sample_images": [],
            "load_sample_image": [
                "image_name"
            ],
            "_pkl_filepath": [],
            "_sha256": [
                "path"
            ],
            "_fetch_remote": [
                "remote",
                "dirname"
            ]
        },
        "sklearn.datasets.openml": {
            "_get_local_path": [
                "openml_path",
                "data_home"
            ],
            "_retry_with_clean_cache": [
                "openml_path",
                "data_home"
            ],
            "_open_openml_url": [
                "openml_path",
                "data_home"
            ],
            "_get_json_content_from_openml_api": [
                "url",
                "error_message",
                "raise_if_error",
                "data_home"
            ],
            "_split_sparse_columns": [
                "arff_data",
                "include_columns"
            ],
            "_sparse_data_to_array": [
                "arff_data",
                "include_columns"
            ],
            "_convert_arff_data": [
                "arff_data",
                "col_slice_x",
                "col_slice_y",
                "shape"
            ],
            "_get_data_info_by_name": [
                "name",
                "version",
                "data_home"
            ],
            "_get_data_description_by_id": [
                "data_id",
                "data_home"
            ],
            "_get_data_features": [
                "data_id",
                "data_home"
            ],
            "_get_data_qualities": [
                "data_id",
                "data_home"
            ],
            "_get_data_shape": [
                "data_qualities"
            ],
            "_download_data_arff": [
                "file_id",
                "sparse",
                "data_home",
                "encode_nominal"
            ],
            "_verify_target_data_type": [
                "features_dict",
                "target_columns"
            ],
            "_valid_data_column_names": [
                "features_list",
                "target_columns"
            ],
            "fetch_openml": [
                "name",
                "version",
                "data_id",
                "data_home",
                "target_column",
                "cache",
                "return_X_y"
            ]
        },
        "sklearn.datasets.species_distributions": {
            "_load_coverage": [
                "F",
                "header_length",
                "dtype"
            ],
            "_load_csv": [
                "F"
            ],
            "construct_grids": [
                "batch"
            ],
            "fetch_species_distributions": [
                "data_home",
                "download_if_missing"
            ]
        },
        "sklearn.datasets.rcv1": {
            "fetch_rcv1": [
                "data_home",
                "subset",
                "download_if_missing",
                "random_state",
                "shuffle",
                "return_X_y"
            ],
            "_inverse_permutation": [
                "p"
            ],
            "_find_permutation": [
                "a",
                "b"
            ]
        },
        "sklearn.datasets.svmlight_format": {
            "load_svmlight_file": [
                "f",
                "n_features",
                "dtype",
                "multilabel",
                "zero_based",
                "query_id",
                "offset",
                "length"
            ],
            "_gen_open": [
                "f"
            ],
            "_open_and_load": [
                "f",
                "dtype",
                "multilabel",
                "zero_based",
                "query_id",
                "offset",
                "length"
            ],
            "load_svmlight_files": [
                "files",
                "n_features",
                "dtype",
                "multilabel",
                "zero_based",
                "query_id",
                "offset",
                "length"
            ],
            "_dump_svmlight": [
                "X",
                "y",
                "f",
                "multilabel",
                "one_based",
                "comment",
                "query_id"
            ],
            "dump_svmlight_file": [
                "X",
                "y",
                "f",
                "zero_based",
                "comment",
                "query_id",
                "multilabel"
            ]
        },
        "sklearn.datasets.tests.test_20news": {
            "test_20news": [],
            "test_20news_length_consistency": [],
            "test_20news_vectorized": []
        },
        "sklearn.datasets.tests.test_rcv1": {
            "test_fetch_rcv1": []
        },
        "sklearn.datasets.tests.test_base": {
            "_remove_dir": [
                "path"
            ],
            "data_home": [
                "tmpdir_factory"
            ],
            "load_files_root": [
                "tmpdir_factory"
            ],
            "test_category_dir_1": [
                "load_files_root"
            ],
            "test_category_dir_2": [
                "load_files_root"
            ],
            "test_data_home": [
                "data_home"
            ],
            "test_default_empty_load_files": [
                "load_files_root"
            ],
            "test_default_load_files": [
                "test_category_dir_1",
                "test_category_dir_2",
                "load_files_root"
            ],
            "test_load_files_w_categories_desc_and_encoding": [
                "test_category_dir_1",
                "test_category_dir_2",
                "load_files_root"
            ],
            "test_load_files_wo_load_content": [
                "test_category_dir_1",
                "test_category_dir_2",
                "load_files_root"
            ],
            "test_load_sample_images": [],
            "test_load_digits": [],
            "test_load_digits_n_class_lt_10": [],
            "test_load_sample_image": [],
            "test_load_missing_sample_image_error": [],
            "test_load_diabetes": [],
            "test_load_linnerud": [],
            "test_load_iris": [],
            "test_load_wine": [],
            "test_load_breast_cancer": [],
            "test_load_boston": [],
            "test_loads_dumps_bunch": [],
            "test_bunch_pickle_generated_with_0_16_and_read_with_0_17": [],
            "test_bunch_dir": []
        },
        "sklearn.datasets.tests": {},
        "sklearn.datasets.tests.test_lfw": {
            "setup_module": [],
            "teardown_module": [],
            "test_load_empty_lfw_people": [],
            "test_load_fake_lfw_people": [],
            "test_load_fake_lfw_people_too_restrictive": [],
            "test_load_empty_lfw_pairs": [],
            "test_load_fake_lfw_pairs": []
        },
        "sklearn.datasets.tests.test_mldata": {
            "tmpdata": [
                "tmpdir_factory"
            ],
            "test_mldata_filename": [],
            "test_download": [
                "tmpdata"
            ],
            "test_fetch_one_column": [
                "tmpdata"
            ],
            "test_fetch_multiple_column": [
                "tmpdata"
            ]
        },
        "sklearn.datasets.tests.test_openml": {
            "_test_features_list": [
                "data_id"
            ],
            "_fetch_dataset_from_openml": [
                "data_id",
                "data_name",
                "data_version",
                "target_column",
                "expected_observations",
                "expected_features",
                "expected_missing",
                "expected_data_dtype",
                "expected_target_dtype",
                "expect_sparse",
                "compare_default_target"
            ],
            "_monkey_patch_webbased_functions": [
                "context",
                "data_id",
                "gzip_response"
            ],
            "test_fetch_openml_iris": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_decode_iris": [
                "monkeypatch"
            ],
            "test_fetch_openml_iris_multitarget": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_anneal": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_decode_anneal": [
                "monkeypatch"
            ],
            "test_fetch_openml_anneal_multitarget": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_cpu": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_decode_cpu": [
                "monkeypatch"
            ],
            "test_fetch_openml_australian": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_adultcensus": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_miceprotein": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_emotions": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_decode_emotions": [
                "monkeypatch"
            ],
            "test_open_openml_url_cache": [
                "monkeypatch",
                "gzip_response",
                "tmpdir"
            ],
            "test_open_openml_url_unlinks_local_path": [
                "monkeypatch",
                "gzip_response",
                "tmpdir",
                "write_to_disk"
            ],
            "test_retry_with_clean_cache": [
                "tmpdir"
            ],
            "test_retry_with_clean_cache_http_error": [
                "tmpdir"
            ],
            "test_fetch_openml_cache": [
                "monkeypatch",
                "gzip_response",
                "tmpdir"
            ],
            "test_fetch_openml_notarget": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_inactive": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_nonexiting": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_raises_illegal_multitarget": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_warn_ignore_attribute": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_string_attribute": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_dataset_with_openml_error": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_dataset_with_openml_warning": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_illegal_column": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_raises_missing_values_target": [
                "monkeypatch",
                "gzip_response"
            ],
            "test_fetch_openml_raises_illegal_argument": []
        },
        "sklearn.datasets.tests.test_covtype": {
            "fetch": [],
            "test_fetch": []
        },
        "sklearn.datasets.tests.test_svmlight_format": {
            "test_load_svmlight_file": [],
            "test_load_svmlight_file_fd": [],
            "test_load_svmlight_file_multilabel": [],
            "test_load_svmlight_files": [],
            "test_load_svmlight_file_n_features": [],
            "test_load_compressed": [],
            "test_load_invalid_file": [],
            "test_load_invalid_order_file": [],
            "test_load_zero_based": [],
            "test_load_zero_based_auto": [],
            "test_load_with_qid": [],
            "test_load_large_qid": [],
            "test_load_invalid_file2": [],
            "test_not_a_filename": [],
            "test_invalid_filename": [],
            "test_dump": [],
            "test_dump_multilabel": [],
            "test_dump_concise": [],
            "test_dump_comment": [],
            "test_dump_invalid": [],
            "test_dump_query_id": [],
            "test_load_with_long_qid": [],
            "test_load_zeros": [],
            "test_load_with_offsets": [
                "sparsity",
                "n_samples",
                "n_features"
            ],
            "test_load_offset_exhaustive_splits": [],
            "test_load_with_offsets_error": []
        },
        "sklearn.datasets.tests.test_samples_generator": {
            "test_make_classification": [],
            "test_make_classification_informative_features": [],
            "test_make_multilabel_classification_return_sequences": [],
            "test_make_multilabel_classification_return_indicator": [],
            "test_make_multilabel_classification_return_indicator_sparse": [],
            "test_make_hastie_10_2": [],
            "test_make_regression": [],
            "test_make_regression_multitarget": [],
            "test_make_blobs": [],
            "test_make_blobs_n_samples_list": [],
            "test_make_blobs_n_samples_list_with_centers": [],
            "test_make_blobs_n_samples_centers_none": [
                "n_samples"
            ],
            "test_make_blobs_error": [],
            "test_make_friedman1": [],
            "test_make_friedman2": [],
            "test_make_friedman3": [],
            "test_make_low_rank_matrix": [],
            "test_make_sparse_coded_signal": [],
            "test_make_sparse_uncorrelated": [],
            "test_make_spd_matrix": [],
            "test_make_swiss_roll": [],
            "test_make_s_curve": [],
            "test_make_biclusters": [],
            "test_make_checkerboard": [],
            "test_make_moons": [],
            "test_make_circles": []
        },
        "sklearn.datasets.tests.test_kddcup99": {
            "test_percent10": [],
            "test_shuffle": []
        },
        "sklearn.datasets.tests.test_common": {
            "check_return_X_y": [
                "bunch",
                "fetch_func_partial"
            ]
        },
        "sklearn.datasets.tests.test_california_housing": {
            "fetch": [],
            "test_fetch": []
        },
        "sklearn.cross_decomposition": {},
        "sklearn.cross_decomposition.pls_": {
            "_nipals_twoblocks_inner_loop": [
                "X",
                "Y",
                "mode",
                "max_iter",
                "tol",
                "norm_y_weights"
            ],
            "_svd_cross_product": [
                "X",
                "Y"
            ],
            "_center_scale_xy": [
                "X",
                "Y",
                "scale"
            ],
            "_PLS": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "deflation_mode",
                    "mode",
                    "algorithm",
                    "norm_y_weights",
                    "max_iter",
                    "tol",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "transform": [
                    "self",
                    "X",
                    "Y",
                    "copy"
                ],
                "predict": [
                    "self",
                    "X",
                    "copy"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "PLSRegression": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "max_iter",
                    "tol",
                    "copy"
                ]
            },
            "PLSCanonical": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "algorithm",
                    "max_iter",
                    "tol",
                    "copy"
                ]
            },
            "PLSSVD": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "transform": [
                    "self",
                    "X",
                    "Y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.cross_decomposition.cca_": {
            "CCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "max_iter",
                    "tol",
                    "copy"
                ]
            }
        },
        "sklearn.cross_decomposition.tests.test_pls": {
            "test_pls": [],
            "test_convergence_fail": [],
            "test_PLSSVD": [],
            "test_univariate_pls_regression": [],
            "test_predict_transform_copy": [],
            "test_scale_and_stability": [],
            "test_pls_errors": [],
            "test_pls_scaling": []
        },
        "sklearn.cross_decomposition.tests": {},
        "sklearn.inspection": {},
        "sklearn.inspection.partial_dependence": {
            "_grid_from_X": [
                "X",
                "percentiles",
                "grid_resolution"
            ],
            "_partial_dependence_recursion": [
                "est",
                "grid",
                "features"
            ],
            "_partial_dependence_brute": [
                "est",
                "grid",
                "features",
                "X",
                "response_method"
            ],
            "partial_dependence": [
                "estimator",
                "X",
                "features",
                "response_method",
                "percentiles",
                "grid_resolution",
                "method"
            ],
            "plot_partial_dependence": [
                "estimator",
                "X",
                "features",
                "feature_names",
                "target",
                "response_method",
                "n_cols",
                "grid_resolution",
                "percentiles",
                "method",
                "n_jobs",
                "verbose",
                "fig",
                "line_kw",
                "contour_kw"
            ]
        },
        "sklearn.inspection.tests": {},
        "sklearn.inspection.tests.test_partial_dependence": {
            "test_output_shape": [
                "Estimator",
                "method",
                "data",
                "grid_resolution",
                "features"
            ],
            "test_grid_from_X": [],
            "test_grid_from_X_error": [
                "grid_resolution",
                "percentiles",
                "err_msg"
            ],
            "test_partial_dependence_helpers": [
                "est",
                "method",
                "target_feature"
            ],
            "test_recursion_decision_function": [
                "target_feature"
            ],
            "test_partial_dependence_easy_target": [
                "est",
                "power"
            ],
            "test_multiclass_multioutput": [
                "Estimator"
            ],
            "test_partial_dependence_error": [
                "estimator",
                "params",
                "err_msg"
            ],
            "test_partial_dependence_unknown_feature": [
                "estimator",
                "features"
            ],
            "test_partial_dependence_unfitted_estimator": [
                "estimator"
            ],
            "test_partial_dependence_X_list": [
                "estimator"
            ],
            "test_warning_recursion_non_constant_init": [],
            "test_partial_dependence_sample_weight": [],
            "test_plot_partial_dependence": [],
            "test_plot_partial_dependence_multiclass": [],
            "test_plot_partial_dependence_multioutput": [],
            "test_plot_partial_dependence_error": [
                "data",
                "params",
                "err_msg"
            ],
            "test_plot_partial_dependence_fig": [],
            "NoPredictProbaNoDecisionFunction": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.manifold.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.manifold.t_sne": {
            "_joint_probabilities": [
                "distances",
                "desired_perplexity",
                "verbose"
            ],
            "_joint_probabilities_nn": [
                "distances",
                "neighbors",
                "desired_perplexity",
                "verbose"
            ],
            "_kl_divergence": [
                "params",
                "P",
                "degrees_of_freedom",
                "n_samples",
                "n_components",
                "skip_num_points",
                "compute_error"
            ],
            "_kl_divergence_bh": [
                "params",
                "P",
                "degrees_of_freedom",
                "n_samples",
                "n_components",
                "angle",
                "skip_num_points",
                "verbose",
                "compute_error"
            ],
            "_gradient_descent": [
                "objective",
                "p0",
                "it",
                "n_iter",
                "n_iter_check",
                "n_iter_without_progress",
                "momentum",
                "learning_rate",
                "min_gain",
                "min_grad_norm",
                "verbose",
                "args",
                "kwargs"
            ],
            "trustworthiness": [
                "X",
                "X_embedded",
                "n_neighbors",
                "precomputed",
                "metric"
            ],
            "TSNE": {
                "__init__": [
                    "self",
                    "n_components",
                    "perplexity",
                    "early_exaggeration",
                    "learning_rate",
                    "n_iter",
                    "n_iter_without_progress",
                    "min_grad_norm",
                    "metric",
                    "init",
                    "verbose",
                    "random_state",
                    "method",
                    "angle"
                ],
                "_fit": [
                    "self",
                    "X",
                    "skip_num_points"
                ],
                "_tsne": [
                    "self",
                    "P",
                    "degrees_of_freedom",
                    "n_samples",
                    "X_embedded",
                    "neighbors",
                    "skip_num_points"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.manifold": {},
        "sklearn.manifold.isomap": {
            "Isomap": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "n_components",
                    "eigen_solver",
                    "tol",
                    "max_iter",
                    "path_method",
                    "neighbors_algorithm",
                    "n_jobs"
                ],
                "_fit_transform": [
                    "self",
                    "X"
                ],
                "reconstruction_error": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.manifold.mds": {
            "_smacof_single": [
                "dissimilarities",
                "metric",
                "n_components",
                "init",
                "max_iter",
                "verbose",
                "eps",
                "random_state"
            ],
            "smacof": [
                "dissimilarities",
                "metric",
                "n_components",
                "init",
                "n_init",
                "n_jobs",
                "max_iter",
                "verbose",
                "eps",
                "random_state",
                "return_n_iter"
            ],
            "MDS": {
                "__init__": [
                    "self",
                    "n_components",
                    "metric",
                    "n_init",
                    "max_iter",
                    "verbose",
                    "eps",
                    "n_jobs",
                    "random_state",
                    "dissimilarity"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "init"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y",
                    "init"
                ]
            }
        },
        "sklearn.manifold.locally_linear": {
            "barycenter_weights": [
                "X",
                "Z",
                "reg"
            ],
            "barycenter_kneighbors_graph": [
                "X",
                "n_neighbors",
                "reg",
                "n_jobs"
            ],
            "null_space": [
                "M",
                "k",
                "k_skip",
                "eigen_solver",
                "tol",
                "max_iter",
                "random_state"
            ],
            "locally_linear_embedding": [
                "X",
                "n_neighbors",
                "n_components",
                "reg",
                "eigen_solver",
                "tol",
                "max_iter",
                "method",
                "hessian_tol",
                "modified_tol",
                "random_state",
                "n_jobs"
            ],
            "LocallyLinearEmbedding": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "n_components",
                    "reg",
                    "eigen_solver",
                    "tol",
                    "max_iter",
                    "method",
                    "hessian_tol",
                    "modified_tol",
                    "neighbors_algorithm",
                    "random_state",
                    "n_jobs"
                ],
                "_fit_transform": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.manifold.spectral_embedding_": {
            "_graph_connected_component": [
                "graph",
                "node_id"
            ],
            "_graph_is_connected": [
                "graph"
            ],
            "_set_diag": [
                "laplacian",
                "value",
                "norm_laplacian"
            ],
            "spectral_embedding": [
                "adjacency",
                "n_components",
                "eigen_solver",
                "random_state",
                "eigen_tol",
                "norm_laplacian",
                "drop_first"
            ],
            "SpectralEmbedding": {
                "__init__": [
                    "self",
                    "n_components",
                    "affinity",
                    "gamma",
                    "random_state",
                    "eigen_solver",
                    "n_neighbors",
                    "n_jobs"
                ],
                "_pairwise": [
                    "self"
                ],
                "_get_affinity_matrix": [
                    "self",
                    "X",
                    "Y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.manifold.tests.test_mds": {
            "test_smacof": [],
            "test_smacof_error": [],
            "test_MDS": []
        },
        "sklearn.manifold.tests.test_spectral_embedding": {
            "_check_with_col_sign_flipping": [
                "A",
                "B",
                "tol"
            ],
            "test_sparse_graph_connected_component": [],
            "test_spectral_embedding_two_components": [
                "seed"
            ],
            "test_spectral_embedding_precomputed_affinity": [
                "seed"
            ],
            "test_spectral_embedding_callable_affinity": [
                "seed"
            ],
            "test_spectral_embedding_amg_solver": [
                "seed"
            ],
            "test_pipeline_spectral_clustering": [
                "seed"
            ],
            "test_spectral_embedding_unknown_eigensolver": [
                "seed"
            ],
            "test_spectral_embedding_unknown_affinity": [
                "seed"
            ],
            "test_connectivity": [
                "seed"
            ],
            "test_spectral_embedding_deterministic": [],
            "test_spectral_embedding_unnormalized": [],
            "test_spectral_embedding_first_eigen_vector": []
        },
        "sklearn.manifold.tests": {},
        "sklearn.manifold.tests.test_t_sne": {
            "test_gradient_descent_stops": [],
            "test_binary_search": [],
            "test_binary_search_neighbors": [],
            "test_binary_perplexity_stability": [],
            "test_gradient": [],
            "test_trustworthiness": [],
            "test_preserve_trustworthiness_approximately": [],
            "test_optimization_minimizes_kl_divergence": [],
            "test_fit_csr_matrix": [],
            "test_preserve_trustworthiness_approximately_with_precomputed_distances": [],
            "test_trustworthiness_precomputed_deprecation": [],
            "test_trustworthiness_not_euclidean_metric": [],
            "test_early_exaggeration_too_small": [],
            "test_too_few_iterations": [],
            "test_non_square_precomputed_distances": [],
            "test_non_positive_precomputed_distances": [],
            "test_non_positive_computed_distances": [],
            "test_init_not_available": [],
            "test_init_ndarray": [],
            "test_init_ndarray_precomputed": [],
            "test_distance_not_available": [],
            "test_method_not_available": [],
            "test_angle_out_of_range_checks": [],
            "test_pca_initialization_not_compatible_with_precomputed_kernel": [],
            "test_n_components_range": [],
            "test_early_exaggeration_used": [],
            "test_n_iter_used": [],
            "test_answer_gradient_two_points": [],
            "test_answer_gradient_four_points": [],
            "test_skip_num_points_gradient": [],
            "_run_answer_test": [
                "pos_input",
                "pos_output",
                "neighbors",
                "grad_output",
                "verbose",
                "perplexity",
                "skip_num_points"
            ],
            "test_verbose": [],
            "test_chebyshev_metric": [],
            "test_reduction_to_one_component": [],
            "test_no_sparse_on_barnes_hut": [],
            "test_64bit": [
                "method",
                "dt"
            ],
            "test_kl_divergence_not_nan": [
                "method"
            ],
            "test_barnes_hut_angle": [],
            "test_n_iter_without_progress": [],
            "test_min_grad_norm": [],
            "test_accessible_kl_divergence": [],
            "check_uniform_grid": [
                "method",
                "seeds",
                "n_iter"
            ],
            "assert_uniform_grid": [
                "Y",
                "try_name"
            ],
            "test_uniform_grid": [
                "method"
            ],
            "test_bh_match_exact": [],
            "test_tsne_with_different_distance_metrics": []
        },
        "sklearn.manifold.tests.test_locally_linear": {
            "test_barycenter_kneighbors_graph": [],
            "test_lle_simple_grid": [],
            "test_lle_manifold": [],
            "test_lle_init_parameters": [],
            "test_pipeline": [],
            "test_singular_matrix": [],
            "test_integer_input": []
        },
        "sklearn.manifold.tests.test_isomap": {
            "test_isomap_simple_grid": [],
            "test_isomap_reconstruction_error": [],
            "test_transform": [],
            "test_pipeline": [],
            "test_isomap_clone_bug": [],
            "test_sparse_input": []
        },
        "sklearn.model_selection._search": {
            "fit_grid_point": [
                "X",
                "y",
                "estimator",
                "parameters",
                "train",
                "test",
                "scorer",
                "verbose",
                "error_score"
            ],
            "_check_param_grid": [
                "param_grid"
            ],
            "ParameterGrid": {
                "__init__": [
                    "self",
                    "param_grid"
                ],
                "__iter__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ],
                "__getitem__": [
                    "self",
                    "ind"
                ]
            },
            "ParameterSampler": {
                "__init__": [
                    "self",
                    "param_distributions",
                    "n_iter",
                    "random_state"
                ],
                "__iter__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "BaseSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "scoring",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch",
                    "error_score",
                    "return_train_score"
                ],
                "_estimator_type": [
                    "self"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_check_is_fitted": [
                    "self",
                    "method_name"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "Xt"
                ],
                "classes_": [
                    "self"
                ],
                "_run_search": [
                    "self",
                    "evaluate_candidates"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "_format_results": [
                    "self",
                    "candidate_params",
                    "scorers",
                    "n_splits",
                    "out"
                ]
            },
            "GridSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "param_grid",
                    "scoring",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch",
                    "error_score",
                    "return_train_score"
                ],
                "_run_search": [
                    "self",
                    "evaluate_candidates"
                ]
            },
            "RandomizedSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "param_distributions",
                    "n_iter",
                    "scoring",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch",
                    "random_state",
                    "error_score",
                    "return_train_score"
                ],
                "_run_search": [
                    "self",
                    "evaluate_candidates"
                ]
            }
        },
        "sklearn.model_selection._split": {
            "_validate_shuffle_split": [
                "n_samples",
                "test_size",
                "train_size",
                "default_test_size"
            ],
            "check_cv": [
                "cv",
                "y",
                "classifier"
            ],
            "train_test_split": [],
            "_build_repr": [
                "self"
            ],
            "BaseCrossValidator": {
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "_iter_test_masks": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "_iter_test_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "LeaveOneOut": {
                "_iter_test_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "LeavePOut": {
                "__init__": [
                    "self",
                    "p"
                ],
                "_iter_test_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "_BaseKFold": {
                "__init__": [
                    "self",
                    "n_splits",
                    "shuffle",
                    "random_state"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "KFold": {
                "__init__": [
                    "self",
                    "n_splits",
                    "shuffle",
                    "random_state"
                ],
                "_iter_test_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "GroupKFold": {
                "__init__": [
                    "self",
                    "n_splits"
                ],
                "_iter_test_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "StratifiedKFold": {
                "__init__": [
                    "self",
                    "n_splits",
                    "shuffle",
                    "random_state"
                ],
                "_make_test_folds": [
                    "self",
                    "X",
                    "y"
                ],
                "_iter_test_masks": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "TimeSeriesSplit": {
                "__init__": [
                    "self",
                    "n_splits",
                    "max_train_size"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "LeaveOneGroupOut": {
                "_iter_test_masks": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "LeavePGroupsOut": {
                "__init__": [
                    "self",
                    "n_groups"
                ],
                "_iter_test_masks": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "_RepeatedSplits": {
                "__init__": [
                    "self",
                    "cv",
                    "n_repeats",
                    "random_state"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "RepeatedKFold": {
                "__init__": [
                    "self",
                    "n_splits",
                    "n_repeats",
                    "random_state"
                ]
            },
            "RepeatedStratifiedKFold": {
                "__init__": [
                    "self",
                    "n_splits",
                    "n_repeats",
                    "random_state"
                ]
            },
            "BaseShuffleSplit": {
                "__init__": [
                    "self",
                    "n_splits",
                    "test_size",
                    "train_size",
                    "random_state"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "_iter_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "ShuffleSplit": {
                "__init__": [
                    "self",
                    "n_splits",
                    "test_size",
                    "train_size",
                    "random_state"
                ],
                "_iter_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "GroupShuffleSplit": {
                "__init__": [
                    "self",
                    "n_splits",
                    "test_size",
                    "train_size",
                    "random_state"
                ],
                "_iter_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "StratifiedShuffleSplit": {
                "__init__": [
                    "self",
                    "n_splits",
                    "test_size",
                    "train_size",
                    "random_state"
                ],
                "_iter_indices": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "PredefinedSplit": {
                "__init__": [
                    "self",
                    "test_fold"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "_iter_test_masks": [
                    "self"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            },
            "_CVIterableWrapper": {
                "__init__": [
                    "self",
                    "cv"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            }
        },
        "sklearn.model_selection": {},
        "sklearn.model_selection._validation": {
            "cross_validate": [
                "estimator",
                "X",
                "y",
                "groups",
                "scoring",
                "cv",
                "n_jobs",
                "verbose",
                "fit_params",
                "pre_dispatch",
                "return_train_score",
                "return_estimator",
                "error_score"
            ],
            "cross_val_score": [
                "estimator",
                "X",
                "y",
                "groups",
                "scoring",
                "cv",
                "n_jobs",
                "verbose",
                "fit_params",
                "pre_dispatch",
                "error_score"
            ],
            "_fit_and_score": [
                "estimator",
                "X",
                "y",
                "scorer",
                "train",
                "test",
                "verbose",
                "parameters",
                "fit_params",
                "return_train_score",
                "return_parameters",
                "return_n_test_samples",
                "return_times",
                "return_estimator",
                "error_score"
            ],
            "_score": [
                "estimator",
                "X_test",
                "y_test",
                "scorer",
                "is_multimetric"
            ],
            "_multimetric_score": [
                "estimator",
                "X_test",
                "y_test",
                "scorers"
            ],
            "cross_val_predict": [
                "estimator",
                "X",
                "y",
                "groups",
                "cv",
                "n_jobs",
                "verbose",
                "fit_params",
                "pre_dispatch",
                "method"
            ],
            "_fit_and_predict": [
                "estimator",
                "X",
                "y",
                "train",
                "test",
                "verbose",
                "fit_params",
                "method"
            ],
            "_enforce_prediction_order": [
                "classes",
                "predictions",
                "n_classes",
                "method"
            ],
            "_check_is_permutation": [
                "indices",
                "n_samples"
            ],
            "_index_param_value": [
                "X",
                "v",
                "indices"
            ],
            "permutation_test_score": [
                "estimator",
                "X",
                "y",
                "groups",
                "cv",
                "n_permutations",
                "n_jobs",
                "random_state",
                "verbose",
                "scoring"
            ],
            "_permutation_test_score": [
                "estimator",
                "X",
                "y",
                "groups",
                "cv",
                "scorer"
            ],
            "_shuffle": [
                "y",
                "groups",
                "random_state"
            ],
            "learning_curve": [
                "estimator",
                "X",
                "y",
                "groups",
                "train_sizes",
                "cv",
                "scoring",
                "exploit_incremental_learning",
                "n_jobs",
                "pre_dispatch",
                "verbose",
                "shuffle",
                "random_state",
                "error_score"
            ],
            "_translate_train_sizes": [
                "train_sizes",
                "n_max_training_samples"
            ],
            "_incremental_fit_estimator": [
                "estimator",
                "X",
                "y",
                "classes",
                "train",
                "test",
                "train_sizes",
                "scorer",
                "verbose"
            ],
            "validation_curve": [
                "estimator",
                "X",
                "y",
                "param_name",
                "param_range",
                "groups",
                "cv",
                "scoring",
                "n_jobs",
                "pre_dispatch",
                "verbose",
                "error_score"
            ],
            "_aggregate_score_dicts": [
                "scores"
            ]
        },
        "sklearn.model_selection.tests.common": {
            "OneTimeSplitter": {
                "__init__": [
                    "self",
                    "n_splits",
                    "n_samples"
                ],
                "split": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ],
                "get_n_splits": [
                    "self",
                    "X",
                    "y",
                    "groups"
                ]
            }
        },
        "sklearn.model_selection.tests": {},
        "sklearn.model_selection.tests.test_split": {
            "test_cross_validator_with_default_params": [],
            "test_2d_y": [],
            "check_valid_split": [
                "train",
                "test",
                "n_samples"
            ],
            "check_cv_coverage": [
                "cv",
                "X",
                "y",
                "groups",
                "expected_n_splits"
            ],
            "test_kfold_valueerrors": [],
            "test_kfold_indices": [],
            "test_kfold_no_shuffle": [],
            "test_stratified_kfold_no_shuffle": [],
            "test_stratified_kfold_ratios": [],
            "test_kfold_balance": [],
            "test_stratifiedkfold_balance": [],
            "test_shuffle_kfold": [],
            "test_shuffle_kfold_stratifiedkfold_reproducibility": [],
            "test_shuffle_stratifiedkfold": [],
            "test_kfold_can_detect_dependent_samples_on_digits": [],
            "test_shuffle_split": [],
            "test_shuffle_split_default_test_size": [
                "split_class",
                "train_size",
                "exp_train",
                "exp_test"
            ],
            "test_group_shuffle_split_default_test_size": [
                "train_size",
                "exp_train",
                "exp_test"
            ],
            "test_stratified_shuffle_split_init": [],
            "test_stratified_shuffle_split_respects_test_size": [],
            "test_stratified_shuffle_split_iter": [],
            "test_stratified_shuffle_split_even": [],
            "test_stratified_shuffle_split_overlap_train_test_bug": [],
            "test_stratified_shuffle_split_multilabel": [],
            "test_stratified_shuffle_split_multilabel_many_labels": [],
            "test_predefinedsplit_with_kfold_split": [],
            "test_group_shuffle_split": [],
            "test_leave_one_p_group_out": [],
            "test_leave_group_out_changing_groups": [],
            "test_leave_one_p_group_out_error_on_fewer_number_of_groups": [],
            "test_repeated_cv_value_errors": [],
            "test_repeated_kfold_determinstic_split": [],
            "test_get_n_splits_for_repeated_kfold": [],
            "test_get_n_splits_for_repeated_stratified_kfold": [],
            "test_repeated_stratified_kfold_determinstic_split": [],
            "test_train_test_split_errors": [],
            "test_train_test_split_invalid_sizes1": [
                "train_size",
                "test_size"
            ],
            "test_train_test_split_invalid_sizes2": [
                "train_size",
                "test_size"
            ],
            "test_train_test_split_default_test_size": [
                "train_size",
                "exp_train",
                "exp_test"
            ],
            "test_train_test_split": [],
            "test_train_test_split_pandas": [],
            "test_train_test_split_sparse": [],
            "test_train_test_split_mock_pandas": [],
            "test_train_test_split_list_input": [],
            "test_shufflesplit_errors": [
                "test_size",
                "train_size"
            ],
            "test_shufflesplit_reproducible": [],
            "test_stratifiedshufflesplit_list_input": [],
            "test_train_test_split_allow_nans": [],
            "test_check_cv": [],
            "test_cv_iterable_wrapper": [],
            "test_group_kfold": [],
            "test_time_series_cv": [],
            "_check_time_series_max_train_size": [
                "splits",
                "check_splits",
                "max_train_size"
            ],
            "test_time_series_max_train_size": [],
            "test_nested_cv": [],
            "test_nsplit_default_warn": [],
            "test_check_cv_default_warn": [],
            "test_build_repr": [],
            "test_shuffle_split_empty_trainset": [
                "CVSplitter"
            ],
            "test_train_test_split_empty_trainset": [],
            "test_leave_one_out_empty_trainset": [],
            "test_leave_p_out_empty_trainset": [],
            "MockClassifier": {
                "__init__": [
                    "self",
                    "a",
                    "allow_nd"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y",
                    "sample_weight",
                    "class_prior",
                    "sparse_sample_weight",
                    "sparse_param",
                    "dummy_int",
                    "dummy_str",
                    "dummy_obj",
                    "callback"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ]
            }
        },
        "sklearn.model_selection.tests.test_validation": {
            "test_cross_val_score": [],
            "test_cross_validate_many_jobs": [],
            "test_cross_validate_invalid_scoring_param": [],
            "test_cross_validate": [],
            "check_cross_validate_single_metric": [
                "clf",
                "X",
                "y",
                "scores"
            ],
            "check_cross_validate_multi_metric": [
                "clf",
                "X",
                "y",
                "scores"
            ],
            "test_cross_val_score_predict_groups": [],
            "test_cross_val_score_pandas": [],
            "test_cross_val_score_mask": [],
            "test_cross_val_score_precomputed": [],
            "test_cross_val_score_fit_params": [],
            "test_cross_val_score_score_func": [],
            "test_cross_val_score_errors": [],
            "test_cross_val_score_with_score_func_classification": [],
            "test_cross_val_score_with_score_func_regression": [],
            "test_permutation_score": [],
            "test_permutation_test_score_allow_nans": [],
            "test_cross_val_score_allow_nans": [],
            "test_cross_val_score_multilabel": [],
            "test_cross_val_predict": [],
            "test_cross_val_predict_decision_function_shape": [],
            "test_cross_val_predict_predict_proba_shape": [],
            "test_cross_val_predict_predict_log_proba_shape": [],
            "test_cross_val_predict_input_types": [],
            "test_cross_val_predict_pandas": [],
            "test_cross_val_predict_unbalanced": [],
            "test_cross_val_score_sparse_fit_params": [],
            "test_learning_curve": [],
            "test_learning_curve_unsupervised": [],
            "test_learning_curve_verbose": [],
            "test_learning_curve_incremental_learning_not_possible": [],
            "test_learning_curve_incremental_learning": [],
            "test_learning_curve_incremental_learning_unsupervised": [],
            "test_learning_curve_batch_and_incremental_learning_are_equal": [],
            "test_learning_curve_n_sample_range_out_of_bounds": [],
            "test_learning_curve_remove_duplicate_sample_sizes": [],
            "test_learning_curve_with_boolean_indices": [],
            "test_learning_curve_with_shuffle": [],
            "test_validation_curve": [],
            "test_validation_curve_clone_estimator": [],
            "test_validation_curve_cv_splits_consistency": [],
            "test_check_is_permutation": [],
            "test_cross_val_predict_sparse_prediction": [],
            "check_cross_val_predict_binary": [
                "est",
                "X",
                "y",
                "method"
            ],
            "check_cross_val_predict_multiclass": [
                "est",
                "X",
                "y",
                "method"
            ],
            "check_cross_val_predict_multilabel": [
                "est",
                "X",
                "y",
                "method"
            ],
            "check_cross_val_predict_with_method_binary": [
                "est"
            ],
            "check_cross_val_predict_with_method_multiclass": [
                "est"
            ],
            "test_cross_val_predict_with_method": [],
            "test_cross_val_predict_method_checking": [],
            "test_gridsearchcv_cross_val_predict_with_method": [],
            "test_cross_val_predict_with_method_multilabel_ovr": [],
            "test_cross_val_predict_with_method_multilabel_rf": [],
            "test_cross_val_predict_with_method_rare_class": [],
            "test_cross_val_predict_with_method_multilabel_rf_rare_class": [],
            "get_expected_predictions": [
                "X",
                "y",
                "cv",
                "classes",
                "est",
                "method"
            ],
            "test_cross_val_predict_class_subset": [],
            "test_score_memmap": [],
            "test_permutation_test_score_pandas": [],
            "test_fit_and_score_failing": [],
            "test_fit_and_score_working": [],
            "three_params_scorer": [
                "i",
                "j",
                "k"
            ],
            "test_fit_and_score_verbosity": [
                "capsys",
                "return_train_score",
                "scorer",
                "expected"
            ],
            "test_score": [],
            "MockImprovingEstimator": {
                "__init__": [
                    "self",
                    "n_max_train_sizes"
                ],
                "fit": [
                    "self",
                    "X_subset",
                    "y_subset"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "_is_training_data": [
                    "self",
                    "X"
                ]
            },
            "MockIncrementalImprovingEstimator": {
                "__init__": [
                    "self",
                    "n_max_train_sizes"
                ],
                "_is_training_data": [
                    "self",
                    "X"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "MockEstimatorWithParameter": {
                "__init__": [
                    "self",
                    "param"
                ],
                "fit": [
                    "self",
                    "X_subset",
                    "y_subset"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_is_training_data": [
                    "self",
                    "X"
                ]
            },
            "MockEstimatorWithSingleFitCallAllowed": {
                "fit": [
                    "self",
                    "X_subset",
                    "y_subset"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "MockClassifier": {
                "__init__": [
                    "self",
                    "a",
                    "allow_nd"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y",
                    "sample_weight",
                    "class_prior",
                    "sparse_sample_weight",
                    "sparse_param",
                    "dummy_int",
                    "dummy_str",
                    "dummy_obj",
                    "callback"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ]
            },
            "RFWithDecisionFunction": {
                "decision_function": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.model_selection.tests.test_search": {
            "assert_grid_iter_equals_getitem": [
                "grid"
            ],
            "test_validate_parameter_grid_input": [
                "input",
                "error_type",
                "error_message"
            ],
            "test_parameter_grid": [],
            "test_grid_search": [],
            "check_hyperparameter_searcher_with_fit_params": [
                "klass"
            ],
            "test_grid_search_with_fit_params": [],
            "test_random_search_with_fit_params": [],
            "test_grid_search_no_score": [],
            "test_grid_search_score_method": [],
            "test_grid_search_groups": [],
            "test_classes__property": [],
            "test_trivial_cv_results_attr": [],
            "test_no_refit": [],
            "test_grid_search_error": [],
            "test_grid_search_one_grid_point": [],
            "test_grid_search_when_param_grid_includes_range": [],
            "test_grid_search_bad_param_grid": [],
            "test_grid_search_sparse": [],
            "test_grid_search_sparse_scoring": [],
            "test_grid_search_precomputed_kernel": [],
            "test_grid_search_precomputed_kernel_error_nonsquare": [],
            "test_refit": [],
            "test_refit_callable": [],
            "test_refit_callable_invalid_type": [],
            "test_refit_callable_out_bound": [
                "out_bound_value",
                "search_cv"
            ],
            "test_refit_callable_multi_metric": [],
            "test_gridsearch_nd": [],
            "test_X_as_list": [],
            "test_y_as_list": [],
            "test_pandas_input": [],
            "test_unsupervised_grid_search": [],
            "test_gridsearch_no_predict": [],
            "test_param_sampler": [],
            "check_cv_results_array_types": [
                "search",
                "param_keys",
                "score_keys"
            ],
            "check_cv_results_keys": [
                "cv_results",
                "param_keys",
                "score_keys",
                "n_cand"
            ],
            "test_grid_search_cv_results": [],
            "test_random_search_cv_results": [],
            "test_search_iid_param": [],
            "test_grid_search_cv_results_multimetric": [],
            "test_random_search_cv_results_multimetric": [],
            "compare_cv_results_multimetric_with_single": [
                "search_multi",
                "search_acc",
                "search_rec",
                "iid"
            ],
            "compare_refit_methods_when_refit_with_acc": [
                "search_multi",
                "search_acc",
                "refit"
            ],
            "test_search_cv_results_rank_tie_breaking": [],
            "test_search_cv_results_none_param": [],
            "test_search_cv_timing": [],
            "test_grid_search_correct_score_results": [],
            "test_fit_grid_point": [],
            "test_pickle": [],
            "test_grid_search_with_multioutput_data": [],
            "test_predict_proba_disabled": [],
            "test_grid_search_allows_nans": [],
            "test_grid_search_failing_classifier": [],
            "test_grid_search_failing_classifier_raise": [],
            "test_parameters_sampler_replacement": [],
            "test_stochastic_gradient_loss_param": [],
            "test_search_train_scores_set_to_false": [],
            "test_grid_search_cv_splits_consistency": [],
            "test_transform_inverse_transform_round_trip": [],
            "test_custom_run_search": [],
            "test__custom_fit_no_run_search": [],
            "test_deprecated_grid_search_iid": [],
            "test_empty_cv_iterator_error": [],
            "test_random_search_bad_cv": [],
            "MockClassifier": {
                "__init__": [
                    "self",
                    "foo_param"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ]
            },
            "LinearSVCNoScore": {
                "score": [
                    "self"
                ]
            },
            "BrokenClassifier": {
                "__init__": [
                    "self",
                    "parameter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "FailingClassifier": {
                "__init__": [
                    "self",
                    "parameter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ]
            }
        },
        "sklearn.cluster.optics_": {
            "_validate_size": [
                "size",
                "n_samples",
                "param_name"
            ],
            "_compute_core_distances_": [
                "X",
                "neighbors",
                "min_samples",
                "working_memory"
            ],
            "compute_optics_graph": [
                "X",
                "min_samples",
                "max_eps",
                "metric",
                "p",
                "metric_params",
                "algorithm",
                "leaf_size",
                "n_jobs"
            ],
            "_set_reach_dist": [
                "core_distances_",
                "reachability_",
                "predecessor_",
                "point_index",
                "processed",
                "X",
                "nbrs",
                "metric",
                "metric_params",
                "p",
                "max_eps"
            ],
            "cluster_optics_dbscan": [
                "reachability",
                "core_distances",
                "ordering",
                "eps"
            ],
            "cluster_optics_xi": [
                "reachability",
                "predecessor",
                "ordering",
                "min_samples",
                "min_cluster_size",
                "xi",
                "predecessor_correction"
            ],
            "_extend_region": [
                "steep_point",
                "xward_point",
                "start",
                "min_samples"
            ],
            "_update_filter_sdas": [
                "sdas",
                "mib",
                "xi_complement",
                "reachability_plot"
            ],
            "_correct_predecessor": [
                "reachability_plot",
                "predecessor_plot",
                "ordering",
                "s",
                "e"
            ],
            "_xi_cluster": [
                "reachability_plot",
                "predecessor_plot",
                "ordering",
                "xi",
                "min_samples",
                "min_cluster_size",
                "predecessor_correction"
            ],
            "_extract_xi_labels": [
                "ordering",
                "clusters"
            ],
            "OPTICS": {
                "__init__": [
                    "self",
                    "min_samples",
                    "max_eps",
                    "metric",
                    "p",
                    "metric_params",
                    "cluster_method",
                    "eps",
                    "xi",
                    "predecessor_correction",
                    "min_cluster_size",
                    "algorithm",
                    "leaf_size",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.cluster.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.cluster": {},
        "sklearn.cluster.mean_shift_": {
            "estimate_bandwidth": [
                "X",
                "quantile",
                "n_samples",
                "random_state",
                "n_jobs"
            ],
            "_mean_shift_single_seed": [
                "my_mean",
                "X",
                "nbrs",
                "max_iter"
            ],
            "mean_shift": [
                "X",
                "bandwidth",
                "seeds",
                "bin_seeding",
                "min_bin_freq",
                "cluster_all",
                "max_iter",
                "n_jobs"
            ],
            "get_bin_seeds": [
                "X",
                "bin_size",
                "min_bin_freq"
            ],
            "MeanShift": {
                "__init__": [
                    "self",
                    "bandwidth",
                    "seeds",
                    "bin_seeding",
                    "min_bin_freq",
                    "cluster_all",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.cluster.birch": {
            "_iterate_sparse_X": [
                "X"
            ],
            "_split_node": [
                "node",
                "threshold",
                "branching_factor"
            ],
            "_CFNode": {
                "__init__": [
                    "self",
                    "threshold",
                    "branching_factor",
                    "is_leaf",
                    "n_features"
                ],
                "append_subcluster": [
                    "self",
                    "subcluster"
                ],
                "update_split_subclusters": [
                    "self",
                    "subcluster",
                    "new_subcluster1",
                    "new_subcluster2"
                ],
                "insert_cf_subcluster": [
                    "self",
                    "subcluster"
                ]
            },
            "_CFSubcluster": {
                "__init__": [
                    "self",
                    "linear_sum"
                ],
                "update": [
                    "self",
                    "subcluster"
                ],
                "merge_subcluster": [
                    "self",
                    "nominee_cluster",
                    "threshold"
                ],
                "radius": [
                    "self"
                ]
            },
            "Birch": {
                "__init__": [
                    "self",
                    "threshold",
                    "branching_factor",
                    "n_clusters",
                    "compute_labels",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "_get_leaves": [
                    "self"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_check_fit": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_global_clustering": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.cluster.spectral": {
            "discretize": [
                "vectors",
                "copy",
                "max_svd_restarts",
                "n_iter_max",
                "random_state"
            ],
            "spectral_clustering": [
                "affinity",
                "n_clusters",
                "n_components",
                "eigen_solver",
                "random_state",
                "n_init",
                "eigen_tol",
                "assign_labels"
            ],
            "SpectralClustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "eigen_solver",
                    "random_state",
                    "n_init",
                    "gamma",
                    "affinity",
                    "n_neighbors",
                    "eigen_tol",
                    "assign_labels",
                    "degree",
                    "coef0",
                    "kernel_params",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_pairwise": [
                    "self"
                ]
            }
        },
        "sklearn.cluster.dbscan_": {
            "dbscan": [
                "X",
                "eps",
                "min_samples",
                "metric",
                "metric_params",
                "algorithm",
                "leaf_size",
                "p",
                "sample_weight",
                "n_jobs"
            ],
            "DBSCAN": {
                "__init__": [
                    "self",
                    "eps",
                    "min_samples",
                    "metric",
                    "metric_params",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "fit_predict": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            }
        },
        "sklearn.cluster.affinity_propagation_": {
            "_equal_similarities_and_preferences": [
                "S",
                "preference"
            ],
            "affinity_propagation": [
                "S",
                "preference",
                "convergence_iter",
                "max_iter",
                "damping",
                "copy",
                "verbose",
                "return_n_iter"
            ],
            "AffinityPropagation": {
                "__init__": [
                    "self",
                    "damping",
                    "max_iter",
                    "convergence_iter",
                    "copy",
                    "preference",
                    "affinity",
                    "verbose"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.cluster.bicluster": {
            "_scale_normalize": [
                "X"
            ],
            "_bistochastic_normalize": [
                "X",
                "max_iter",
                "tol"
            ],
            "_log_normalize": [
                "X"
            ],
            "BaseSpectral": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "svd_method",
                    "n_svd_vecs",
                    "mini_batch",
                    "init",
                    "n_init",
                    "n_jobs",
                    "random_state"
                ],
                "_check_parameters": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_svd": [
                    "self",
                    "array",
                    "n_components",
                    "n_discard"
                ],
                "_k_means": [
                    "self",
                    "data",
                    "n_clusters"
                ]
            },
            "SpectralCoclustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "svd_method",
                    "n_svd_vecs",
                    "mini_batch",
                    "init",
                    "n_init",
                    "n_jobs",
                    "random_state"
                ],
                "_fit": [
                    "self",
                    "X"
                ]
            },
            "SpectralBiclustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "method",
                    "n_components",
                    "n_best",
                    "svd_method",
                    "n_svd_vecs",
                    "mini_batch",
                    "init",
                    "n_init",
                    "n_jobs",
                    "random_state"
                ],
                "_check_parameters": [
                    "self"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "_fit_best_piecewise": [
                    "self",
                    "vectors",
                    "n_best",
                    "n_clusters"
                ],
                "_project_and_cluster": [
                    "self",
                    "data",
                    "vectors",
                    "n_clusters"
                ]
            }
        },
        "sklearn.cluster.k_means_": {
            "_k_init": [
                "X",
                "n_clusters",
                "x_squared_norms",
                "random_state",
                "n_local_trials"
            ],
            "_validate_center_shape": [
                "X",
                "n_centers",
                "centers"
            ],
            "_tolerance": [
                "X",
                "tol"
            ],
            "_check_sample_weight": [
                "X",
                "sample_weight"
            ],
            "k_means": [
                "X",
                "n_clusters",
                "sample_weight",
                "init",
                "precompute_distances",
                "n_init",
                "max_iter",
                "verbose",
                "tol",
                "random_state",
                "copy_x",
                "n_jobs",
                "algorithm",
                "return_n_iter"
            ],
            "_kmeans_single_elkan": [
                "X",
                "sample_weight",
                "n_clusters",
                "max_iter",
                "init",
                "verbose",
                "x_squared_norms",
                "random_state",
                "tol",
                "precompute_distances"
            ],
            "_kmeans_single_lloyd": [
                "X",
                "sample_weight",
                "n_clusters",
                "max_iter",
                "init",
                "verbose",
                "x_squared_norms",
                "random_state",
                "tol",
                "precompute_distances"
            ],
            "_labels_inertia_precompute_dense": [
                "X",
                "sample_weight",
                "x_squared_norms",
                "centers",
                "distances"
            ],
            "_labels_inertia": [
                "X",
                "sample_weight",
                "x_squared_norms",
                "centers",
                "precompute_distances",
                "distances"
            ],
            "_init_centroids": [
                "X",
                "k",
                "init",
                "random_state",
                "x_squared_norms",
                "init_size"
            ],
            "_mini_batch_step": [
                "X",
                "sample_weight",
                "x_squared_norms",
                "centers",
                "weight_sums",
                "old_center_buffer",
                "compute_squared_diff",
                "distances",
                "random_reassign",
                "random_state",
                "reassignment_ratio",
                "verbose"
            ],
            "_mini_batch_convergence": [
                "model",
                "iteration_idx",
                "n_iter",
                "tol",
                "n_samples",
                "centers_squared_diff",
                "batch_inertia",
                "context",
                "verbose"
            ],
            "KMeans": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "init",
                    "n_init",
                    "max_iter",
                    "tol",
                    "precompute_distances",
                    "verbose",
                    "random_state",
                    "copy_x",
                    "n_jobs",
                    "algorithm"
                ],
                "_check_test_data": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "fit_predict": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_transform": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X",
                    "sample_weight"
                ],
                "score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "MiniBatchKMeans": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "init",
                    "max_iter",
                    "batch_size",
                    "verbose",
                    "compute_labels",
                    "random_state",
                    "tol",
                    "max_no_improvement",
                    "init_size",
                    "n_init",
                    "reassignment_ratio"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_labels_inertia_minibatch": [
                    "self",
                    "X",
                    "sample_weight"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X",
                    "sample_weight"
                ]
            }
        },
        "sklearn.cluster._feature_agglomeration": {
            "AgglomerationTransform": {
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "Xred"
                ]
            }
        },
        "sklearn.cluster.hierarchical": {
            "_fix_connectivity": [
                "X",
                "connectivity",
                "affinity"
            ],
            "_single_linkage_tree": [
                "connectivity",
                "n_samples",
                "n_nodes",
                "n_clusters",
                "n_connected_components",
                "return_distance"
            ],
            "ward_tree": [
                "X",
                "connectivity",
                "n_clusters",
                "return_distance"
            ],
            "linkage_tree": [
                "X",
                "connectivity",
                "n_clusters",
                "linkage",
                "affinity",
                "return_distance"
            ],
            "_complete_linkage": [],
            "_average_linkage": [],
            "_single_linkage": [],
            "_hc_cut": [
                "n_clusters",
                "children",
                "n_leaves"
            ],
            "AgglomerativeClustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "affinity",
                    "memory",
                    "connectivity",
                    "compute_full_tree",
                    "linkage",
                    "pooling_func",
                    "distance_threshold"
                ],
                "n_components_": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "FeatureAgglomeration": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "affinity",
                    "memory",
                    "connectivity",
                    "compute_full_tree",
                    "linkage",
                    "pooling_func",
                    "distance_threshold"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_predict": [
                    "self"
                ]
            }
        },
        "sklearn.cluster.tests.test_hierarchical": {
            "test_linkage_misc": [],
            "test_structured_linkage_tree": [],
            "test_unstructured_linkage_tree": [],
            "test_height_linkage_tree": [],
            "test_agglomerative_clustering_wrong_arg_memory": [],
            "test_agglomerative_clustering": [],
            "test_ward_agglomeration": [],
            "test_single_linkage_clustering": [],
            "assess_same_labelling": [
                "cut1",
                "cut2"
            ],
            "test_scikit_vs_scipy": [],
            "test_identical_points": [],
            "test_connectivity_propagation": [],
            "test_ward_tree_children_order": [],
            "test_ward_linkage_tree_return_distance": [],
            "test_connectivity_fixing_non_lil": [],
            "test_int_float_dict": [],
            "test_connectivity_callable": [],
            "test_connectivity_ignores_diagonal": [],
            "test_compute_full_tree": [],
            "test_n_components": [],
            "test_agg_n_clusters": [],
            "test_affinity_passed_to_fix_connectivity": [],
            "test_agglomerative_clustering_with_distance_threshold": [
                "linkage"
            ],
            "test_small_distance_threshold": [],
            "test_cluster_distances_with_distance_threshold": [],
            "test_agglomerative_clustering_with_distance_threshold_edge_case": [
                "linkage",
                "threshold",
                "y_true"
            ],
            "test_dist_threshold_invalid_parameters": [],
            "test_n_components_deprecation": []
        },
        "sklearn.cluster.tests.common": {
            "generate_clustered_data": [
                "seed",
                "n_clusters",
                "n_features",
                "n_samples_per_cluster",
                "std"
            ]
        },
        "sklearn.cluster.tests.test_affinity_propagation": {
            "test_affinity_propagation": [],
            "test_affinity_propagation_predict": [],
            "test_affinity_propagation_predict_error": [],
            "test_affinity_propagation_fit_non_convergence": [],
            "test_affinity_propagation_equal_mutual_similarities": [],
            "test_affinity_propagation_predict_non_convergence": [],
            "test_equal_similarities_and_preferences": [],
            "test_affinity_propagation_convergence_warning_dense_sparse": [
                "centers"
            ]
        },
        "sklearn.cluster.tests.test_feature_agglomeration": {
            "test_feature_agglomeration": []
        },
        "sklearn.cluster.tests.test_optics": {
            "test_extend_downward": [
                "r_plot",
                "end"
            ],
            "test_extend_upward": [
                "r_plot",
                "end"
            ],
            "test_the_extract_xi_labels": [
                "ordering",
                "clusters",
                "expected"
            ],
            "test_extract_xi": [],
            "test_cluster_hierarchy_": [],
            "test_correct_number_of_clusters": [],
            "test_minimum_number_of_sample_check": [],
            "test_bad_extract": [],
            "test_bad_reachability": [],
            "test_close_extract": [],
            "test_dbscan_optics_parity": [
                "eps",
                "min_samples"
            ],
            "test_min_samples_edge_case": [],
            "test_min_cluster_size": [
                "min_cluster_size"
            ],
            "test_min_cluster_size_invalid": [
                "min_cluster_size"
            ],
            "test_min_cluster_size_invalid2": [],
            "test_processing_order": [],
            "test_compare_to_ELKI": [],
            "test_wrong_cluster_method": [],
            "test_extract_dbscan": [],
            "test_precomputed_dists": []
        },
        "sklearn.cluster.tests": {},
        "sklearn.cluster.tests.test_spectral": {
            "test_spectral_clustering": [
                "eigen_solver",
                "assign_labels"
            ],
            "test_spectral_unknown_mode": [],
            "test_spectral_unknown_assign_labels": [],
            "test_spectral_clustering_sparse": [],
            "test_affinities": [],
            "test_discretize": [
                "n_samples"
            ],
            "test_spectral_clustering_with_arpack_amg_solvers": []
        },
        "sklearn.cluster.tests.test_bicluster": {
            "test_get_submatrix": [],
            "_test_shape_indices": [
                "model"
            ],
            "test_spectral_coclustering": [],
            "test_spectral_biclustering": [],
            "_do_scale_test": [
                "scaled"
            ],
            "_do_bistochastic_test": [
                "scaled"
            ],
            "test_scale_normalize": [],
            "test_bistochastic_normalize": [],
            "test_log_normalize": [],
            "test_fit_best_piecewise": [],
            "test_project_and_cluster": [],
            "test_perfect_checkerboard": [],
            "test_errors": [],
            "MockBiclustering": {
                "__init__": [
                    "self"
                ],
                "get_indices": [
                    "self",
                    "i"
                ]
            }
        },
        "sklearn.cluster.tests.test_dbscan": {
            "test_dbscan_similarity": [],
            "test_dbscan_feature": [],
            "test_dbscan_sparse": [],
            "test_dbscan_sparse_precomputed": [
                "include_self"
            ],
            "test_dbscan_input_not_modified": [
                "use_sparse",
                "metric"
            ],
            "test_dbscan_no_core_samples": [],
            "test_dbscan_callable": [],
            "test_dbscan_metric_params": [],
            "test_dbscan_balltree": [],
            "test_input_validation": [],
            "test_dbscan_badargs": [],
            "test_pickle": [],
            "test_boundaries": [],
            "test_weighted_dbscan": [],
            "test_dbscan_core_samples_toy": [
                "algorithm"
            ],
            "test_dbscan_precomputed_metric_with_degenerate_input_arrays": [],
            "test_dbscan_precomputed_metric_with_initial_rows_zero": []
        },
        "sklearn.cluster.tests.test_birch": {
            "test_n_samples_leaves_roots": [],
            "test_partial_fit": [],
            "test_birch_predict": [],
            "test_n_clusters": [],
            "test_sparse_X": [],
            "check_branching_factor": [
                "node",
                "branching_factor"
            ],
            "test_branching_factor": [],
            "check_threshold": [
                "birch_instance",
                "threshold"
            ],
            "test_threshold": []
        },
        "sklearn.cluster.tests.test_k_means": {
            "test_kmeans_results": [
                "representation",
                "algo",
                "dtype"
            ],
            "test_elkan_results": [
                "distribution"
            ],
            "test_labels_assignment_and_inertia": [],
            "test_minibatch_update_consistency": [],
            "_check_fitted_model": [
                "km"
            ],
            "test_k_means_new_centers": [],
            "test_k_means_plus_plus_init_2_jobs": [],
            "test_k_means_precompute_distances_flag": [],
            "test_k_means_plus_plus_init_not_precomputed": [],
            "test_k_means_random_init_not_precomputed": [],
            "test_k_means_init": [
                "data",
                "init"
            ],
            "test_k_means_n_init": [],
            "test_k_means_explicit_init_shape": [
                "Class"
            ],
            "test_k_means_fortran_aligned_data": [],
            "test_k_means_fit_predict": [
                "algo",
                "dtype",
                "constructor",
                "seed",
                "max_iter",
                "tol"
            ],
            "test_mb_kmeans_verbose": [],
            "test_minibatch_init_with_large_k": [],
            "test_minibatch_k_means_init_multiple_runs_with_explicit_centers": [],
            "test_minibatch_k_means_init": [
                "data",
                "init"
            ],
            "test_minibatch_sensible_reassign_fit": [],
            "test_minibatch_sensible_reassign_partial_fit": [],
            "test_minibatch_reassign": [],
            "test_minibatch_with_many_reassignments": [],
            "test_sparse_mb_k_means_callable_init": [],
            "test_mini_batch_k_means_random_init_partial_fit": [],
            "test_minibatch_default_init_size": [],
            "test_minibatch_tol": [],
            "test_minibatch_set_init_size": [],
            "test_k_means_invalid_init": [
                "Estimator"
            ],
            "test_k_means_copyx": [],
            "test_k_means_non_collapsed": [],
            "test_score": [
                "algo"
            ],
            "test_predict": [
                "Estimator",
                "data",
                "init"
            ],
            "test_predict_minibatch_dense_sparse": [
                "init"
            ],
            "test_int_input": [],
            "test_transform": [],
            "test_fit_transform": [],
            "test_predict_equal_labels": [
                "algo"
            ],
            "test_full_vs_elkan": [],
            "test_n_init": [],
            "test_k_means_function": [],
            "test_x_squared_norms_init_centroids": [],
            "test_max_iter_error": [],
            "test_float_precision": [
                "Estimator",
                "is_sparse"
            ],
            "test_k_means_init_centers": [],
            "test_k_means_init_fitted_centers": [
                "data"
            ],
            "test_sparse_validate_centers": [],
            "test_less_centers_than_unique_points": [],
            "_sort_centers": [
                "centers"
            ],
            "test_weighted_vs_repeated": [],
            "test_unit_weights_vs_no_weights": [],
            "test_scaled_weights": [],
            "test_sample_weight_length": [],
            "test_check_sample_weight": [],
            "test_iter_attribute": [],
            "test_k_means_empty_cluster_relocated": []
        },
        "sklearn.cluster.tests.test_mean_shift": {
            "test_estimate_bandwidth": [],
            "test_estimate_bandwidth_1sample": [],
            "test_mean_shift": [
                "bandwidth",
                "cluster_all",
                "expected",
                "first_cluster_label"
            ],
            "test_mean_shift_negative_bandwidth": [],
            "test_estimate_bandwidth_with_sparse_matrix": [],
            "test_parallel": [],
            "test_meanshift_predict": [],
            "test_meanshift_all_orphans": [],
            "test_unfitted": [],
            "test_cluster_intensity_tie": [],
            "test_bin_seeds": []
        },
        "sklearn.externals.six": {
            "_add_doc": [
                "func",
                "doc"
            ],
            "_import_module": [
                "name"
            ],
            "add_move": [
                "move"
            ],
            "remove_move": [
                "name"
            ],
            "iterkeys": [
                "d"
            ],
            "itervalues": [
                "d"
            ],
            "iteritems": [
                "d"
            ],
            "iterlists": [
                "d"
            ],
            "with_metaclass": [
                "meta"
            ],
            "add_metaclass": [
                "metaclass"
            ],
            "_LazyDescr": {
                "__init__": [
                    "self",
                    "name"
                ],
                "__get__": [
                    "self",
                    "obj",
                    "tp"
                ]
            },
            "MovedModule": {
                "__init__": [
                    "self",
                    "name",
                    "old",
                    "new"
                ],
                "_resolve": [
                    "self"
                ]
            },
            "MovedAttribute": {
                "__init__": [
                    "self",
                    "name",
                    "old_mod",
                    "new_mod",
                    "old_attr",
                    "new_attr"
                ],
                "_resolve": [
                    "self"
                ]
            },
            "_MovedItems": {},
            "Module_six_moves_urllib_parse": {},
            "Module_six_moves_urllib_error": {},
            "Module_six_moves_urllib_request": {},
            "Module_six_moves_urllib_response": {},
            "Module_six_moves_urllib_robotparser": {},
            "Module_six_moves_urllib": {}
        },
        "sklearn.externals.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.externals": {},
        "sklearn.externals._arff": {
            "_build_re_values": [],
            "_escape_sub_callback": [
                "match"
            ],
            "_unquote": [
                "v"
            ],
            "_parse_values": [
                "s"
            ],
            "_unescape_sub_callback": [
                "match"
            ],
            "encode_string": [
                "s"
            ],
            "_get_data_object_for_decoding": [
                "matrix_type"
            ],
            "_get_data_object_for_encoding": [
                "matrix"
            ],
            "load": [
                "fp",
                "encode_nominal",
                "return_type"
            ],
            "loads": [
                "s",
                "encode_nominal",
                "return_type"
            ],
            "dump": [
                "obj",
                "fp"
            ],
            "dumps": [
                "obj"
            ],
            "ArffException": {
                "__init__": [
                    "self"
                ],
                "__str__": [
                    "self"
                ]
            },
            "BadRelationFormat": {},
            "BadAttributeFormat": {},
            "BadDataFormat": {
                "__init__": [
                    "self",
                    "value"
                ]
            },
            "BadAttributeType": {},
            "BadAttributeName": {
                "__init__": [
                    "self",
                    "value",
                    "value2"
                ]
            },
            "BadNominalValue": {
                "__init__": [
                    "self",
                    "value"
                ]
            },
            "BadNominalFormatting": {
                "__init__": [
                    "self",
                    "value"
                ]
            },
            "BadNumericalValue": {},
            "BadStringValue": {},
            "BadLayout": {
                "__init__": [
                    "self",
                    "msg"
                ]
            },
            "BadObject": {
                "__init__": [
                    "self",
                    "msg"
                ],
                "__str__": [
                    "self"
                ]
            },
            "EncodedNominalConversor": {
                "__init__": [
                    "self",
                    "values"
                ],
                "__call__": [
                    "self",
                    "value"
                ]
            },
            "NominalConversor": {
                "__init__": [
                    "self",
                    "values"
                ],
                "__call__": [
                    "self",
                    "value"
                ]
            },
            "DenseGeneratorData": {
                "decode_rows": [
                    "self",
                    "stream",
                    "conversors"
                ],
                "_decode_values": [
                    "values",
                    "conversors"
                ],
                "encode_data": [
                    "self",
                    "data",
                    "attributes"
                ]
            },
            "_DataListMixin": {
                "decode_rows": [
                    "self",
                    "stream",
                    "conversors"
                ]
            },
            "Data": {},
            "COOData": {
                "decode_rows": [
                    "self",
                    "stream",
                    "conversors"
                ],
                "encode_data": [
                    "self",
                    "data",
                    "attributes"
                ]
            },
            "LODGeneratorData": {
                "decode_rows": [
                    "self",
                    "stream",
                    "conversors"
                ],
                "encode_data": [
                    "self",
                    "data",
                    "attributes"
                ]
            },
            "LODData": {},
            "ArffDecoder": {
                "__init__": [
                    "self"
                ],
                "_decode_comment": [
                    "self",
                    "s"
                ],
                "_decode_relation": [
                    "self",
                    "s"
                ],
                "_decode_attribute": [
                    "self",
                    "s"
                ],
                "_decode": [
                    "self",
                    "s",
                    "encode_nominal",
                    "matrix_type"
                ],
                "decode": [
                    "self",
                    "s",
                    "encode_nominal",
                    "return_type"
                ]
            },
            "ArffEncoder": {
                "_encode_comment": [
                    "self",
                    "s"
                ],
                "_encode_relation": [
                    "self",
                    "name"
                ],
                "_encode_attribute": [
                    "self",
                    "name",
                    "type_"
                ],
                "encode": [
                    "self",
                    "obj"
                ],
                "iter_encode": [
                    "self",
                    "obj"
                ]
            }
        },
        "sklearn.externals._pilutil": {
            "bytescale": [
                "data",
                "cmin",
                "cmax",
                "high",
                "low"
            ],
            "imread": [
                "name",
                "flatten",
                "mode"
            ],
            "imsave": [
                "name",
                "arr",
                "format"
            ],
            "fromimage": [
                "im",
                "flatten",
                "mode"
            ],
            "toimage": [
                "arr",
                "high",
                "low",
                "cmin",
                "cmax",
                "pal",
                "mode",
                "channel_axis"
            ],
            "imresize": [
                "arr",
                "size",
                "interp",
                "mode"
            ]
        },
        "sklearn.externals.conftest": {
            "pytest_ignore_collect": [
                "path",
                "config"
            ]
        },
        "sklearn.externals.joblib": {},
        "sklearn.externals.joblib.numpy_pickle": {},
        "sklearn.feature_extraction.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.feature_extraction.dict_vectorizer": {
            "_tosequence": [
                "X"
            ],
            "DictVectorizer": {
                "__init__": [
                    "self",
                    "dtype",
                    "separator",
                    "sparse",
                    "sort"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_transform": [
                    "self",
                    "X",
                    "fitting"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "dict_type"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "get_feature_names": [
                    "self"
                ],
                "restrict": [
                    "self",
                    "support",
                    "indices"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.feature_extraction": {},
        "sklearn.feature_extraction.text": {
            "strip_accents_unicode": [
                "s"
            ],
            "strip_accents_ascii": [
                "s"
            ],
            "strip_tags": [
                "s"
            ],
            "_check_stop_list": [
                "stop"
            ],
            "_document_frequency": [
                "X"
            ],
            "_make_int_array": [],
            "VectorizerMixin": {
                "decode": [
                    "self",
                    "doc"
                ],
                "_word_ngrams": [
                    "self",
                    "tokens",
                    "stop_words"
                ],
                "_char_ngrams": [
                    "self",
                    "text_document"
                ],
                "_char_wb_ngrams": [
                    "self",
                    "text_document"
                ],
                "build_preprocessor": [
                    "self"
                ],
                "build_tokenizer": [
                    "self"
                ],
                "get_stop_words": [
                    "self"
                ],
                "_check_stop_words_consistency": [
                    "self",
                    "stop_words",
                    "preprocess",
                    "tokenize"
                ],
                "_validate_custom_analyzer": [
                    "self"
                ],
                "build_analyzer": [
                    "self"
                ],
                "_validate_vocabulary": [
                    "self"
                ],
                "_check_vocabulary": [
                    "self"
                ],
                "_validate_params": [
                    "self"
                ]
            },
            "HashingVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "encoding",
                    "decode_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "analyzer",
                    "n_features",
                    "binary",
                    "norm",
                    "alternate_sign",
                    "dtype"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_hasher": [
                    "self"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "CountVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "encoding",
                    "decode_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "analyzer",
                    "max_df",
                    "min_df",
                    "max_features",
                    "vocabulary",
                    "binary",
                    "dtype"
                ],
                "_sort_features": [
                    "self",
                    "X",
                    "vocabulary"
                ],
                "_limit_features": [
                    "self",
                    "X",
                    "vocabulary",
                    "high",
                    "low",
                    "limit"
                ],
                "_count_vocab": [
                    "self",
                    "raw_documents",
                    "fixed_vocab"
                ],
                "fit": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "transform": [
                    "self",
                    "raw_documents"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "get_feature_names": [
                    "self"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "TfidfTransformer": {
                "__init__": [
                    "self",
                    "norm",
                    "use_idf",
                    "smooth_idf",
                    "sublinear_tf"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "idf_": [
                    "self",
                    "value"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "TfidfVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "encoding",
                    "decode_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "analyzer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "max_df",
                    "min_df",
                    "max_features",
                    "vocabulary",
                    "binary",
                    "dtype",
                    "norm",
                    "use_idf",
                    "smooth_idf",
                    "sublinear_tf"
                ],
                "norm": [
                    "self",
                    "value"
                ],
                "use_idf": [
                    "self",
                    "value"
                ],
                "smooth_idf": [
                    "self",
                    "value"
                ],
                "sublinear_tf": [
                    "self",
                    "value"
                ],
                "idf_": [
                    "self",
                    "value"
                ],
                "_check_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "transform": [
                    "self",
                    "raw_documents",
                    "copy"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.feature_extraction.image": {
            "_make_edges_3d": [
                "n_x",
                "n_y",
                "n_z"
            ],
            "_compute_gradient_3d": [
                "edges",
                "img"
            ],
            "_mask_edges_weights": [
                "mask",
                "edges",
                "weights"
            ],
            "_to_graph": [
                "n_x",
                "n_y",
                "n_z",
                "mask",
                "img",
                "return_as",
                "dtype"
            ],
            "img_to_graph": [
                "img",
                "mask",
                "return_as",
                "dtype"
            ],
            "grid_to_graph": [
                "n_x",
                "n_y",
                "n_z",
                "mask",
                "return_as",
                "dtype"
            ],
            "_compute_n_patches": [
                "i_h",
                "i_w",
                "p_h",
                "p_w",
                "max_patches"
            ],
            "extract_patches": [
                "arr",
                "patch_shape",
                "extraction_step"
            ],
            "extract_patches_2d": [
                "image",
                "patch_size",
                "max_patches",
                "random_state"
            ],
            "reconstruct_from_patches_2d": [
                "patches",
                "image_size"
            ],
            "PatchExtractor": {
                "__init__": [
                    "self",
                    "patch_size",
                    "max_patches",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.feature_extraction.hashing": {
            "_iteritems": [
                "d"
            ],
            "FeatureHasher": {
                "__init__": [
                    "self",
                    "n_features",
                    "input_type",
                    "dtype",
                    "alternate_sign"
                ],
                "_validate_params": [
                    "n_features",
                    "input_type"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "raw_X"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.feature_extraction.stop_words": {},
        "sklearn.feature_extraction.tests.test_image": {
            "test_img_to_graph": [],
            "test_grid_to_graph": [],
            "test_connect_regions": [],
            "test_connect_regions_with_grid": [],
            "_downsampled_face": [],
            "_orange_face": [
                "face"
            ],
            "_make_images": [
                "face"
            ],
            "test_extract_patches_all": [],
            "test_extract_patches_all_color": [],
            "test_extract_patches_all_rect": [],
            "test_extract_patches_max_patches": [],
            "test_extract_patch_same_size_image": [],
            "test_extract_patches_less_than_max_patches": [],
            "test_reconstruct_patches_perfect": [],
            "test_reconstruct_patches_perfect_color": [],
            "test_patch_extractor_fit": [],
            "test_patch_extractor_max_patches": [],
            "test_patch_extractor_max_patches_default": [],
            "test_patch_extractor_all_patches": [],
            "test_patch_extractor_color": [],
            "test_extract_patches_strided": [],
            "test_extract_patches_square": [],
            "test_width_patch": []
        },
        "sklearn.feature_extraction.tests": {},
        "sklearn.feature_extraction.tests.test_dict_vectorizer": {
            "test_dictvectorizer": [
                "sparse",
                "dtype",
                "sort",
                "iterable"
            ],
            "test_feature_selection": [],
            "test_one_of_k": [],
            "test_unseen_or_no_features": [],
            "test_deterministic_vocabulary": []
        },
        "sklearn.feature_extraction.tests.test_text": {
            "uppercase": [
                "s"
            ],
            "strip_eacute": [
                "s"
            ],
            "split_tokenize": [
                "s"
            ],
            "lazy_analyze": [
                "s"
            ],
            "test_strip_accents": [],
            "test_to_ascii": [],
            "test_word_analyzer_unigrams": [
                "Vectorizer"
            ],
            "test_word_analyzer_unigrams_and_bigrams": [],
            "test_unicode_decode_error": [],
            "test_char_ngram_analyzer": [],
            "test_char_wb_ngram_analyzer": [],
            "test_word_ngram_analyzer": [],
            "test_countvectorizer_custom_vocabulary": [],
            "test_countvectorizer_custom_vocabulary_pipeline": [],
            "test_countvectorizer_custom_vocabulary_repeated_indices": [],
            "test_countvectorizer_custom_vocabulary_gap_index": [],
            "test_countvectorizer_stop_words": [],
            "test_countvectorizer_empty_vocabulary": [],
            "test_fit_countvectorizer_twice": [],
            "test_tf_idf_smoothing": [],
            "test_tfidf_no_smoothing": [],
            "test_sublinear_tf": [],
            "test_vectorizer": [],
            "test_tfidf_vectorizer_setters": [],
            "test_hashing_vectorizer": [],
            "test_feature_names": [],
            "test_vectorizer_max_features": [
                "Vectorizer"
            ],
            "test_count_vectorizer_max_features": [],
            "test_vectorizer_max_df": [],
            "test_vectorizer_min_df": [],
            "test_count_binary_occurrences": [],
            "test_hashed_binary_occurrences": [],
            "test_vectorizer_inverse_transform": [
                "Vectorizer"
            ],
            "test_count_vectorizer_pipeline_grid_selection": [],
            "test_vectorizer_pipeline_grid_selection": [],
            "test_vectorizer_pipeline_cross_validation": [],
            "test_vectorizer_unicode": [],
            "test_tfidf_vectorizer_with_fixed_vocabulary": [],
            "test_pickling_vectorizer": [],
            "test_countvectorizer_vocab_sets_when_pickling": [],
            "test_countvectorizer_vocab_dicts_when_pickling": [],
            "test_stop_words_removal": [],
            "test_pickling_transformer": [],
            "test_transformer_idf_setter": [],
            "test_tfidf_vectorizer_setter": [],
            "test_tfidfvectorizer_invalid_idf_attr": [],
            "test_non_unique_vocab": [],
            "test_hashingvectorizer_nan_in_docs": [],
            "test_tfidfvectorizer_binary": [],
            "test_tfidfvectorizer_export_idf": [],
            "test_vectorizer_vocab_clone": [],
            "test_vectorizer_string_object_as_input": [
                "Vectorizer"
            ],
            "test_tfidf_transformer_type": [
                "X_dtype"
            ],
            "test_tfidf_transformer_sparse": [],
            "test_tfidf_vectorizer_type": [
                "vectorizer_dtype",
                "output_dtype",
                "warning_expected"
            ],
            "test_vectorizers_invalid_ngram_range": [
                "vec"
            ],
            "_check_stop_words_consistency": [
                "estimator"
            ],
            "test_vectorizer_stop_words_inconsistent": [],
            "test_countvectorizer_sort_features_64bit_sparse_indices": [],
            "test_stop_word_validation_custom_preprocessor": [
                "Estimator"
            ],
            "test_callable_analyzer_error": [
                "Estimator",
                "input_type",
                "err_type",
                "err_msg"
            ],
            "test_callable_analyzer_change_behavior": [
                "Estimator",
                "analyzer",
                "input_type"
            ],
            "test_callable_analyzer_reraise_error": [
                "tmpdir",
                "Estimator"
            ]
        },
        "sklearn.feature_extraction.tests.test_feature_hasher": {
            "test_feature_hasher_dicts": [],
            "test_feature_hasher_strings": [],
            "test_feature_hasher_pairs": [],
            "test_feature_hasher_pairs_with_string_values": [],
            "test_hash_empty_input": [],
            "test_hasher_invalid_input": [],
            "test_hasher_set_params": [],
            "test_hasher_zeros": [],
            "test_hasher_alternate_sign": [],
            "test_hash_collisions": []
        },
        "sklearn.preprocessing._discretization": {
            "KBinsDiscretizer": {
                "__init__": [
                    "self",
                    "n_bins",
                    "encode",
                    "strategy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_n_bins": [
                    "self",
                    "n_features"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "Xt"
                ]
            }
        },
        "sklearn.preprocessing._encoders": {
            "_BaseEncoder": {
                "_check_X": [
                    "self",
                    "X"
                ],
                "_get_feature": [
                    "self",
                    "X",
                    "feature_idx"
                ],
                "_fit": [
                    "self",
                    "X",
                    "handle_unknown"
                ],
                "_transform": [
                    "self",
                    "X",
                    "handle_unknown"
                ]
            },
            "OneHotEncoder": {
                "__init__": [
                    "self",
                    "n_values",
                    "categorical_features",
                    "categories",
                    "drop",
                    "sparse",
                    "dtype",
                    "handle_unknown"
                ],
                "active_features_": [
                    "self"
                ],
                "feature_indices_": [
                    "self"
                ],
                "n_values_": [
                    "self"
                ],
                "_handle_deprecations": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_compute_drop_idx": [
                    "self"
                ],
                "_validate_keywords": [
                    "self"
                ],
                "_legacy_fit_transform": [
                    "self",
                    "X"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_legacy_transform": [
                    "self",
                    "X"
                ],
                "_transform_new": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "get_feature_names": [
                    "self",
                    "input_features"
                ]
            },
            "OrdinalEncoder": {
                "__init__": [
                    "self",
                    "categories",
                    "dtype"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.preprocessing.data": {
            "_handle_zeros_in_scale": [
                "scale",
                "copy"
            ],
            "scale": [
                "X",
                "axis",
                "with_mean",
                "with_std",
                "copy"
            ],
            "minmax_scale": [
                "X",
                "feature_range",
                "axis",
                "copy"
            ],
            "maxabs_scale": [
                "X",
                "axis",
                "copy"
            ],
            "robust_scale": [
                "X",
                "axis",
                "with_centering",
                "with_scaling",
                "quantile_range",
                "copy"
            ],
            "normalize": [
                "X",
                "norm",
                "axis",
                "copy",
                "return_norm"
            ],
            "binarize": [
                "X",
                "threshold",
                "copy"
            ],
            "add_dummy_feature": [
                "X",
                "value"
            ],
            "quantile_transform": [
                "X",
                "axis",
                "n_quantiles",
                "output_distribution",
                "ignore_implicit_zeros",
                "subsample",
                "random_state",
                "copy"
            ],
            "power_transform": [
                "X",
                "method",
                "standardize",
                "copy"
            ],
            "MinMaxScaler": {
                "__init__": [
                    "self",
                    "feature_range",
                    "copy"
                ],
                "_reset": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "StandardScaler": {
                "__init__": [
                    "self",
                    "copy",
                    "with_mean",
                    "with_std"
                ],
                "_reset": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MaxAbsScaler": {
                "__init__": [
                    "self",
                    "copy"
                ],
                "_reset": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "RobustScaler": {
                "__init__": [
                    "self",
                    "with_centering",
                    "with_scaling",
                    "quantile_range",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "PolynomialFeatures": {
                "__init__": [
                    "self",
                    "degree",
                    "interaction_only",
                    "include_bias",
                    "order"
                ],
                "_combinations": [
                    "n_features",
                    "degree",
                    "interaction_only",
                    "include_bias"
                ],
                "powers_": [
                    "self"
                ],
                "get_feature_names": [
                    "self",
                    "input_features"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "Normalizer": {
                "__init__": [
                    "self",
                    "norm",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "Binarizer": {
                "__init__": [
                    "self",
                    "threshold",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "KernelCenterer": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "K",
                    "y"
                ],
                "transform": [
                    "self",
                    "K",
                    "copy"
                ],
                "_pairwise": [
                    "self"
                ]
            },
            "QuantileTransformer": {
                "__init__": [
                    "self",
                    "n_quantiles",
                    "output_distribution",
                    "ignore_implicit_zeros",
                    "subsample",
                    "random_state",
                    "copy"
                ],
                "_dense_fit": [
                    "self",
                    "X",
                    "random_state"
                ],
                "_sparse_fit": [
                    "self",
                    "X",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_transform_col": [
                    "self",
                    "X_col",
                    "quantiles",
                    "inverse"
                ],
                "_check_inputs": [
                    "self",
                    "X",
                    "accept_sparse_negative"
                ],
                "_check_is_fitted": [
                    "self",
                    "X"
                ],
                "_transform": [
                    "self",
                    "X",
                    "inverse"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "PowerTransformer": {
                "__init__": [
                    "self",
                    "method",
                    "standardize",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "force_transform"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_box_cox_inverse_tranform": [
                    "self",
                    "x",
                    "lmbda"
                ],
                "_yeo_johnson_inverse_transform": [
                    "self",
                    "x",
                    "lmbda"
                ],
                "_yeo_johnson_transform": [
                    "self",
                    "x",
                    "lmbda"
                ],
                "_box_cox_optimize": [
                    "self",
                    "x"
                ],
                "_yeo_johnson_optimize": [
                    "self",
                    "x"
                ],
                "_check_input": [
                    "self",
                    "X",
                    "check_positive",
                    "check_shape",
                    "check_method"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.preprocessing.label": {
            "_encode_numpy": [
                "values",
                "uniques",
                "encode"
            ],
            "_encode_python": [
                "values",
                "uniques",
                "encode"
            ],
            "_encode": [
                "values",
                "uniques",
                "encode"
            ],
            "_encode_check_unknown": [
                "values",
                "uniques",
                "return_mask"
            ],
            "label_binarize": [
                "y",
                "classes",
                "neg_label",
                "pos_label",
                "sparse_output"
            ],
            "_inverse_binarize_multiclass": [
                "y",
                "classes"
            ],
            "_inverse_binarize_thresholding": [
                "y",
                "output_type",
                "classes",
                "threshold"
            ],
            "LabelEncoder": {
                "fit": [
                    "self",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "y"
                ],
                "transform": [
                    "self",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "y"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "LabelBinarizer": {
                "__init__": [
                    "self",
                    "neg_label",
                    "pos_label",
                    "sparse_output"
                ],
                "fit": [
                    "self",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "y"
                ],
                "transform": [
                    "self",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "Y",
                    "threshold"
                ],
                "_more_tags": [
                    "self"
                ]
            },
            "MultiLabelBinarizer": {
                "__init__": [
                    "self",
                    "classes",
                    "sparse_output"
                ],
                "fit": [
                    "self",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "y"
                ],
                "transform": [
                    "self",
                    "y"
                ],
                "_build_cache": [
                    "self"
                ],
                "_transform": [
                    "self",
                    "y",
                    "class_mapping"
                ],
                "inverse_transform": [
                    "self",
                    "yt"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.preprocessing.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.preprocessing.imputation": {
            "_get_mask": [
                "X",
                "value_to_mask"
            ],
            "_most_frequent": [
                "array",
                "extra_value",
                "n_repeat"
            ],
            "Imputer": {
                "__init__": [
                    "self",
                    "missing_values",
                    "strategy",
                    "axis",
                    "verbose",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_sparse_fit": [
                    "self",
                    "X",
                    "strategy",
                    "missing_values",
                    "axis"
                ],
                "_dense_fit": [
                    "self",
                    "X",
                    "strategy",
                    "missing_values",
                    "axis"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.preprocessing": {},
        "sklearn.preprocessing._function_transformer": {
            "_identity": [
                "X"
            ],
            "FunctionTransformer": {
                "__init__": [
                    "self",
                    "func",
                    "inverse_func",
                    "validate",
                    "accept_sparse",
                    "pass_y",
                    "check_inverse",
                    "kw_args",
                    "inv_kw_args"
                ],
                "_check_input": [
                    "self",
                    "X"
                ],
                "_check_inverse_transform": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "_transform": [
                    "self",
                    "X",
                    "func",
                    "kw_args"
                ],
                "_more_tags": [
                    "self"
                ]
            }
        },
        "sklearn.preprocessing.base": {
            "_transform_selected": [
                "X",
                "transform",
                "dtype",
                "selected",
                "copy",
                "retain_order"
            ]
        },
        "sklearn.preprocessing.tests.test_base": {
            "toarray": [
                "a"
            ],
            "_check_transform_selected": [
                "X",
                "X_expected",
                "dtype",
                "sel"
            ],
            "test_transform_selected": [
                "output_dtype",
                "input_dtype"
            ],
            "test_transform_selected_copy_arg": [
                "output_dtype",
                "input_dtype"
            ],
            "test_transform_selected_retain_order": []
        },
        "sklearn.preprocessing.tests.test_label": {
            "toarray": [
                "a"
            ],
            "test_label_binarizer": [],
            "test_label_binarizer_unseen_labels": [],
            "test_label_binarizer_set_label_encoding": [],
            "test_label_binarizer_errors": [],
            "test_label_encoder": [
                "values",
                "classes",
                "unknown"
            ],
            "test_label_encoder_negative_ints": [],
            "test_label_encoder_str_bad_shape": [
                "dtype"
            ],
            "test_label_encoder_errors": [],
            "test_label_encoder_empty_array": [
                "values"
            ],
            "test_sparse_output_multilabel_binarizer": [],
            "test_multilabel_binarizer": [],
            "test_multilabel_binarizer_empty_sample": [],
            "test_multilabel_binarizer_unknown_class": [],
            "test_multilabel_binarizer_given_classes": [],
            "test_multilabel_binarizer_multiple_calls": [],
            "test_multilabel_binarizer_same_length_sequence": [],
            "test_multilabel_binarizer_non_integer_labels": [],
            "test_multilabel_binarizer_non_unique": [],
            "test_multilabel_binarizer_inverse_validation": [],
            "test_label_binarize_with_class_order": [],
            "check_binarized_results": [
                "y",
                "classes",
                "pos_label",
                "neg_label",
                "expected"
            ],
            "test_label_binarize_binary": [],
            "test_label_binarize_multiclass": [],
            "test_label_binarize_multilabel": [],
            "test_invalid_input_label_binarize": [],
            "test_inverse_binarize_multiclass": [],
            "test_encode_util": [
                "values",
                "expected"
            ]
        },
        "sklearn.preprocessing.tests": {},
        "sklearn.preprocessing.tests.test_function_transformer": {
            "_make_func": [
                "args_store",
                "kwargs_store",
                "func"
            ],
            "test_delegate_to_func": [],
            "test_np_log": [],
            "test_kw_arg": [],
            "test_kw_arg_update": [],
            "test_kw_arg_reset": [],
            "test_inverse_transform": [],
            "test_check_inverse": [],
            "test_function_transformer_future_warning": [
                "validate",
                "expected_warning"
            ],
            "test_function_transformer_frame": []
        },
        "sklearn.preprocessing.tests.test_imputation": {
            "_check_statistics": [
                "X",
                "X_true",
                "strategy",
                "statistics",
                "missing_values"
            ],
            "test_imputation_shape": [],
            "test_imputation_mean_median_only_zero": [],
            "safe_median": [
                "arr"
            ],
            "safe_mean": [
                "arr"
            ],
            "test_imputation_mean_median": [],
            "test_imputation_median_special_cases": [],
            "test_imputation_most_frequent": [],
            "test_imputation_pipeline_grid_search": [],
            "test_imputation_pickle": [],
            "test_imputation_copy": []
        },
        "sklearn.preprocessing.tests.test_data": {
            "toarray": [
                "a"
            ],
            "_check_dim_1axis": [
                "a"
            ],
            "assert_correct_incr": [
                "i",
                "batch_start",
                "batch_stop",
                "n",
                "chunk_size",
                "n_samples_seen"
            ],
            "test_polynomial_features": [],
            "test_polynomial_feature_names": [],
            "test_polynomial_feature_array_order": [],
            "test_polynomial_features_csc_X": [
                "deg",
                "include_bias",
                "interaction_only",
                "dtype"
            ],
            "test_polynomial_features_csr_X": [
                "deg",
                "include_bias",
                "interaction_only",
                "dtype"
            ],
            "test_polynomial_features_csr_X_floats": [
                "deg",
                "include_bias",
                "interaction_only",
                "dtype"
            ],
            "test_polynomial_features_csr_X_zero_row": [
                "zero_row_index",
                "deg",
                "interaction_only"
            ],
            "test_polynomial_features_csr_X_degree_4": [
                "include_bias",
                "interaction_only"
            ],
            "test_polynomial_features_csr_X_dim_edges": [
                "deg",
                "dim",
                "interaction_only"
            ],
            "test_standard_scaler_1d": [],
            "test_standard_scaler_dtype": [],
            "test_scale_1d": [],
            "test_standard_scaler_numerical_stability": [],
            "test_scaler_2d_arrays": [],
            "test_scaler_float16_overflow": [],
            "test_handle_zeros_in_scale": [],
            "test_minmax_scaler_partial_fit": [],
            "test_standard_scaler_partial_fit": [],
            "test_standard_scaler_partial_fit_numerical_stability": [],
            "test_partial_fit_sparse_input": [],
            "test_standard_scaler_trasform_with_partial_fit": [],
            "test_min_max_scaler_iris": [],
            "test_min_max_scaler_zero_variance_features": [],
            "test_minmax_scale_axis1": [],
            "test_min_max_scaler_1d": [],
            "test_scaler_without_centering": [],
            "test_scaler_n_samples_seen_with_nan": [
                "with_mean",
                "with_std",
                "array_constructor"
            ],
            "_check_identity_scalers_attributes": [
                "scaler_1",
                "scaler_2"
            ],
            "test_scaler_return_identity": [],
            "test_scaler_int": [],
            "test_scaler_without_copy": [],
            "test_scale_sparse_with_mean_raise_exception": [],
            "test_scale_input_finiteness_validation": [],
            "test_robust_scaler_error_sparse": [],
            "test_robust_scaler_attributes": [
                "X",
                "with_centering",
                "with_scaling"
            ],
            "test_robust_scaler_col_zero_sparse": [],
            "test_robust_scaler_2d_arrays": [],
            "test_robust_scaler_equivalence_dense_sparse": [
                "density",
                "strictly_signed"
            ],
            "test_robust_scaler_transform_one_row_csr": [],
            "test_robust_scaler_iris": [],
            "test_robust_scaler_iris_quantiles": [],
            "test_quantile_transform_iris": [],
            "test_quantile_transform_check_error": [],
            "test_quantile_transform_sparse_ignore_zeros": [],
            "test_quantile_transform_dense_toy": [],
            "test_quantile_transform_subsampling": [],
            "test_quantile_transform_sparse_toy": [],
            "test_quantile_transform_axis1": [],
            "test_quantile_transform_bounds": [],
            "test_quantile_transform_and_inverse": [],
            "test_quantile_transform_nan": [],
            "test_deprecated_quantile_transform_copy": [],
            "test_robust_scaler_invalid_range": [],
            "test_scale_function_without_centering": [],
            "test_robust_scale_axis1": [],
            "test_robust_scale_1d_array": [],
            "test_robust_scaler_zero_variance_features": [],
            "test_maxabs_scaler_zero_variance_features": [],
            "test_maxabs_scaler_large_negative_value": [],
            "test_maxabs_scaler_transform_one_row_csr": [],
            "test_maxabs_scaler_1d": [],
            "test_maxabs_scaler_partial_fit": [],
            "test_normalizer_l1": [],
            "test_normalizer_l2": [],
            "test_normalizer_max": [],
            "test_normalize": [],
            "test_binarizer": [],
            "test_center_kernel": [],
            "test_cv_pipeline_precomputed": [],
            "test_fit_transform": [],
            "test_add_dummy_feature": [],
            "test_add_dummy_feature_coo": [],
            "test_add_dummy_feature_csc": [],
            "test_add_dummy_feature_csr": [],
            "test_fit_cold_start": [],
            "test_quantile_transform_valid_axis": [],
            "test_power_transformer_notfitted": [
                "method"
            ],
            "test_power_transformer_inverse": [
                "method",
                "standardize",
                "X"
            ],
            "test_power_transformer_1d": [],
            "test_power_transformer_2d": [],
            "test_power_transformer_boxcox_strictly_positive_exception": [],
            "test_power_transformer_yeojohnson_any_input": [
                "X"
            ],
            "test_power_transformer_shape_exception": [
                "method"
            ],
            "test_power_transformer_method_exception": [],
            "test_power_transformer_lambda_zero": [],
            "test_power_transformer_lambda_one": [],
            "test_optimization_power_transformer": [
                "method",
                "lmbda"
            ],
            "test_yeo_johnson_darwin_example": [],
            "test_power_transformer_nans": [
                "method"
            ],
            "test_power_transformer_fit_transform": [
                "method",
                "standardize"
            ],
            "test_power_transformer_copy_True": [
                "method",
                "standardize"
            ],
            "test_power_transformer_copy_False": [
                "method",
                "standardize"
            ],
            "test_power_transform_default_method": []
        },
        "sklearn.preprocessing.tests.test_encoders": {
            "toarray": [
                "a"
            ],
            "test_one_hot_encoder_sparse": [],
            "test_one_hot_encoder_dense": [],
            "test_one_hot_encoder_deprecationwarnings": [],
            "test_one_hot_encoder_force_new_behaviour": [],
            "_run_one_hot": [
                "X",
                "X2",
                "cat"
            ],
            "_check_one_hot": [
                "X",
                "X2",
                "cat",
                "n_features"
            ],
            "test_one_hot_encoder_categorical_features": [],
            "test_one_hot_encoder_categorical_features_ignore_unknown": [],
            "test_one_hot_encoder_handle_unknown": [],
            "test_one_hot_encoder_not_fitted": [],
            "test_one_hot_encoder_no_categorical_features": [],
            "test_one_hot_encoder_handle_unknown_strings": [],
            "test_one_hot_encoder_dtype": [
                "input_dtype",
                "output_dtype"
            ],
            "test_one_hot_encoder_dtype_pandas": [
                "output_dtype"
            ],
            "test_one_hot_encoder_set_params": [],
            "check_categorical_onehot": [
                "X"
            ],
            "test_one_hot_encoder": [
                "X"
            ],
            "test_one_hot_encoder_inverse": [
                "sparse_",
                "drop"
            ],
            "test_X_is_not_1D": [
                "X",
                "method"
            ],
            "test_X_is_not_1D_pandas": [
                "method"
            ],
            "test_one_hot_encoder_categories": [
                "X",
                "cat_exp",
                "cat_dtype"
            ],
            "test_one_hot_encoder_specified_categories": [
                "X",
                "X2",
                "cats",
                "cat_dtype"
            ],
            "test_one_hot_encoder_unsorted_categories": [],
            "test_one_hot_encoder_specified_categories_mixed_columns": [],
            "test_one_hot_encoder_pandas": [],
            "test_one_hot_encoder_feature_names": [],
            "test_one_hot_encoder_feature_names_unicode": [],
            "test_one_hot_encoder_raise_missing": [
                "X",
                "as_data_frame",
                "handle_unknown"
            ],
            "test_ordinal_encoder": [
                "X"
            ],
            "test_ordinal_encoder_specified_categories": [
                "X",
                "X2",
                "cats",
                "cat_dtype"
            ],
            "test_ordinal_encoder_inverse": [],
            "test_ordinal_encoder_raise_missing": [
                "X"
            ],
            "test_ordinal_encoder_raise_categories_shape": [],
            "test_encoder_dtypes": [],
            "test_encoder_dtypes_pandas": [],
            "test_one_hot_encoder_warning": [],
            "test_one_hot_encoder_drop_manual": [],
            "test_one_hot_encoder_invalid_params": [],
            "test_invalid_drop_length": [
                "drop"
            ],
            "test_categories": [
                "density",
                "drop"
            ]
        },
        "sklearn.preprocessing.tests.test_discretization": {
            "test_fit_transform": [
                "strategy",
                "expected"
            ],
            "test_valid_n_bins": [],
            "test_invalid_n_bins": [],
            "test_invalid_n_bins_array": [],
            "test_fit_transform_n_bins_array": [
                "strategy",
                "expected"
            ],
            "test_invalid_n_features": [],
            "test_same_min_max": [
                "strategy"
            ],
            "test_transform_1d_behavior": [],
            "test_numeric_stability": [],
            "test_invalid_encode_option": [],
            "test_encode_options": [],
            "test_invalid_strategy_option": [],
            "test_nonuniform_strategies": [
                "strategy",
                "expected_2bins",
                "expected_3bins",
                "expected_5bins"
            ],
            "test_inverse_transform": [
                "strategy",
                "encode",
                "expected_inv"
            ],
            "test_transform_outside_fit_range": [
                "strategy"
            ],
            "test_overwrite": [],
            "test_redundant_bins": [
                "strategy",
                "expected_bin_edges"
            ],
            "test_percentile_numeric_stability": []
        },
        "sklearn.preprocessing.tests.test_common": {
            "_get_valid_samples_by_column": [
                "X",
                "col"
            ],
            "test_missing_value_handling": [
                "est",
                "func",
                "support_sparse",
                "strictly_positive"
            ]
        },
        "sklearn.ensemble.bagging": {
            "_generate_indices": [
                "random_state",
                "bootstrap",
                "n_population",
                "n_samples"
            ],
            "_generate_bagging_indices": [
                "random_state",
                "bootstrap_features",
                "bootstrap_samples",
                "n_features",
                "n_samples",
                "max_features",
                "max_samples"
            ],
            "_parallel_build_estimators": [
                "n_estimators",
                "ensemble",
                "X",
                "y",
                "sample_weight",
                "seeds",
                "total_n_estimators",
                "verbose"
            ],
            "_parallel_predict_proba": [
                "estimators",
                "estimators_features",
                "X",
                "n_classes"
            ],
            "_parallel_predict_log_proba": [
                "estimators",
                "estimators_features",
                "X",
                "n_classes"
            ],
            "_parallel_decision_function": [
                "estimators",
                "estimators_features",
                "X"
            ],
            "_parallel_predict_regression": [
                "estimators",
                "estimators_features",
                "X"
            ],
            "BaseBagging": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "max_samples",
                    "max_features",
                    "bootstrap",
                    "bootstrap_features",
                    "oob_score",
                    "warm_start",
                    "n_jobs",
                    "random_state",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_parallel_args": [
                    "self"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "max_samples",
                    "max_depth",
                    "sample_weight"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_y": [
                    "self",
                    "y"
                ],
                "_get_estimators_indices": [
                    "self"
                ],
                "estimators_samples_": [
                    "self"
                ]
            },
            "BaggingClassifier": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "max_samples",
                    "max_features",
                    "bootstrap",
                    "bootstrap_features",
                    "oob_score",
                    "warm_start",
                    "n_jobs",
                    "random_state",
                    "verbose"
                ],
                "_validate_estimator": [
                    "self"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_y": [
                    "self",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ]
            },
            "BaggingRegressor": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "max_samples",
                    "max_features",
                    "bootstrap",
                    "bootstrap_features",
                    "oob_score",
                    "warm_start",
                    "n_jobs",
                    "random_state",
                    "verbose"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_validate_estimator": [
                    "self"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.ensemble.iforest": {
            "_average_path_length": [
                "n_samples_leaf"
            ],
            "IsolationForest": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "max_samples",
                    "contamination",
                    "max_features",
                    "bootstrap",
                    "n_jobs",
                    "behaviour",
                    "random_state",
                    "verbose",
                    "warm_start"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_parallel_args": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "threshold_": [
                    "self"
                ],
                "_compute_chunked_score_samples": [
                    "self",
                    "X"
                ],
                "_compute_score_samples": [
                    "self",
                    "X",
                    "subsample_features"
                ]
            }
        },
        "sklearn.ensemble.forest": {
            "_generate_sample_indices": [
                "random_state",
                "n_samples"
            ],
            "_generate_unsampled_indices": [
                "random_state",
                "n_samples"
            ],
            "_parallel_build_trees": [
                "tree",
                "forest",
                "X",
                "y",
                "sample_weight",
                "tree_idx",
                "n_trees",
                "verbose",
                "class_weight"
            ],
            "_accumulate_prediction": [
                "predict",
                "X",
                "out",
                "lock"
            ],
            "BaseForest": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start",
                    "class_weight"
                ],
                "apply": [
                    "self",
                    "X"
                ],
                "decision_path": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_y_class_weight": [
                    "self",
                    "y"
                ],
                "_validate_X_predict": [
                    "self",
                    "X"
                ],
                "feature_importances_": [
                    "self"
                ]
            },
            "ForestClassifier": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start",
                    "class_weight"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_y_class_weight": [
                    "self",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "ForestRegressor": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RandomForestClassifier": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start",
                    "class_weight"
                ]
            },
            "RandomForestRegressor": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start"
                ]
            },
            "ExtraTreesClassifier": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start",
                    "class_weight"
                ]
            },
            "ExtraTreesRegressor": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_features",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start"
                ]
            },
            "RandomTreesEmbedding": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_leaf_nodes",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "sparse_output",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "warm_start"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.ensemble": {},
        "sklearn.ensemble._gb_losses": {
            "LossFunction": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions"
                ],
                "update_terminal_regions": [
                    "self",
                    "tree",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight",
                    "sample_mask",
                    "learning_rate",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ],
                "get_init_raw_predictions": [
                    "self",
                    "X",
                    "estimator"
                ]
            },
            "RegressionLossFunction": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "check_init_estimator": [
                    "self",
                    "estimator"
                ],
                "get_init_raw_predictions": [
                    "self",
                    "X",
                    "estimator"
                ]
            },
            "LeastSquaresError": {
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions"
                ],
                "update_terminal_regions": [
                    "self",
                    "tree",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight",
                    "sample_mask",
                    "learning_rate",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ]
            },
            "LeastAbsoluteError": {
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ]
            },
            "HuberLossFunction": {
                "__init__": [
                    "self",
                    "n_classes",
                    "alpha"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ]
            },
            "QuantileLossFunction": {
                "__init__": [
                    "self",
                    "n_classes",
                    "alpha"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ]
            },
            "ClassificationLossFunction": {
                "_raw_prediction_to_proba": [
                    "self",
                    "raw_predictions"
                ],
                "_raw_prediction_to_decision": [
                    "self",
                    "raw_predictions"
                ],
                "check_init_estimator": [
                    "self",
                    "estimator"
                ]
            },
            "BinomialDeviance": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ],
                "_raw_prediction_to_proba": [
                    "self",
                    "raw_predictions"
                ],
                "_raw_prediction_to_decision": [
                    "self",
                    "raw_predictions"
                ],
                "get_init_raw_predictions": [
                    "self",
                    "X",
                    "estimator"
                ]
            },
            "MultinomialDeviance": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ],
                "_raw_prediction_to_proba": [
                    "self",
                    "raw_predictions"
                ],
                "_raw_prediction_to_decision": [
                    "self",
                    "raw_predictions"
                ],
                "get_init_raw_predictions": [
                    "self",
                    "X",
                    "estimator"
                ]
            },
            "ExponentialLoss": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "raw_predictions",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "raw_predictions"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "raw_predictions",
                    "sample_weight"
                ],
                "_raw_prediction_to_proba": [
                    "self",
                    "raw_predictions"
                ],
                "_raw_prediction_to_decision": [
                    "self",
                    "raw_predictions"
                ],
                "get_init_raw_predictions": [
                    "self",
                    "X",
                    "estimator"
                ]
            }
        },
        "sklearn.ensemble.voting": {
            "_parallel_fit_estimator": [
                "estimator",
                "X",
                "y",
                "sample_weight"
            ],
            "_BaseVoting": {
                "named_estimators": [
                    "self"
                ],
                "_weights_not_none": [
                    "self"
                ],
                "_predict": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "set_params": [
                    "self"
                ],
                "get_params": [
                    "self",
                    "deep"
                ]
            },
            "VotingClassifier": {
                "__init__": [
                    "self",
                    "estimators",
                    "voting",
                    "weights",
                    "n_jobs",
                    "flatten_transform"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_collect_probas": [
                    "self",
                    "X"
                ],
                "_predict_proba": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "VotingRegressor": {
                "__init__": [
                    "self",
                    "estimators",
                    "weights",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.weight_boosting": {
            "_samme_proba": [
                "estimator",
                "n_classes",
                "X"
            ],
            "BaseWeightBoosting": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "learning_rate",
                    "random_state"
                ],
                "_validate_data": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_boost": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight",
                    "random_state"
                ],
                "staged_score": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "feature_importances_": [
                    "self"
                ]
            },
            "AdaBoostClassifier": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "learning_rate",
                    "algorithm",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_validate_estimator": [
                    "self"
                ],
                "_boost": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight",
                    "random_state"
                ],
                "_boost_real": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight",
                    "random_state"
                ],
                "_boost_discrete": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight",
                    "random_state"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "staged_decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "staged_predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "AdaBoostRegressor": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "learning_rate",
                    "loss",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_validate_estimator": [
                    "self"
                ],
                "_boost": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight",
                    "random_state"
                ],
                "_get_median_predict": [
                    "self",
                    "X",
                    "limit"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.base": {
            "_set_random_states": [
                "estimator",
                "random_state"
            ],
            "_partition_estimators": [
                "n_estimators",
                "n_jobs"
            ],
            "BaseEnsemble": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params"
                ],
                "_validate_estimator": [
                    "self",
                    "default"
                ],
                "_make_estimator": [
                    "self",
                    "append",
                    "random_state"
                ],
                "__len__": [
                    "self"
                ],
                "__getitem__": [
                    "self",
                    "index"
                ],
                "__iter__": [
                    "self"
                ]
            }
        },
        "sklearn.ensemble.gradient_boosting": {
            "QuantileEstimator": {
                "__init__": [
                    "self",
                    "alpha"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "MeanEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "LogOddsEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "ScaledLogOddsEstimator": {},
            "PriorProbabilityEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "ZeroEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "LossFunction": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "y_pred"
                ],
                "update_terminal_regions": [
                    "self",
                    "tree",
                    "X",
                    "y",
                    "residual",
                    "y_pred",
                    "sample_weight",
                    "sample_mask",
                    "learning_rate",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ]
            },
            "RegressionLossFunction": {
                "__init__": [
                    "self",
                    "n_classes"
                ]
            },
            "LeastSquaresError": {
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "update_terminal_regions": [
                    "self",
                    "tree",
                    "X",
                    "y",
                    "residual",
                    "y_pred",
                    "sample_weight",
                    "sample_mask",
                    "learning_rate",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ]
            },
            "LeastAbsoluteError": {
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ]
            },
            "HuberLossFunction": {
                "__init__": [
                    "self",
                    "n_classes",
                    "alpha"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ]
            },
            "QuantileLossFunction": {
                "__init__": [
                    "self",
                    "n_classes",
                    "alpha"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ]
            },
            "ClassificationLossFunction": {
                "_score_to_proba": [
                    "self",
                    "score"
                ],
                "_score_to_decision": [
                    "self",
                    "score"
                ]
            },
            "BinomialDeviance": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ],
                "_score_to_proba": [
                    "self",
                    "score"
                ],
                "_score_to_decision": [
                    "self",
                    "score"
                ]
            },
            "MultinomialDeviance": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ],
                "_score_to_proba": [
                    "self",
                    "score"
                ],
                "_score_to_decision": [
                    "self",
                    "score"
                ]
            },
            "ExponentialLoss": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred",
                    "sample_weight"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred",
                    "sample_weight"
                ],
                "_score_to_proba": [
                    "self",
                    "score"
                ],
                "_score_to_decision": [
                    "self",
                    "score"
                ]
            },
            "VerboseReporter": {
                "__init__": [
                    "self",
                    "verbose"
                ],
                "init": [
                    "self",
                    "est",
                    "begin_at_stage"
                ],
                "update": [
                    "self",
                    "j",
                    "est"
                ]
            },
            "BaseGradientBoosting": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "n_estimators",
                    "criterion",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_depth",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "init",
                    "subsample",
                    "max_features",
                    "random_state",
                    "alpha",
                    "verbose",
                    "max_leaf_nodes",
                    "warm_start",
                    "presort",
                    "validation_fraction",
                    "n_iter_no_change",
                    "tol"
                ],
                "_fit_stage": [
                    "self",
                    "i",
                    "X",
                    "y",
                    "raw_predictions",
                    "sample_weight",
                    "sample_mask",
                    "random_state",
                    "X_idx_sorted",
                    "X_csc",
                    "X_csr"
                ],
                "_check_params": [
                    "self"
                ],
                "_init_state": [
                    "self"
                ],
                "_clear_state": [
                    "self"
                ],
                "_resize_state": [
                    "self"
                ],
                "_is_initialized": [
                    "self"
                ],
                "_check_initialized": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "monitor"
                ],
                "_fit_stages": [
                    "self",
                    "X",
                    "y",
                    "raw_predictions",
                    "sample_weight",
                    "random_state",
                    "X_val",
                    "y_val",
                    "sample_weight_val",
                    "begin_at_stage",
                    "monitor",
                    "X_idx_sorted"
                ],
                "_make_estimator": [
                    "self",
                    "append"
                ],
                "_raw_predict_init": [
                    "self",
                    "X"
                ],
                "_raw_predict": [
                    "self",
                    "X"
                ],
                "_staged_raw_predict": [
                    "self",
                    "X"
                ],
                "feature_importances_": [
                    "self"
                ],
                "_validate_y": [
                    "self",
                    "y",
                    "sample_weight"
                ],
                "apply": [
                    "self",
                    "X"
                ]
            },
            "GradientBoostingClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "n_estimators",
                    "subsample",
                    "criterion",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_depth",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "init",
                    "random_state",
                    "max_features",
                    "verbose",
                    "max_leaf_nodes",
                    "warm_start",
                    "presort",
                    "validation_fraction",
                    "n_iter_no_change",
                    "tol"
                ],
                "_validate_y": [
                    "self",
                    "y",
                    "sample_weight"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "staged_decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "staged_predict_proba": [
                    "self",
                    "X"
                ]
            },
            "GradientBoostingRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "n_estimators",
                    "subsample",
                    "criterion",
                    "min_samples_split",
                    "min_samples_leaf",
                    "min_weight_fraction_leaf",
                    "max_depth",
                    "min_impurity_decrease",
                    "min_impurity_split",
                    "init",
                    "random_state",
                    "max_features",
                    "alpha",
                    "verbose",
                    "max_leaf_nodes",
                    "warm_start",
                    "presort",
                    "validation_fraction",
                    "n_iter_no_change",
                    "tol"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ],
                "apply": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.partial_dependence": {
            "_grid_from_X": [
                "X",
                "percentiles",
                "grid_resolution"
            ],
            "partial_dependence": [
                "gbrt",
                "target_variables",
                "grid",
                "X",
                "percentiles",
                "grid_resolution"
            ],
            "plot_partial_dependence": [
                "gbrt",
                "X",
                "features",
                "feature_names",
                "label",
                "n_cols",
                "grid_resolution",
                "percentiles",
                "n_jobs",
                "verbose",
                "ax",
                "line_kw",
                "contour_kw"
            ]
        },
        "sklearn.ensemble.tests.test_forest": {
            "check_classification_toy": [
                "name"
            ],
            "test_classification_toy": [
                "name"
            ],
            "check_iris_criterion": [
                "name",
                "criterion"
            ],
            "test_iris": [
                "name",
                "criterion"
            ],
            "check_boston_criterion": [
                "name",
                "criterion"
            ],
            "test_boston": [
                "name",
                "criterion"
            ],
            "check_regressor_attributes": [
                "name"
            ],
            "test_regressor_attributes": [
                "name"
            ],
            "check_probability": [
                "name"
            ],
            "test_probability": [
                "name"
            ],
            "check_importances": [
                "name",
                "criterion",
                "dtype",
                "tolerance"
            ],
            "test_importances": [
                "dtype",
                "name",
                "criterion"
            ],
            "test_importances_asymptotic": [],
            "check_unfitted_feature_importances": [
                "name"
            ],
            "test_unfitted_feature_importances": [
                "name"
            ],
            "check_oob_score": [
                "name",
                "X",
                "y",
                "n_estimators"
            ],
            "test_oob_score_classifiers": [
                "name"
            ],
            "test_oob_score_regressors": [
                "name"
            ],
            "check_oob_score_raise_error": [
                "name"
            ],
            "test_oob_score_raise_error": [
                "name"
            ],
            "check_gridsearch": [
                "name"
            ],
            "test_gridsearch": [
                "name"
            ],
            "check_parallel": [
                "name",
                "X",
                "y"
            ],
            "test_parallel": [
                "name"
            ],
            "check_pickle": [
                "name",
                "X",
                "y"
            ],
            "test_pickle": [
                "name"
            ],
            "check_multioutput": [
                "name"
            ],
            "test_multioutput": [
                "name"
            ],
            "test_multioutput_string": [
                "name"
            ],
            "check_classes_shape": [
                "name"
            ],
            "test_classes_shape": [
                "name"
            ],
            "test_random_trees_dense_type": [],
            "test_random_trees_dense_equal": [],
            "test_random_hasher": [],
            "test_random_hasher_sparse_data": [],
            "test_parallel_train": [],
            "test_distribution": [],
            "check_max_leaf_nodes_max_depth": [
                "name"
            ],
            "test_max_leaf_nodes_max_depth": [
                "name"
            ],
            "check_min_samples_split": [
                "name"
            ],
            "test_min_samples_split": [
                "name"
            ],
            "check_min_samples_leaf": [
                "name"
            ],
            "test_min_samples_leaf": [
                "name"
            ],
            "check_min_weight_fraction_leaf": [
                "name"
            ],
            "test_min_weight_fraction_leaf": [
                "name"
            ],
            "check_sparse_input": [
                "name",
                "X",
                "X_sparse",
                "y"
            ],
            "test_sparse_input": [
                "name",
                "sparse_matrix"
            ],
            "check_memory_layout": [
                "name",
                "dtype"
            ],
            "test_memory_layout": [
                "name",
                "dtype"
            ],
            "check_1d_input": [
                "name",
                "X",
                "X_2d",
                "y"
            ],
            "test_1d_input": [
                "name"
            ],
            "check_class_weights": [
                "name"
            ],
            "test_class_weights": [
                "name"
            ],
            "check_class_weight_balanced_and_bootstrap_multi_output": [
                "name"
            ],
            "test_class_weight_balanced_and_bootstrap_multi_output": [
                "name"
            ],
            "check_class_weight_errors": [
                "name"
            ],
            "test_class_weight_errors": [
                "name"
            ],
            "check_warm_start": [
                "name",
                "random_state"
            ],
            "test_warm_start": [
                "name"
            ],
            "check_warm_start_clear": [
                "name"
            ],
            "test_warm_start_clear": [
                "name"
            ],
            "check_warm_start_smaller_n_estimators": [
                "name"
            ],
            "test_warm_start_smaller_n_estimators": [
                "name"
            ],
            "check_warm_start_equal_n_estimators": [
                "name"
            ],
            "test_warm_start_equal_n_estimators": [
                "name"
            ],
            "check_warm_start_oob": [
                "name"
            ],
            "test_warm_start_oob": [
                "name"
            ],
            "test_dtype_convert": [
                "n_classes"
            ],
            "check_decision_path": [
                "name"
            ],
            "test_decision_path": [
                "name"
            ],
            "test_min_impurity_split": [],
            "test_min_impurity_decrease": [],
            "test_nestimators_future_warning": [
                "forest"
            ],
            "test_backend_respected": [],
            "test_multi_target": [
                "name",
                "oob_score"
            ],
            "test_forest_feature_importances_sum": [],
            "test_forest_degenerate_feature_importances": [],
            "MyBackend": {
                "__init__": [
                    "self"
                ],
                "start_call": [
                    "self"
                ]
            }
        },
        "sklearn.ensemble.tests.test_weight_boosting": {
            "test_samme_proba": [],
            "test_oneclass_adaboost_proba": [],
            "test_classification_toy": [],
            "test_regression_toy": [],
            "test_iris": [],
            "test_boston": [],
            "test_staged_predict": [],
            "test_gridsearch": [],
            "test_pickle": [],
            "test_importances": [],
            "test_error": [],
            "test_base_estimator": [],
            "test_sample_weight_missing": [],
            "test_sparse_classification": [],
            "test_sparse_regression": [],
            "test_sample_weight_adaboost_regressor": [],
            "test_multidimensional_X": []
        },
        "sklearn.ensemble.tests.test_voting": {
            "test_estimator_init": [],
            "test_predictproba_hardvoting": [],
            "test_notfitted": [],
            "test_majority_label_iris": [],
            "test_tie_situation": [],
            "test_weights_iris": [],
            "test_weights_regressor": [],
            "test_predict_on_toy_problem": [],
            "test_predict_proba_on_toy_problem": [],
            "test_multilabel": [],
            "test_gridsearch": [],
            "test_parallel_fit": [],
            "test_sample_weight": [],
            "test_sample_weight_kwargs": [],
            "test_set_params": [],
            "test_set_estimator_none": [],
            "test_estimator_weights_format": [],
            "test_transform": []
        },
        "sklearn.ensemble.tests.test_gradient_boosting": {
            "check_classification_toy": [
                "presort",
                "loss"
            ],
            "test_classification_toy": [
                "presort",
                "loss"
            ],
            "test_classifier_parameter_checks": [],
            "test_regressor_parameter_checks": [],
            "test_loss_function": [],
            "check_classification_synthetic": [
                "presort",
                "loss"
            ],
            "test_classification_synthetic": [
                "presort",
                "loss"
            ],
            "check_boston": [
                "presort",
                "loss",
                "subsample"
            ],
            "test_boston": [
                "presort",
                "loss",
                "subsample"
            ],
            "check_iris": [
                "presort",
                "subsample",
                "sample_weight"
            ],
            "test_iris": [
                "presort",
                "subsample",
                "sample_weight"
            ],
            "test_regression_synthetic": [],
            "test_feature_importances": [],
            "test_probability_log": [],
            "test_check_inputs": [],
            "test_check_inputs_predict": [],
            "test_check_inputs_predict_stages": [],
            "test_check_max_features": [],
            "test_max_feature_regression": [],
            "test_feature_importance_regression": [],
            "test_max_feature_auto": [],
            "test_staged_predict": [],
            "test_staged_predict_proba": [],
            "test_staged_functions_defensive": [
                "Estimator"
            ],
            "test_serialization": [],
            "test_degenerate_targets": [],
            "test_quantile_loss": [],
            "test_symbol_labels": [],
            "test_float_class_labels": [],
            "test_shape_y": [],
            "test_mem_layout": [],
            "test_oob_improvement": [],
            "test_oob_improvement_raise": [],
            "test_oob_multilcass_iris": [],
            "test_verbose_output": [],
            "test_more_verbose_output": [],
            "test_warm_start": [
                "Cls"
            ],
            "test_warm_start_n_estimators": [
                "Cls"
            ],
            "test_warm_start_max_depth": [
                "Cls"
            ],
            "test_warm_start_clear": [
                "Cls"
            ],
            "test_warm_start_zero_n_estimators": [
                "Cls"
            ],
            "test_warm_start_smaller_n_estimators": [
                "Cls"
            ],
            "test_warm_start_equal_n_estimators": [
                "Cls"
            ],
            "test_warm_start_oob_switch": [
                "Cls"
            ],
            "test_warm_start_oob": [
                "Cls"
            ],
            "test_warm_start_sparse": [
                "Cls"
            ],
            "test_warm_start_fortran": [
                "Cls"
            ],
            "early_stopping_monitor": [
                "i",
                "est",
                "locals"
            ],
            "test_monitor_early_stopping": [
                "Cls"
            ],
            "test_complete_classification": [],
            "test_complete_regression": [],
            "test_zero_estimator_reg": [],
            "test_zero_estimator_clf": [],
            "test_max_leaf_nodes_max_depth": [
                "GBEstimator"
            ],
            "test_min_impurity_split": [
                "GBEstimator"
            ],
            "test_min_impurity_decrease": [
                "GBEstimator"
            ],
            "test_warm_start_wo_nestimators_change": [],
            "test_probability_exponential": [],
            "test_non_uniform_weights_toy_edge_case_reg": [],
            "test_non_uniform_weights_toy_edge_case_clf": [],
            "check_sparse_input": [
                "EstimatorClass",
                "X",
                "X_sparse",
                "y"
            ],
            "test_sparse_input": [
                "EstimatorClass",
                "sparse_matrix"
            ],
            "test_gradient_boosting_early_stopping": [],
            "test_gradient_boosting_validation_fraction": [],
            "test_early_stopping_stratified": [],
            "_make_multiclass": [],
            "test_gradient_boosting_with_init": [
                "gb",
                "dataset_maker",
                "init_estimator"
            ],
            "test_gradient_boosting_with_init_pipeline": [],
            "test_gradient_boosting_init_wrong_methods": [
                "estimator",
                "missing_method"
            ],
            "test_early_stopping_n_classes": [],
            "test_gbr_degenerate_feature_importances": [],
            "_NoSampleWeightWrapper": {
                "__init__": [
                    "self",
                    "est"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.tests.test_base": {
            "test_base": [],
            "test_base_zero_n_estimators": [],
            "test_base_not_int_n_estimators": [],
            "test_set_random_states": []
        },
        "sklearn.ensemble.tests": {},
        "sklearn.ensemble.tests.test_partial_dependence": {
            "test_partial_dependence_classifier": [],
            "test_partial_dependence_multiclass": [],
            "test_partial_dependence_regressor": [],
            "test_partial_dependence_sample_weight": [],
            "test_partial_dependecy_input": [],
            "test_plot_partial_dependence": [],
            "test_plot_partial_dependence_input": [],
            "test_plot_partial_dependence_multiclass": [],
            "test_warning_raised_partial_dependence": [],
            "test_warning_raised_partial_dependence_plot": []
        },
        "sklearn.ensemble.tests.test_gradient_boosting_loss_functions": {
            "test_binomial_deviance": [],
            "test_sample_weight_smoke": [],
            "test_sample_weight_init_estimators": [],
            "test_weighted_percentile": [],
            "test_weighted_percentile_equal": [],
            "test_weighted_percentile_zero_weight": [],
            "test_quantile_loss_function": [],
            "test_sample_weight_deviance": [],
            "test_init_raw_predictions_shapes": [],
            "test_init_raw_predictions_values": []
        },
        "sklearn.ensemble.tests.test_iforest": {
            "test_iforest": [],
            "test_iforest_sparse": [],
            "test_iforest_error": [],
            "test_recalculate_max_depth": [],
            "test_max_samples_attribute": [],
            "test_iforest_parallel_regression": [],
            "test_iforest_performance": [],
            "test_iforest_works": [
                "contamination"
            ],
            "test_max_samples_consistency": [],
            "test_iforest_subsampled_features": [],
            "test_iforest_average_path_length": [],
            "test_score_samples": [],
            "test_iforest_warm_start": [],
            "test_deprecation": [],
            "test_behaviour_param": [],
            "test_iforest_chunks_works1": [
                "mocked_get_chunk",
                "contamination",
                "n_predict_calls"
            ],
            "test_iforest_chunks_works2": [
                "mocked_get_chunk",
                "contamination",
                "n_predict_calls"
            ]
        },
        "sklearn.ensemble.tests.test_bagging": {
            "test_classification": [],
            "test_sparse_classification": [],
            "test_regression": [],
            "test_sparse_regression": [],
            "test_bootstrap_samples": [],
            "test_bootstrap_features": [],
            "test_probability": [],
            "test_oob_score_classification": [],
            "test_oob_score_regression": [],
            "test_single_estimator": [],
            "test_error": [],
            "test_parallel_classification": [],
            "test_parallel_regression": [],
            "test_gridsearch": [],
            "test_base_estimator": [],
            "test_bagging_with_pipeline": [],
            "test_bagging_sample_weight_unsupported_but_passed": [],
            "test_warm_start": [
                "random_state"
            ],
            "test_warm_start_smaller_n_estimators": [],
            "test_warm_start_equal_n_estimators": [],
            "test_warm_start_equivalence": [],
            "test_warm_start_with_oob_score_fails": [],
            "test_oob_score_removed_on_warm_start": [],
            "test_oob_score_consistency": [],
            "test_estimators_samples": [],
            "test_estimators_samples_deterministic": [],
            "test_max_samples_consistency": [],
            "test_set_oob_score_label_encoding": [],
            "replace": [
                "X"
            ],
            "test_bagging_regressor_with_missing_inputs": [],
            "test_bagging_classifier_with_missing_inputs": [],
            "test_bagging_small_max_features": [],
            "DummySizeEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "DummyZeroEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble._hist_gradient_boosting.grower": {
            "_fill_predictor_node_array": [
                "predictor_nodes",
                "grower_node",
                "bin_thresholds",
                "next_free_idx"
            ],
            "TreeNode": {
                "__init__": [
                    "self",
                    "depth",
                    "sample_indices",
                    "sum_gradients",
                    "sum_hessians",
                    "parent"
                ],
                "__lt__": [
                    "self",
                    "other_node"
                ]
            },
            "TreeGrower": {
                "__init__": [
                    "self",
                    "X_binned",
                    "gradients",
                    "hessians",
                    "max_leaf_nodes",
                    "max_depth",
                    "min_samples_leaf",
                    "min_gain_to_split",
                    "max_bins",
                    "actual_n_bins",
                    "l2_regularization",
                    "min_hessian_to_split",
                    "shrinkage"
                ],
                "_validate_parameters": [
                    "self",
                    "X_binned",
                    "max_leaf_nodes",
                    "max_depth",
                    "min_samples_leaf",
                    "min_gain_to_split",
                    "l2_regularization",
                    "min_hessian_to_split"
                ],
                "grow": [
                    "self"
                ],
                "_intilialize_root": [
                    "self",
                    "gradients",
                    "hessians",
                    "hessians_are_constant"
                ],
                "_compute_best_split_and_push": [
                    "self",
                    "node"
                ],
                "split_next": [
                    "self"
                ],
                "_finalize_leaf": [
                    "self",
                    "node"
                ],
                "_finalize_splittable_nodes": [
                    "self"
                ],
                "make_predictor": [
                    "self",
                    "bin_thresholds"
                ]
            }
        },
        "sklearn.ensemble._hist_gradient_boosting.predictor": {
            "TreePredictor": {
                "__init__": [
                    "self",
                    "nodes"
                ],
                "get_n_leaf_nodes": [
                    "self"
                ],
                "get_max_depth": [
                    "self"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_binned": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble._hist_gradient_boosting.binning": {
            "_find_binning_thresholds": [
                "data",
                "max_bins",
                "subsample",
                "random_state"
            ],
            "_BinMapper": {
                "__init__": [
                    "self",
                    "max_bins",
                    "subsample",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble._hist_gradient_boosting": {},
        "sklearn.ensemble._hist_gradient_boosting.loss": {
            "BaseLoss": {
                "init_gradients_and_hessians": [
                    "self",
                    "n_samples",
                    "prediction_dim"
                ],
                "get_baseline_prediction": [
                    "self",
                    "y_train",
                    "prediction_dim"
                ],
                "update_gradients_and_hessians": [
                    "self",
                    "gradients",
                    "hessians",
                    "y_true",
                    "raw_predictions"
                ]
            },
            "LeastSquares": {
                "__call__": [
                    "self",
                    "y_true",
                    "raw_predictions",
                    "average"
                ],
                "get_baseline_prediction": [
                    "self",
                    "y_train",
                    "prediction_dim"
                ],
                "inverse_link_function": [
                    "raw_predictions"
                ],
                "update_gradients_and_hessians": [
                    "self",
                    "gradients",
                    "hessians",
                    "y_true",
                    "raw_predictions"
                ]
            },
            "BinaryCrossEntropy": {
                "__call__": [
                    "self",
                    "y_true",
                    "raw_predictions",
                    "average"
                ],
                "get_baseline_prediction": [
                    "self",
                    "y_train",
                    "prediction_dim"
                ],
                "update_gradients_and_hessians": [
                    "self",
                    "gradients",
                    "hessians",
                    "y_true",
                    "raw_predictions"
                ],
                "predict_proba": [
                    "self",
                    "raw_predictions"
                ]
            },
            "CategoricalCrossEntropy": {
                "__call__": [
                    "self",
                    "y_true",
                    "raw_predictions",
                    "average"
                ],
                "get_baseline_prediction": [
                    "self",
                    "y_train",
                    "prediction_dim"
                ],
                "update_gradients_and_hessians": [
                    "self",
                    "gradients",
                    "hessians",
                    "y_true",
                    "raw_predictions"
                ],
                "predict_proba": [
                    "self",
                    "raw_predictions"
                ]
            }
        },
        "sklearn.ensemble._hist_gradient_boosting.gradient_boosting": {
            "BaseHistGradientBoosting": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "max_iter",
                    "max_leaf_nodes",
                    "max_depth",
                    "min_samples_leaf",
                    "l2_regularization",
                    "max_bins",
                    "scoring",
                    "validation_fraction",
                    "n_iter_no_change",
                    "tol",
                    "verbose",
                    "random_state"
                ],
                "_validate_parameters": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_check_early_stopping_scorer": [
                    "self",
                    "X_binned_small_train",
                    "y_small_train",
                    "X_binned_val",
                    "y_val"
                ],
                "_check_early_stopping_loss": [
                    "self",
                    "raw_predictions",
                    "y_train",
                    "raw_predictions_val",
                    "y_val"
                ],
                "_should_stop": [
                    "self",
                    "scores"
                ],
                "_print_iteration_stats": [
                    "self",
                    "iteration_start_time"
                ],
                "_raw_predict": [
                    "self",
                    "X"
                ],
                "_get_loss": [
                    "self"
                ],
                "_encode_y": [
                    "self",
                    "y"
                ],
                "n_iter_": [
                    "self"
                ]
            },
            "HistGradientBoostingRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "max_iter",
                    "max_leaf_nodes",
                    "max_depth",
                    "min_samples_leaf",
                    "l2_regularization",
                    "max_bins",
                    "scoring",
                    "validation_fraction",
                    "n_iter_no_change",
                    "tol",
                    "verbose",
                    "random_state"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_encode_y": [
                    "self",
                    "y"
                ],
                "_get_loss": [
                    "self"
                ]
            },
            "HistGradientBoostingClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "max_iter",
                    "max_leaf_nodes",
                    "max_depth",
                    "min_samples_leaf",
                    "l2_regularization",
                    "max_bins",
                    "scoring",
                    "validation_fraction",
                    "n_iter_no_change",
                    "tol",
                    "verbose",
                    "random_state"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "_encode_y": [
                    "self",
                    "y"
                ],
                "_get_loss": [
                    "self"
                ]
            }
        },
        "scikits": {},
        "scikits.learn.lda": {},
        "scikits.learn.label_propagation": {},
        "scikits.learn.naive_bayes": {},
        "scikits.learn": {},
        "scikits.learn.neighbors": {},
        "scikits.learn.grid_search": {},
        "scikits.learn.ball_tree": {},
        "scikits.learn.base": {},
        "scikits.learn.qda": {},
        "scikits.learn.pipeline": {},
        "scikits.learn.cross_val": {}
    }
}