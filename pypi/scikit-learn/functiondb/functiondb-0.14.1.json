{
    "0.14.1": {
        "sklearn.multiclass": {
            "_fit_binary": [
                "estimator",
                "X",
                "y",
                "classes"
            ],
            "_predict_binary": [
                "estimator",
                "X"
            ],
            "_check_estimator": [
                "estimator"
            ],
            "fit_ovr": [
                "estimator",
                "X",
                "y",
                "n_jobs"
            ],
            "predict_ovr": [
                "estimators",
                "label_binarizer",
                "X"
            ],
            "predict_proba_ovr": [
                "estimators",
                "X",
                "is_multilabel"
            ],
            "_fit_ovo_binary": [
                "estimator",
                "X",
                "y",
                "i",
                "j"
            ],
            "fit_ovo": [
                "estimator",
                "X",
                "y",
                "n_jobs"
            ],
            "predict_ovo": [
                "estimators",
                "classes",
                "X"
            ],
            "fit_ecoc": [
                "estimator",
                "X",
                "y",
                "code_size",
                "random_state",
                "n_jobs"
            ],
            "predict_ecoc": [
                "estimators",
                "classes",
                "code_book",
                "X"
            ],
            "_ConstantPredictor": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ]
            },
            "OneVsRestClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_check_is_fitted": [
                    "self"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "multilabel_": [
                    "self"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "classes_": [
                    "self"
                ],
                "coef_": [
                    "self"
                ],
                "intercept_": [
                    "self"
                ]
            },
            "OneVsOneClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "OutputCodeClassifier": {
                "__init__": [
                    "self",
                    "estimator",
                    "code_size",
                    "random_state",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.hmm": {
            "normalize": [
                "A",
                "axis"
            ],
            "_BaseHMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "startprob",
                    "transmat",
                    "startprob_prior",
                    "transmat_prior",
                    "algorithm",
                    "random_state",
                    "n_iter",
                    "thresh",
                    "params",
                    "init_params"
                ],
                "eval": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "obs"
                ],
                "score": [
                    "self",
                    "obs"
                ],
                "_decode_viterbi": [
                    "self",
                    "obs"
                ],
                "_decode_map": [
                    "self",
                    "obs"
                ],
                "decode": [
                    "self",
                    "obs",
                    "algorithm"
                ],
                "predict": [
                    "self",
                    "obs",
                    "algorithm"
                ],
                "predict_proba": [
                    "self",
                    "obs"
                ],
                "sample": [
                    "self",
                    "n",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "obs"
                ],
                "_get_algorithm": [
                    "self"
                ],
                "_set_algorithm": [
                    "self",
                    "algorithm"
                ],
                "_get_startprob": [
                    "self"
                ],
                "_set_startprob": [
                    "self",
                    "startprob"
                ],
                "_get_transmat": [
                    "self"
                ],
                "_set_transmat": [
                    "self",
                    "transmat"
                ],
                "_do_viterbi_pass": [
                    "self",
                    "framelogprob"
                ],
                "_do_forward_pass": [
                    "self",
                    "framelogprob"
                ],
                "_do_backward_pass": [
                    "self",
                    "framelogprob"
                ],
                "_compute_log_likelihood": [
                    "self",
                    "obs"
                ],
                "_generate_sample_from_state": [
                    "self",
                    "state",
                    "random_state"
                ],
                "_init": [
                    "self",
                    "obs",
                    "params"
                ],
                "_initialize_sufficient_statistics": [
                    "self"
                ],
                "_accumulate_sufficient_statistics": [
                    "self",
                    "stats",
                    "seq",
                    "framelogprob",
                    "posteriors",
                    "fwdlattice",
                    "bwdlattice",
                    "params"
                ],
                "_do_mstep": [
                    "self",
                    "stats",
                    "params"
                ]
            },
            "GaussianHMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "covariance_type",
                    "startprob",
                    "transmat",
                    "startprob_prior",
                    "transmat_prior",
                    "algorithm",
                    "means_prior",
                    "means_weight",
                    "covars_prior",
                    "covars_weight",
                    "random_state",
                    "n_iter",
                    "thresh",
                    "params",
                    "init_params"
                ],
                "covariance_type": [
                    "self"
                ],
                "_get_means": [
                    "self"
                ],
                "_set_means": [
                    "self",
                    "means"
                ],
                "_get_covars": [
                    "self"
                ],
                "_set_covars": [
                    "self",
                    "covars"
                ],
                "_compute_log_likelihood": [
                    "self",
                    "obs"
                ],
                "_generate_sample_from_state": [
                    "self",
                    "state",
                    "random_state"
                ],
                "_init": [
                    "self",
                    "obs",
                    "params"
                ],
                "_initialize_sufficient_statistics": [
                    "self"
                ],
                "_accumulate_sufficient_statistics": [
                    "self",
                    "stats",
                    "obs",
                    "framelogprob",
                    "posteriors",
                    "fwdlattice",
                    "bwdlattice",
                    "params"
                ],
                "_do_mstep": [
                    "self",
                    "stats",
                    "params"
                ]
            },
            "MultinomialHMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "startprob",
                    "transmat",
                    "startprob_prior",
                    "transmat_prior",
                    "algorithm",
                    "random_state",
                    "n_iter",
                    "thresh",
                    "params",
                    "init_params"
                ],
                "_get_emissionprob": [
                    "self"
                ],
                "_set_emissionprob": [
                    "self",
                    "emissionprob"
                ],
                "_compute_log_likelihood": [
                    "self",
                    "obs"
                ],
                "_generate_sample_from_state": [
                    "self",
                    "state",
                    "random_state"
                ],
                "_init": [
                    "self",
                    "obs",
                    "params"
                ],
                "_initialize_sufficient_statistics": [
                    "self"
                ],
                "_accumulate_sufficient_statistics": [
                    "self",
                    "stats",
                    "obs",
                    "framelogprob",
                    "posteriors",
                    "fwdlattice",
                    "bwdlattice",
                    "params"
                ],
                "_do_mstep": [
                    "self",
                    "stats",
                    "params"
                ],
                "_check_input_symbols": [
                    "self",
                    "obs"
                ],
                "fit": [
                    "self",
                    "obs"
                ]
            },
            "GMMHMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "n_mix",
                    "startprob",
                    "transmat",
                    "startprob_prior",
                    "transmat_prior",
                    "algorithm",
                    "gmms",
                    "covariance_type",
                    "covars_prior",
                    "random_state",
                    "n_iter",
                    "thresh",
                    "params",
                    "init_params"
                ],
                "covariance_type": [
                    "self"
                ],
                "_compute_log_likelihood": [
                    "self",
                    "obs"
                ],
                "_generate_sample_from_state": [
                    "self",
                    "state",
                    "random_state"
                ],
                "_init": [
                    "self",
                    "obs",
                    "params"
                ],
                "_initialize_sufficient_statistics": [
                    "self"
                ],
                "_accumulate_sufficient_statistics": [
                    "self",
                    "stats",
                    "obs",
                    "framelogprob",
                    "posteriors",
                    "fwdlattice",
                    "bwdlattice",
                    "params"
                ],
                "_do_mstep": [
                    "self",
                    "stats",
                    "params"
                ]
            }
        },
        "sklearn.lda": {
            "LDA": {
                "__init__": [
                    "self",
                    "n_components",
                    "priors"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "store_covariance",
                    "tol"
                ],
                "scaling": [
                    "self"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn._build_utils": {
            "get_blas_info": []
        },
        "sklearn.random_projection": {
            "johnson_lindenstrauss_min_dim": [
                "n_samples",
                "eps"
            ],
            "_check_density": [
                "density",
                "n_features"
            ],
            "_check_input_size": [
                "n_components",
                "n_features"
            ],
            "gaussian_random_matrix": [
                "n_components",
                "n_features",
                "random_state"
            ],
            "sparse_random_matrix": [
                "n_components",
                "n_features",
                "density",
                "random_state"
            ],
            "BaseRandomProjection": {
                "__init__": [
                    "self",
                    "n_components",
                    "eps",
                    "dense_output",
                    "random_state"
                ],
                "_make_random_matrix": [
                    "n_components",
                    "n_features"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "GaussianRandomProjection": {
                "__init__": [
                    "self",
                    "n_components",
                    "eps",
                    "random_state"
                ],
                "_make_random_matrix": [
                    "self",
                    "n_components",
                    "n_features"
                ]
            },
            "SparseRandomProjection": {
                "__init__": [
                    "self",
                    "n_components",
                    "density",
                    "eps",
                    "dense_output",
                    "random_state"
                ],
                "_make_random_matrix": [
                    "self",
                    "n_components",
                    "n_features"
                ]
            }
        },
        "sklearn.isotonic": {
            "isotonic_regression": [
                "y",
                "sample_weight",
                "y_min",
                "y_max",
                "weight",
                "increasing"
            ],
            "IsotonicRegression": {
                "__init__": [
                    "self",
                    "y_min",
                    "y_max",
                    "increasing"
                ],
                "_check_fit_data": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "weight"
                ],
                "transform": [
                    "self",
                    "T"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "weight"
                ],
                "predict": [
                    "self",
                    "T"
                ]
            }
        },
        "sklearn.dummy": {
            "DummyClassifier": {
                "__init__": [
                    "self",
                    "strategy",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "DummyRegressor": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.pls": {},
        "sklearn.test_setup": {},
        "sklearn.kernel_approximation": {
            "RBFSampler": {
                "__init__": [
                    "self",
                    "gamma",
                    "n_components",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SkewedChi2Sampler": {
                "__init__": [
                    "self",
                    "skewedness",
                    "n_components",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "AdditiveChi2Sampler": {
                "__init__": [
                    "self",
                    "sample_steps",
                    "sample_interval"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_transform_dense": [
                    "self",
                    "X"
                ],
                "_transform_sparse": [
                    "self",
                    "X"
                ]
            },
            "Nystroem": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "coef0",
                    "degree",
                    "kernel_params",
                    "n_components",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_get_kernel_params": [
                    "self"
                ]
            }
        },
        "sklearn.cross_validation": {
            "_validate_shuffle_split": [
                "n",
                "test_size",
                "train_size"
            ],
            "_cross_val_score": [
                "estimator",
                "X",
                "y",
                "scorer",
                "train",
                "test",
                "verbose",
                "fit_params"
            ],
            "cross_val_score": [
                "estimator",
                "X",
                "y",
                "scoring",
                "cv",
                "n_jobs",
                "verbose",
                "fit_params",
                "score_func",
                "pre_dispatch"
            ],
            "_permutation_test_score": [
                "estimator",
                "X",
                "y",
                "cv",
                "scorer"
            ],
            "_shuffle": [
                "y",
                "labels",
                "random_state"
            ],
            "check_cv": [
                "cv",
                "X",
                "y",
                "classifier"
            ],
            "permutation_test_score": [
                "estimator",
                "X",
                "y",
                "score_func",
                "cv",
                "n_permutations",
                "n_jobs",
                "labels",
                "random_state",
                "verbose",
                "scoring"
            ],
            "train_test_split": [],
            "_PartitionIterator": {
                "__init__": [
                    "self",
                    "n",
                    "indices"
                ],
                "__iter__": [
                    "self"
                ],
                "_iter_test_masks": [
                    "self"
                ],
                "_iter_test_indices": [
                    "self"
                ],
                "_empty_mask": [
                    "self"
                ]
            },
            "LeaveOneOut": {
                "_iter_test_indices": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "LeavePOut": {
                "__init__": [
                    "self",
                    "n",
                    "p",
                    "indices"
                ],
                "_iter_test_indices": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "_BaseKFold": {
                "__init__": [
                    "self",
                    "n",
                    "n_folds",
                    "indices",
                    "k"
                ]
            },
            "KFold": {
                "__init__": [
                    "self",
                    "n",
                    "n_folds",
                    "indices",
                    "shuffle",
                    "random_state",
                    "k"
                ],
                "_iter_test_indices": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "StratifiedKFold": {
                "__init__": [
                    "self",
                    "y",
                    "n_folds",
                    "indices",
                    "k"
                ],
                "_iter_test_indices": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "LeaveOneLabelOut": {
                "__init__": [
                    "self",
                    "labels",
                    "indices"
                ],
                "_iter_test_masks": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "LeavePLabelOut": {
                "__init__": [
                    "self",
                    "labels",
                    "p",
                    "indices"
                ],
                "_iter_test_masks": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "Bootstrap": {
                "__init__": [
                    "self",
                    "n",
                    "n_iter",
                    "train_size",
                    "test_size",
                    "random_state",
                    "n_bootstraps"
                ],
                "__iter__": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "BaseShuffleSplit": {
                "__init__": [
                    "self",
                    "n",
                    "n_iter",
                    "test_size",
                    "train_size",
                    "indices",
                    "random_state",
                    "n_iterations"
                ],
                "__iter__": [
                    "self"
                ],
                "_iter_indices": [
                    "self"
                ]
            },
            "ShuffleSplit": {
                "_iter_indices": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "StratifiedShuffleSplit": {
                "__init__": [
                    "self",
                    "y",
                    "n_iter",
                    "test_size",
                    "train_size",
                    "indices",
                    "random_state",
                    "n_iterations"
                ],
                "_iter_indices": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            }
        },
        "sklearn.base": {
            "clone": [
                "estimator",
                "safe"
            ],
            "_pprint": [
                "params",
                "offset",
                "printer"
            ],
            "_get_sub_estimator": [
                "estimator"
            ],
            "is_classifier": [
                "estimator"
            ],
            "BaseEstimator": {
                "_get_param_names": [
                    "cls"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ],
                "__str__": [
                    "self"
                ]
            },
            "ClassifierMixin": {
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RegressorMixin": {
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "ClusterMixin": {
                "fit_predict": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "BiclusterMixin": {
                "biclusters_": [
                    "self"
                ],
                "get_indices": [
                    "self",
                    "i"
                ],
                "get_shape": [
                    "self",
                    "i"
                ],
                "get_submatrix": [
                    "self",
                    "i",
                    "data"
                ]
            },
            "TransformerMixin": {
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "MetaEstimatorMixin": {}
        },
        "sklearn.qda": {
            "QDA": {
                "__init__": [
                    "self",
                    "priors",
                    "reg_param"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "store_covariances",
                    "tol"
                ],
                "scalings": [
                    "self"
                ],
                "rotations": [
                    "self"
                ],
                "_decision_function": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.naive_bayes": {
            "BaseNB": {
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "GaussianNB": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            },
            "BaseDiscreteNB": {
                "_update_class_log_prior": [
                    "self",
                    "class_prior"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "class_prior"
                ],
                "_get_coef": [
                    "self"
                ],
                "_get_intercept": [
                    "self"
                ]
            },
            "MultinomialNB": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_prior",
                    "class_prior"
                ],
                "_count": [
                    "self",
                    "X",
                    "Y"
                ],
                "_update_feature_log_prob": [
                    "self"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            },
            "BernoulliNB": {
                "__init__": [
                    "self",
                    "alpha",
                    "binarize",
                    "fit_prior",
                    "class_prior"
                ],
                "_count": [
                    "self",
                    "X",
                    "Y"
                ],
                "_update_feature_log_prob": [
                    "self"
                ],
                "_joint_log_likelihood": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.grid_search": {
            "fit_grid_point": [
                "X",
                "y",
                "base_estimator",
                "parameters",
                "train",
                "test",
                "scorer",
                "verbose",
                "loss_func"
            ],
            "_check_param_grid": [
                "param_grid"
            ],
            "ParameterGrid": {
                "__init__": [
                    "self",
                    "param_grid"
                ],
                "__iter__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "IterGrid": {
                "__init__": [
                    "self",
                    "param_grid"
                ]
            },
            "ParameterSampler": {
                "__init__": [
                    "self",
                    "param_distributions",
                    "n_iter",
                    "random_state"
                ],
                "__iter__": [
                    "self"
                ],
                "__len__": [
                    "self"
                ]
            },
            "_CVScoreTuple": {
                "__repr__": [
                    "self"
                ]
            },
            "BaseSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "scoring",
                    "loss_func",
                    "score_func",
                    "fit_params",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self"
                ],
                "predict_proba": [
                    "self"
                ],
                "decision_function": [
                    "self"
                ],
                "transform": [
                    "self"
                ],
                "_check_estimator": [
                    "self"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "parameter_iterable"
                ]
            },
            "GridSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "param_grid",
                    "scoring",
                    "loss_func",
                    "score_func",
                    "fit_params",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RandomizedSearchCV": {
                "__init__": [
                    "self",
                    "estimator",
                    "param_distributions",
                    "n_iter",
                    "scoring",
                    "fit_params",
                    "n_jobs",
                    "iid",
                    "refit",
                    "cv",
                    "verbose",
                    "pre_dispatch",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn": {
            "setup_module": [
                "module"
            ]
        },
        "sklearn.pipeline": {
            "_fit_one_transformer": [
                "transformer",
                "X",
                "y"
            ],
            "_transform_one": [
                "transformer",
                "name",
                "X",
                "transformer_weights"
            ],
            "_fit_transform_one": [
                "transformer",
                "name",
                "X",
                "y",
                "transformer_weights"
            ],
            "Pipeline": {
                "__init__": [
                    "self",
                    "steps"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "_pre_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_pairwise": [
                    "self"
                ]
            },
            "FeatureUnion": {
                "__init__": [
                    "self",
                    "transformer_list",
                    "n_jobs",
                    "transformer_weights"
                ],
                "get_feature_names": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "get_params": [
                    "self",
                    "deep"
                ]
            }
        },
        "sklearn.manifold.isomap": {
            "Isomap": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "n_components",
                    "eigen_solver",
                    "tol",
                    "max_iter",
                    "path_method",
                    "neighbors_algorithm"
                ],
                "_fit_transform": [
                    "self",
                    "X"
                ],
                "reconstruction_error": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.manifold.mds": {
            "_smacof_single": [
                "similarities",
                "metric",
                "n_components",
                "init",
                "max_iter",
                "verbose",
                "eps",
                "random_state"
            ],
            "smacof": [
                "similarities",
                "metric",
                "n_components",
                "init",
                "n_init",
                "n_jobs",
                "max_iter",
                "verbose",
                "eps",
                "random_state"
            ],
            "MDS": {
                "__init__": [
                    "self",
                    "n_components",
                    "metric",
                    "n_init",
                    "max_iter",
                    "verbose",
                    "eps",
                    "n_jobs",
                    "random_state",
                    "dissimilarity"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "init",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "init",
                    "y"
                ]
            }
        },
        "sklearn.manifold.spectral_embedding_": {
            "_graph_connected_component": [
                "graph",
                "node_id"
            ],
            "_graph_is_connected": [
                "graph"
            ],
            "_set_diag": [
                "laplacian",
                "value"
            ],
            "spectral_embedding": [
                "adjacency",
                "n_components",
                "eigen_solver",
                "random_state",
                "eigen_tol",
                "norm_laplacian",
                "drop_first",
                "mode"
            ],
            "SpectralEmbedding": {
                "__init__": [
                    "self",
                    "n_components",
                    "affinity",
                    "gamma",
                    "random_state",
                    "eigen_solver",
                    "n_neighbors"
                ],
                "_pairwise": [
                    "self"
                ],
                "_get_affinity_matrix": [
                    "self",
                    "X",
                    "Y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.manifold.locally_linear": {
            "barycenter_weights": [
                "X",
                "Z",
                "reg"
            ],
            "barycenter_kneighbors_graph": [
                "X",
                "n_neighbors",
                "reg"
            ],
            "null_space": [
                "M",
                "k",
                "k_skip",
                "eigen_solver",
                "tol",
                "max_iter",
                "random_state"
            ],
            "locally_linear_embedding": [
                "X",
                "n_neighbors",
                "n_components",
                "reg",
                "eigen_solver",
                "tol",
                "max_iter",
                "method",
                "hessian_tol",
                "modified_tol",
                "random_state"
            ],
            "LocallyLinearEmbedding": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "n_components",
                    "reg",
                    "eigen_solver",
                    "tol",
                    "max_iter",
                    "method",
                    "hessian_tol",
                    "modified_tol",
                    "neighbors_algorithm",
                    "random_state"
                ],
                "_fit_transform": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.manifold": {},
        "sklearn.metrics.scorer": {
            "_deprecate_loss_and_score_funcs": [
                "loss_func",
                "score_func",
                "scoring",
                "score_overrides_loss"
            ],
            "make_scorer": [
                "score_func",
                "greater_is_better",
                "needs_proba",
                "needs_threshold"
            ],
            "_BaseScorer": {
                "__init__": [
                    "self",
                    "score_func",
                    "sign",
                    "kwargs"
                ],
                "__call__": [
                    "self",
                    "estimator",
                    "X",
                    "y"
                ],
                "__repr__": [
                    "self"
                ],
                "_factory_args": [
                    "self"
                ]
            },
            "_PredictScorer": {
                "__call__": [
                    "self",
                    "estimator",
                    "X",
                    "y_true"
                ]
            },
            "_ProbaScorer": {
                "__call__": [
                    "self",
                    "clf",
                    "X",
                    "y"
                ],
                "_factory_args": [
                    "self"
                ]
            },
            "_ThresholdScorer": {
                "__call__": [
                    "self",
                    "clf",
                    "X",
                    "y"
                ],
                "_factory_args": [
                    "self"
                ]
            }
        },
        "sklearn.metrics.metrics": {
            "_check_reg_targets": [
                "y_true",
                "y_pred"
            ],
            "_check_clf_targets": [
                "y_true",
                "y_pred"
            ],
            "auc": [
                "x",
                "y",
                "reorder"
            ],
            "hinge_loss": [
                "y_true",
                "pred_decision",
                "pos_label",
                "neg_label"
            ],
            "average_precision_score": [
                "y_true",
                "y_score"
            ],
            "auc_score": [
                "y_true",
                "y_score"
            ],
            "roc_auc_score": [
                "y_true",
                "y_score"
            ],
            "matthews_corrcoef": [
                "y_true",
                "y_pred"
            ],
            "_binary_clf_curve": [
                "y_true",
                "y_score",
                "pos_label"
            ],
            "precision_recall_curve": [
                "y_true",
                "probas_pred",
                "pos_label"
            ],
            "roc_curve": [
                "y_true",
                "y_score",
                "pos_label"
            ],
            "confusion_matrix": [
                "y_true",
                "y_pred",
                "labels"
            ],
            "zero_one_loss": [
                "y_true",
                "y_pred",
                "normalize"
            ],
            "zero_one": [
                "y_true",
                "y_pred",
                "normalize"
            ],
            "jaccard_similarity_score": [
                "y_true",
                "y_pred",
                "normalize"
            ],
            "accuracy_score": [
                "y_true",
                "y_pred",
                "normalize"
            ],
            "f1_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average"
            ],
            "fbeta_score": [
                "y_true",
                "y_pred",
                "beta",
                "labels",
                "pos_label",
                "average"
            ],
            "_tp_tn_fp_fn": [
                "y_true",
                "y_pred",
                "labels"
            ],
            "precision_recall_fscore_support": [
                "y_true",
                "y_pred",
                "beta",
                "labels",
                "pos_label",
                "average"
            ],
            "precision_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average"
            ],
            "recall_score": [
                "y_true",
                "y_pred",
                "labels",
                "pos_label",
                "average"
            ],
            "zero_one_score": [
                "y_true",
                "y_pred"
            ],
            "classification_report": [
                "y_true",
                "y_pred",
                "labels",
                "target_names"
            ],
            "hamming_loss": [
                "y_true",
                "y_pred",
                "classes"
            ],
            "mean_absolute_error": [
                "y_true",
                "y_pred"
            ],
            "mean_squared_error": [
                "y_true",
                "y_pred"
            ],
            "explained_variance_score": [
                "y_true",
                "y_pred"
            ],
            "r2_score": [
                "y_true",
                "y_pred"
            ],
            "log_loss": [
                "y_true",
                "y_pred",
                "eps",
                "normalize"
            ]
        },
        "sklearn.metrics.pairwise": {
            "check_pairwise_arrays": [
                "X",
                "Y"
            ],
            "euclidean_distances": [
                "X",
                "Y",
                "Y_norm_squared",
                "squared"
            ],
            "manhattan_distances": [
                "X",
                "Y",
                "sum_over_features",
                "size_threshold"
            ],
            "linear_kernel": [
                "X",
                "Y"
            ],
            "polynomial_kernel": [
                "X",
                "Y",
                "degree",
                "gamma",
                "coef0"
            ],
            "sigmoid_kernel": [
                "X",
                "Y",
                "gamma",
                "coef0"
            ],
            "rbf_kernel": [
                "X",
                "Y",
                "gamma"
            ],
            "cosine_similarity": [
                "X",
                "Y"
            ],
            "additive_chi2_kernel": [
                "X",
                "Y"
            ],
            "chi2_kernel": [
                "X",
                "Y",
                "gamma"
            ],
            "distance_metrics": [],
            "_parallel_pairwise": [
                "X",
                "Y",
                "func",
                "n_jobs"
            ],
            "pairwise_distances": [
                "X",
                "Y",
                "metric",
                "n_jobs"
            ],
            "kernel_metrics": [],
            "pairwise_kernels": [
                "X",
                "Y",
                "metric",
                "filter_params",
                "n_jobs"
            ]
        },
        "sklearn.metrics.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.metrics": {},
        "sklearn.metrics.tests.test_score_objects": {
            "test_make_scorer": [],
            "test_classification_scores": [],
            "test_regression_scorers": [],
            "test_thresholded_scorers": [],
            "test_unsupervised_scorers": [],
            "test_raises_on_score_list": []
        },
        "sklearn.metrics.tests.test_pairwise": {
            "test_pairwise_distances": [],
            "test_pairwise_parallel": [],
            "test_pairwise_kernels": [],
            "test_pairwise_kernels_filter_param": [],
            "test_euclidean_distances": [],
            "test_chi_square_kernel": [],
            "test_kernel_symmetry": [],
            "test_kernel_sparse": [],
            "test_linear_kernel": [],
            "test_rbf_kernel": [],
            "test_cosine_similarity": [],
            "test_check_dense_matrices": [],
            "test_check_XB_returned": [],
            "test_check_different_dimensions": [],
            "test_check_invalid_dimensions": [],
            "test_check_sparse_arrays": [],
            "tuplify": [
                "X"
            ],
            "test_check_tuple_input": [],
            "test_check_preserve_type": []
        },
        "sklearn.metrics.tests.test_metrics": {
            "make_prediction": [
                "dataset",
                "binary"
            ],
            "_auc": [
                "y_true",
                "y_score"
            ],
            "test_roc_curve": [],
            "test_roc_curve_end_points": [],
            "test_roc_returns_consistency": [],
            "test_roc_curve_multi": [],
            "test_roc_curve_confidence": [],
            "test_roc_curve_hard": [],
            "test_roc_curve_one_label": [],
            "test_auc": [],
            "test_auc_duplicate_values": [],
            "test_auc_errors": [],
            "test_auc_score_non_binary_class": [],
            "test_precision_recall_f1_score_binary": [],
            "test_precision_recall_f_binary_single_class": [],
            "test_average_precision_score_duplicate_values": [],
            "test_average_precision_score_tied_values": [],
            "test_precision_recall_fscore_support_errors": [],
            "test_confusion_matrix_binary": [],
            "test_matthews_corrcoef_nan": [],
            "test_precision_recall_f1_score_multiclass": [],
            "test_precision_recall_f1_score_multiclass_pos_label_none": [],
            "test_zero_precision_recall": [],
            "test_confusion_matrix_multiclass": [],
            "test_confusion_matrix_multiclass_subset_labels": [],
            "test_classification_report_multiclass": [],
            "test_classification_report_multiclass_with_string_label": [],
            "test_multilabel_classification_report": [],
            "test_precision_recall_curve": [],
            "_test_precision_recall_curve": [
                "y_true",
                "probas_pred"
            ],
            "test_precision_recall_curve_errors": [],
            "test_score_scale_invariance": [],
            "test_losses": [],
            "test_losses_at_limits": [],
            "test_r2_one_case_error": [],
            "test_symmetry": [],
            "test_sample_order_invariance": [],
            "test_format_invariance_with_1d_vectors": [],
            "test_invariance_string_vs_numbers_labels": [],
            "test_clf_single_sample": [],
            "test_hinge_loss_binary": [],
            "test_multioutput_regression": [],
            "test_multioutput_number_of_output_differ": [],
            "test_multioutput_regression_invariance_to_dimension_shuffling": [],
            "test_multilabel_representation_invariance": [],
            "test_multilabel_zero_one_loss_subset": [],
            "test_multilabel_hamming_loss": [],
            "test_multilabel_accuracy_score_subset_accuracy": [],
            "test_multilabel_jaccard_similarity_score": [],
            "test_normalize_option_binary_classification": [],
            "test_normalize_option_multiclasss_classification": [],
            "test_normalize_option_multilabel_classification": [],
            "test_precision_recall_f1_score_multilabel_1": [],
            "test_precision_recall_f1_score_multilabel_2": [],
            "test_precision_recall_f1_score_with_an_empty_prediction": [],
            "test_precision_recall_f1_no_labels": [],
            "test__check_clf_targets": [],
            "test__check_reg_targets": [],
            "test_log_loss": []
        },
        "sklearn.metrics.tests": {},
        "sklearn.metrics.cluster.supervised": {
            "comb2": [
                "n"
            ],
            "check_clusterings": [
                "labels_true",
                "labels_pred"
            ],
            "contingency_matrix": [
                "labels_true",
                "labels_pred",
                "eps"
            ],
            "adjusted_rand_score": [
                "labels_true",
                "labels_pred"
            ],
            "homogeneity_completeness_v_measure": [
                "labels_true",
                "labels_pred"
            ],
            "homogeneity_score": [
                "labels_true",
                "labels_pred"
            ],
            "completeness_score": [
                "labels_true",
                "labels_pred"
            ],
            "v_measure_score": [
                "labels_true",
                "labels_pred"
            ],
            "mutual_info_score": [
                "labels_true",
                "labels_pred",
                "contingency"
            ],
            "adjusted_mutual_info_score": [
                "labels_true",
                "labels_pred"
            ],
            "normalized_mutual_info_score": [
                "labels_true",
                "labels_pred"
            ],
            "entropy": [
                "labels"
            ]
        },
        "sklearn.metrics.cluster.unsupervised": {
            "silhouette_score": [
                "X",
                "labels",
                "metric",
                "sample_size",
                "random_state"
            ],
            "silhouette_samples": [
                "X",
                "labels",
                "metric"
            ],
            "_intra_cluster_distance": [
                "distances_row",
                "labels",
                "i"
            ],
            "_nearest_cluster_distance": [
                "distances_row",
                "labels",
                "i"
            ]
        },
        "sklearn.metrics.cluster.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.metrics.cluster": {},
        "sklearn.metrics.cluster.tests.test_unsupervised": {
            "test_silhouette": [],
            "test_no_nan": []
        },
        "sklearn.metrics.cluster.tests.test_supervised": {
            "test_error_messages_on_wrong_input": [],
            "test_perfect_matches": [],
            "test_homogeneous_but_not_complete_labeling": [],
            "test_complete_but_not_homogeneous_labeling": [],
            "test_not_complete_and_not_homogeneous_labeling": [],
            "test_non_consicutive_labels": [],
            "uniform_labelings_scores": [
                "score_func",
                "n_samples",
                "k_range",
                "n_runs",
                "seed"
            ],
            "test_adjustment_for_chance": [],
            "test_adjusted_mutual_info_score": [],
            "test_entropy": [],
            "test_contingency_matrix": [],
            "test_exactly_zero_info_score": [],
            "test_v_measure_and_mutual_information": [
                "seed"
            ]
        },
        "sklearn.metrics.cluster.tests": {},
        "sklearn.metrics.cluster.bicluster.bicluster_metrics": {
            "_check_rows_and_columns": [
                "a",
                "b"
            ],
            "_jaccard": [
                "a_rows",
                "a_cols",
                "b_rows",
                "b_cols"
            ],
            "_pairwise_similarity": [
                "a",
                "b",
                "similarity"
            ],
            "consensus_score": [
                "a",
                "b",
                "similarity"
            ]
        },
        "sklearn.metrics.cluster.bicluster": {},
        "sklearn.metrics.cluster.bicluster.tests.test_bicluster_metrics": {
            "test_jaccard": [],
            "test_consensus_score": []
        },
        "sklearn.metrics.cluster.bicluster.tests": {},
        "sklearn.ensemble.weight_boosting": {
            "_samme_proba": [
                "estimator",
                "n_classes",
                "X"
            ],
            "BaseWeightBoosting": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "learning_rate",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_check_fitted": [
                    "self"
                ],
                "_boost": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "staged_score": [
                    "self",
                    "X",
                    "y"
                ],
                "feature_importances_": [
                    "self"
                ]
            },
            "AdaBoostClassifier": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "learning_rate",
                    "algorithm",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_boost": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_boost_real": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_boost_discrete": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "staged_decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "staged_predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "AdaBoostRegressor": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "learning_rate",
                    "loss",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_boost": [
                    "self",
                    "iboost",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_get_median_predict": [
                    "self",
                    "X",
                    "limit"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.partial_dependence": {
            "_grid_from_X": [
                "X",
                "percentiles",
                "grid_resolution"
            ],
            "partial_dependence": [
                "gbrt",
                "target_variables",
                "grid",
                "X",
                "percentiles",
                "grid_resolution"
            ],
            "plot_partial_dependence": [
                "gbrt",
                "X",
                "features",
                "feature_names",
                "label",
                "n_cols",
                "grid_resolution",
                "percentiles",
                "n_jobs",
                "verbose",
                "ax",
                "line_kw",
                "contour_kw"
            ]
        },
        "sklearn.ensemble.base": {
            "BaseEnsemble": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params"
                ],
                "_make_estimator": [
                    "self",
                    "append"
                ],
                "__len__": [
                    "self"
                ],
                "__getitem__": [
                    "self",
                    "index"
                ],
                "__iter__": [
                    "self"
                ]
            }
        },
        "sklearn.ensemble.gradient_boosting": {
            "QuantileEstimator": {
                "__init__": [
                    "self",
                    "alpha"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "MeanEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "LogOddsEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "PriorProbabilityEstimator": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "LossFunction": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self",
                    "X",
                    "y"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "y_pred"
                ],
                "update_terminal_regions": [
                    "self",
                    "tree",
                    "X",
                    "y",
                    "residual",
                    "y_pred",
                    "sample_mask",
                    "learning_rate",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "RegressionLossFunction": {
                "__init__": [
                    "self",
                    "n_classes"
                ]
            },
            "LeastSquaresError": {
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "update_terminal_regions": [
                    "self",
                    "tree",
                    "X",
                    "y",
                    "residual",
                    "y_pred",
                    "sample_mask",
                    "learning_rate",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "LeastAbsoluteError": {
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "HuberLossFunction": {
                "__init__": [
                    "self",
                    "n_classes",
                    "alpha"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "QuantileLossFunction": {
                "__init__": [
                    "self",
                    "n_classes",
                    "alpha"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "BinomialDeviance": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "MultinomialDeviance": {
                "__init__": [
                    "self",
                    "n_classes"
                ],
                "init_estimator": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "y",
                    "pred"
                ],
                "negative_gradient": [
                    "self",
                    "y",
                    "pred",
                    "k"
                ],
                "_update_terminal_region": [
                    "self",
                    "tree",
                    "terminal_regions",
                    "leaf",
                    "X",
                    "y",
                    "residual",
                    "pred"
                ]
            },
            "BaseGradientBoosting": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "n_estimators",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_depth",
                    "init",
                    "subsample",
                    "max_features",
                    "random_state",
                    "alpha",
                    "verbose"
                ],
                "_fit_stage": [
                    "self",
                    "i",
                    "X",
                    "y",
                    "y_pred",
                    "sample_mask",
                    "random_state"
                ],
                "_check_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_make_estimator": [
                    "self",
                    "append"
                ],
                "_init_decision_function": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "staged_decision_function": [
                    "self",
                    "X"
                ],
                "feature_importances_": [
                    "self"
                ],
                "oob_score_": [
                    "self"
                ]
            },
            "GradientBoostingClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "n_estimators",
                    "subsample",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_depth",
                    "init",
                    "random_state",
                    "max_features",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_score_to_proba": [
                    "self",
                    "score"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "staged_predict_proba": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ]
            },
            "GradientBoostingRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "learning_rate",
                    "n_estimators",
                    "subsample",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_depth",
                    "init",
                    "random_state",
                    "max_features",
                    "alpha",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "staged_predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.ensemble": {},
        "sklearn.ensemble.forest": {
            "_parallel_build_trees": [
                "n_trees",
                "forest",
                "X",
                "y",
                "sample_weight",
                "seeds",
                "verbose"
            ],
            "_parallel_predict_proba": [
                "trees",
                "X",
                "n_classes",
                "n_outputs"
            ],
            "_parallel_predict_regression": [
                "trees",
                "X"
            ],
            "_partition_trees": [
                "forest"
            ],
            "BaseForest": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose"
                ],
                "apply": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_y": [
                    "self",
                    "y"
                ],
                "feature_importances_": [
                    "self"
                ]
            },
            "ForestClassifier": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_y": [
                    "self",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "ForestRegressor": {
                "__init__": [
                    "self",
                    "base_estimator",
                    "n_estimators",
                    "estimator_params",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_set_oob_score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RandomForestClassifier": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "min_density",
                    "compute_importances"
                ]
            },
            "RandomForestRegressor": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "min_density",
                    "compute_importances"
                ]
            },
            "ExtraTreesClassifier": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "min_density",
                    "compute_importances"
                ]
            },
            "ExtraTreesRegressor": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "criterion",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "bootstrap",
                    "oob_score",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "min_density",
                    "compute_importances"
                ]
            },
            "RandomTreesEmbedding": {
                "__init__": [
                    "self",
                    "n_estimators",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "n_jobs",
                    "random_state",
                    "verbose",
                    "min_density"
                ],
                "_set_oob_score": [],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.ensemble.tests.test_base": {
            "test_base": [],
            "test_error": []
        },
        "sklearn.ensemble.tests.test_partial_dependence": {
            "test_partial_dependence_classifier": [],
            "test_partial_dependence_multiclass": [],
            "test_partial_dependence_regressor": [],
            "test_partial_dependecy_input": [],
            "test_plot_partial_dependence": [],
            "test_plot_partial_dependence_input": [],
            "test_plot_partial_dependence_multiclass": []
        },
        "sklearn.ensemble.tests.test_forest": {
            "test_classification_toy": [],
            "test_iris": [],
            "test_boston": [],
            "test_regressor_attributes": [],
            "test_probability": [],
            "test_importances": [],
            "test_oob_score_classification": [],
            "test_oob_score_regression": [],
            "test_gridsearch": [],
            "test_parallel": [],
            "test_pickle": [],
            "test_multioutput": [],
            "test_classes_shape": [],
            "test_random_hasher": [],
            "test_parallel_train": []
        },
        "sklearn.ensemble.tests.test_gradient_boosting": {
            "test_classification_toy": [],
            "test_parameter_checks": [],
            "test_classification_synthetic": [],
            "test_boston": [],
            "test_iris": [],
            "test_regression_synthetic": [],
            "test_feature_importances": [],
            "test_probability": [],
            "test_check_inputs": [],
            "test_check_inputs_predict": [],
            "test_check_max_features": [],
            "test_max_feature_regression": [],
            "test_staged_predict": [],
            "test_staged_predict_proba": [],
            "test_serialization": [],
            "test_degenerate_targets": [],
            "test_quantile_loss": [],
            "test_symbol_labels": [],
            "test_float_class_labels": [],
            "test_shape_y": [],
            "test_mem_layout": [],
            "test_oob_score": [],
            "test_oob_improvement": [],
            "test_oob_improvement_raise": [],
            "test_oob_multilcass_iris": [],
            "test_verbose_output": [],
            "test_more_verbose_output": []
        },
        "sklearn.ensemble.tests.test_weight_boosting": {
            "test_classification_toy": [],
            "test_regression_toy": [],
            "test_iris": [],
            "test_boston": [],
            "test_staged_predict": [],
            "test_gridsearch": [],
            "test_pickle": [],
            "test_importances": [],
            "test_error": [],
            "test_base_estimator": []
        },
        "sklearn.ensemble.tests.test_gradient_boosting_loss_functions": {
            "test_binomial_deviance": [],
            "test_log_odds_estimator": []
        },
        "sklearn.ensemble.tests": {},
        "sklearn.gaussian_process.gaussian_process": {
            "l1_cross_distances": [
                "X"
            ],
            "GaussianProcess": {
                "__init__": [
                    "self",
                    "regr",
                    "corr",
                    "beta0",
                    "storage_mode",
                    "verbose",
                    "theta0",
                    "thetaL",
                    "thetaU",
                    "optimizer",
                    "random_start",
                    "normalize",
                    "nugget",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X",
                    "eval_MSE",
                    "batch_size"
                ],
                "reduced_likelihood_function": [
                    "self",
                    "theta"
                ],
                "_arg_max_reduced_likelihood_function": [
                    "self"
                ],
                "_check_params": [
                    "self",
                    "n_samples"
                ]
            }
        },
        "sklearn.gaussian_process.regression_models": {
            "constant": [
                "x"
            ],
            "linear": [
                "x"
            ],
            "quadratic": [
                "x"
            ]
        },
        "sklearn.gaussian_process.correlation_models": {
            "absolute_exponential": [
                "theta",
                "d"
            ],
            "squared_exponential": [
                "theta",
                "d"
            ],
            "generalized_exponential": [
                "theta",
                "d"
            ],
            "pure_nugget": [
                "theta",
                "d"
            ],
            "cubic": [
                "theta",
                "d"
            ],
            "linear": [
                "theta",
                "d"
            ]
        },
        "sklearn.gaussian_process": {},
        "sklearn.gaussian_process.tests.test_gaussian_process": {
            "test_1d": [
                "regr",
                "corr",
                "random_start",
                "beta0"
            ],
            "test_2d": [
                "regr",
                "corr",
                "random_start",
                "beta0"
            ],
            "test_wrong_number_of_outputs": [],
            "test_more_builtin_correlation_models": [
                "random_start"
            ],
            "test_ordinary_kriging": [],
            "test_no_normalize": []
        },
        "sklearn.gaussian_process.tests": {},
        "sklearn.feature_selection.rfe": {
            "RFE": {
                "__init__": [
                    "self",
                    "estimator",
                    "n_features_to_select",
                    "step",
                    "estimator_params",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "RFECV": {
                "__init__": [
                    "self",
                    "estimator",
                    "step",
                    "cv",
                    "scoring",
                    "loss_func",
                    "estimator_params",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.feature_selection.from_model": {
            "_LearntSelectorMixin": {
                "transform": [
                    "self",
                    "X",
                    "threshold"
                ]
            }
        },
        "sklearn.feature_selection.univariate_selection": {
            "_clean_nans": [
                "scores"
            ],
            "f_oneway": [],
            "f_classif": [
                "X",
                "y"
            ],
            "_chisquare": [
                "f_obs",
                "f_exp"
            ],
            "chi2": [
                "X",
                "y"
            ],
            "f_regression": [
                "X",
                "y",
                "center"
            ],
            "_BaseFilter": {
                "__init__": [
                    "self",
                    "score_func"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "_PvalueFilter": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "_ScoreFilter": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SelectPercentile": {
                "__init__": [
                    "self",
                    "score_func",
                    "percentile"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectKBest": {
                "__init__": [
                    "self",
                    "score_func",
                    "k"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectFpr": {
                "__init__": [
                    "self",
                    "score_func",
                    "alpha"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectFdr": {
                "__init__": [
                    "self",
                    "score_func",
                    "alpha"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "SelectFwe": {
                "__init__": [
                    "self",
                    "score_func",
                    "alpha"
                ],
                "_get_support_mask": [
                    "self"
                ]
            },
            "GenericUnivariateSelect": {
                "__init__": [
                    "self",
                    "score_func",
                    "mode",
                    "param"
                ],
                "_get_support_mask": [
                    "self"
                ]
            }
        },
        "sklearn.feature_selection.base": {
            "SelectorMixin": {
                "get_support": [
                    "self",
                    "indices"
                ],
                "_get_support_mask": [
                    "self"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.feature_selection": {},
        "sklearn.feature_selection.selector_mixin": {},
        "sklearn.feature_selection.tests.test_base": {
            "test_transform_dense": [],
            "test_transform_sparse": [],
            "test_inverse_transform_dense": [],
            "test_inverse_transform_sparse": [],
            "test_get_support": [],
            "StepSelector": {
                "__init__": [
                    "self",
                    "step"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_support_mask": [
                    "self"
                ]
            }
        },
        "sklearn.feature_selection.tests.test_rfe": {
            "test_rfe_set_params": [],
            "test_rfe": [],
            "test_rfecv": []
        },
        "sklearn.feature_selection.tests.test_chi2": {
            "mkchi2": [
                "k"
            ],
            "test_chi2": [],
            "test_chi2_coo": [],
            "test_chi2_negative": [],
            "test_chisquare": []
        },
        "sklearn.feature_selection.tests.test_from_model": {
            "test_transform_linear_model": [],
            "test_invalid_input": []
        },
        "sklearn.feature_selection.tests.test_feature_select": {
            "test_f_oneway_vs_scipy_stats": [],
            "test_f_oneway_ints": [],
            "test_f_classif": [],
            "test_f_regression": [],
            "test_f_regression_input_dtype": [],
            "test_f_classif_multi_class": [],
            "test_select_percentile_classif": [],
            "test_select_percentile_classif_sparse": [],
            "test_select_kbest_classif": [],
            "test_select_kbest_all": [],
            "test_select_fpr_classif": [],
            "test_select_fdr_classif": [],
            "test_select_fwe_classif": [],
            "assert_best_scores_kept": [
                "score_filter"
            ],
            "test_select_percentile_regression": [],
            "test_select_percentile_regression_full": [],
            "test_invalid_percentile": [],
            "test_select_kbest_regression": [],
            "test_select_fpr_regression": [],
            "test_select_fdr_regression": [],
            "test_select_fwe_regression": [],
            "test_selectkbest_tiebreaking": [],
            "test_selectpercentile_tiebreaking": [],
            "test_tied_pvalues": [],
            "test_nans": [],
            "test_score_func_error": []
        },
        "sklearn.feature_selection.tests": {},
        "sklearn.covariance.outlier_detection": {
            "OutlierDetectionMixin": {
                "__init__": [
                    "self",
                    "contamination"
                ],
                "decision_function": [
                    "self",
                    "X",
                    "raw_values"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "EllipticEnvelope": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "support_fraction",
                    "contamination",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "EllipticEnvelop": {}
        },
        "sklearn.covariance.shrunk_covariance_": {
            "shrunk_covariance": [
                "emp_cov",
                "shrinkage"
            ],
            "ledoit_wolf_shrinkage": [
                "X",
                "assume_centered",
                "block_size"
            ],
            "ledoit_wolf": [
                "X",
                "assume_centered",
                "block_size"
            ],
            "oas": [
                "X",
                "assume_centered"
            ],
            "ShrunkCovariance": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "shrinkage"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LedoitWolf": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "block_size"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "OAS": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.covariance.graph_lasso_": {
            "_objective": [
                "mle",
                "precision_",
                "alpha"
            ],
            "_dual_gap": [
                "emp_cov",
                "precision_",
                "alpha"
            ],
            "alpha_max": [
                "emp_cov"
            ],
            "graph_lasso": [
                "emp_cov",
                "alpha",
                "cov_init",
                "mode",
                "tol",
                "max_iter",
                "verbose",
                "return_costs",
                "eps"
            ],
            "graph_lasso_path": [
                "X",
                "alphas",
                "cov_init",
                "X_test",
                "mode",
                "tol",
                "max_iter",
                "verbose"
            ],
            "GraphLasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "mode",
                    "tol",
                    "max_iter",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "GraphLassoCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "n_refinements",
                    "cv",
                    "tol",
                    "max_iter",
                    "mode",
                    "n_jobs",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.covariance.robust_covariance": {
            "c_step": [
                "X",
                "n_support",
                "remaining_iterations",
                "initial_estimates",
                "verbose",
                "cov_computation_method",
                "random_state"
            ],
            "select_candidates": [
                "X",
                "n_support",
                "n_trials",
                "select",
                "n_iter",
                "verbose",
                "cov_computation_method",
                "random_state"
            ],
            "fast_mcd": [
                "X",
                "support_fraction",
                "cov_computation_method",
                "random_state"
            ],
            "MinCovDet": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered",
                    "support_fraction",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "correct_covariance": [
                    "self",
                    "data"
                ],
                "reweight_covariance": [
                    "self",
                    "data"
                ]
            }
        },
        "sklearn.covariance.empirical_covariance_": {
            "log_likelihood": [
                "emp_cov",
                "precision"
            ],
            "empirical_covariance": [
                "X",
                "assume_centered"
            ],
            "EmpiricalCovariance": {
                "__init__": [
                    "self",
                    "store_precision",
                    "assume_centered"
                ],
                "_set_covariance": [
                    "self",
                    "covariance"
                ],
                "get_precision": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "score": [
                    "self",
                    "X_test",
                    "y"
                ],
                "error_norm": [
                    "self",
                    "comp_cov",
                    "norm",
                    "scaling",
                    "squared"
                ],
                "mahalanobis": [
                    "self",
                    "observations"
                ]
            }
        },
        "sklearn.covariance": {},
        "sklearn.covariance.tests.test_robust_covariance": {
            "test_mcd": [],
            "launch_mcd_on_dataset": [
                "n_samples",
                "n_features",
                "n_outliers",
                "tol_loc",
                "tol_cov",
                "tol_support"
            ],
            "test_mcd_issue1127": [],
            "test_outlier_detection": []
        },
        "sklearn.covariance.tests.test_graph_lasso": {
            "test_graph_lasso": [
                "random_state"
            ],
            "test_graph_lasso_cv": [
                "random_state"
            ]
        },
        "sklearn.covariance.tests.test_covariance": {
            "test_covariance": [],
            "test_shrunk_covariance": [],
            "test_ledoit_wolf": [],
            "test_oas": []
        },
        "sklearn.covariance.tests": {},
        "sklearn.cross_decomposition.cca_": {
            "CCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "max_iter",
                    "tol",
                    "copy"
                ]
            }
        },
        "sklearn.cross_decomposition.pls_": {
            "_nipals_twoblocks_inner_loop": [
                "X",
                "Y",
                "mode",
                "max_iter",
                "tol",
                "norm_y_weights"
            ],
            "_svd_cross_product": [
                "X",
                "Y"
            ],
            "_center_scale_xy": [
                "X",
                "Y",
                "scale"
            ],
            "_PLS": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "deflation_mode",
                    "mode",
                    "algorithm",
                    "norm_y_weights",
                    "max_iter",
                    "tol",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "transform": [
                    "self",
                    "X",
                    "Y",
                    "copy"
                ],
                "predict": [
                    "self",
                    "X",
                    "copy"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "PLSRegression": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "max_iter",
                    "tol",
                    "copy"
                ]
            },
            "PLSCanonical": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "algorithm",
                    "max_iter",
                    "tol",
                    "copy"
                ]
            },
            "PLSSVD": {
                "__init__": [
                    "self",
                    "n_components",
                    "scale",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "transform": [
                    "self",
                    "X",
                    "Y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.cross_decomposition": {},
        "sklearn.tests.test_multiclass": {
            "test_ovr_exceptions": [],
            "test_ovr_fit_predict": [],
            "test_ovr_always_present": [],
            "test_ovr_multilabel": [],
            "test_ovr_fit_predict_svc": [],
            "test_ovr_multilabel_dataset": [],
            "test_ovr_multilabel_predict_proba": [],
            "test_ovr_single_label_predict_proba": [],
            "test_ovr_multilabel_decision_function": [],
            "test_ovr_single_label_decision_function": [],
            "test_ovr_gridsearch": [],
            "test_ovr_pipeline": [],
            "test_ovr_coef_": [],
            "test_ovr_coef_exceptions": [],
            "test_ovo_exceptions": [],
            "test_ovo_fit_predict": [],
            "test_ovo_gridsearch": [],
            "test_ovo_ties": [],
            "test_ovo_ties2": [],
            "test_ecoc_exceptions": [],
            "test_ecoc_fit_predict": [],
            "test_ecoc_gridsearch": []
        },
        "sklearn.tests.test_init": {
            "test_import_skl": []
        },
        "sklearn.tests.test_kernel_approximation": {
            "test_additive_chi2_sampler": [],
            "test_skewed_chi2_sampler": [],
            "test_rbf_sampler": [],
            "test_input_validation": [],
            "test_nystroem_approximation": [],
            "test_nystroem_poly_kernel_params": [],
            "test_nystroem_callable": []
        },
        "sklearn.tests.test_hmm": {
            "train_hmm_and_keep_track_of_log_likelihood": [
                "hmm",
                "obs",
                "n_iter"
            ],
            "create_random_gmm": [
                "n_mix",
                "n_features",
                "covariance_type",
                "prng"
            ],
            "test_normalize_1D": [],
            "test_normalize_3D": [],
            "TestBaseHMM": {
                "setUp": [
                    "self"
                ],
                "setup_example_hmm": [
                    "self"
                ],
                "test_init": [
                    "self"
                ],
                "test_set_startprob": [
                    "self"
                ],
                "test_set_transmat": [
                    "self"
                ],
                "test_do_forward_pass": [
                    "self"
                ],
                "test_do_backward_pass": [
                    "self"
                ],
                "test_do_viterbi_pass": [
                    "self"
                ],
                "test_score_samples": [
                    "self"
                ],
                "test_hmm_score_samples_consistent_with_gmm": [
                    "self"
                ],
                "test_hmm_decode_consistent_with_gmm": [
                    "self"
                ],
                "test_base_hmm_attributes": [
                    "self"
                ]
            },
            "GaussianHMMBaseTester": {
                "setUp": [
                    "self"
                ],
                "test_bad_covariance_type": [
                    "self"
                ],
                "test_score_samples_and_decode": [
                    "self"
                ],
                "test_sample": [
                    "self",
                    "n"
                ],
                "test_fit": [
                    "self",
                    "params",
                    "n_iter",
                    "verbose"
                ],
                "test_fit_works_on_sequences_of_different_length": [
                    "self"
                ],
                "test_fit_with_priors": [
                    "self",
                    "params",
                    "n_iter",
                    "verbose"
                ],
                "test_fit_non_ergodic_transmat": [
                    "self"
                ]
            },
            "TestGaussianHMMWithSphericalCovars": {
                "test_fit_startprob_and_transmat": [
                    "self"
                ]
            },
            "TestGaussianHMMWithDiagonalCovars": {},
            "TestGaussianHMMWithTiedCovars": {},
            "TestGaussianHMMWithFullCovars": {},
            "MultinomialHMMTestCase": {
                "setUp": [
                    "self"
                ],
                "test_set_emissionprob": [
                    "self"
                ],
                "test_wikipedia_viterbi_example": [
                    "self"
                ],
                "test_decode_map_algorithm": [
                    "self"
                ],
                "test_predict": [
                    "self"
                ],
                "test_attributes": [
                    "self"
                ],
                "test_score_samples": [
                    "self"
                ],
                "test_sample": [
                    "self",
                    "n"
                ],
                "test_fit": [
                    "self",
                    "params",
                    "n_iter",
                    "verbose"
                ],
                "test_fit_emissionprob": [
                    "self"
                ],
                "test_fit_with_init": [
                    "self",
                    "params",
                    "n_iter",
                    "verbose"
                ]
            },
            "GMMHMMBaseTester": {
                "setUp": [
                    "self"
                ],
                "test_attributes": [
                    "self"
                ],
                "test_score_samples_and_decode": [
                    "self"
                ],
                "test_sample": [
                    "self",
                    "n"
                ],
                "test_fit": [
                    "self",
                    "params",
                    "n_iter",
                    "verbose"
                ],
                "test_fit_works_on_sequences_of_different_length": [
                    "self"
                ]
            },
            "TestGMMHMMWithDiagCovars": {
                "test_fit_startprob_and_transmat": [
                    "self"
                ],
                "test_fit_means": [
                    "self"
                ]
            },
            "TestGMMHMMWithTiedCovars": {},
            "TestGMMHMMWithFullCovars": {}
        },
        "sklearn.tests.test_grid_search": {
            "test_parameter_grid": [],
            "test_grid_search": [],
            "test_grid_search_no_score": [],
            "test_trivial_grid_scores": [],
            "test_no_refit": [],
            "test_grid_search_error": [],
            "test_grid_search_iid": [],
            "test_grid_search_one_grid_point": [],
            "test_grid_search_bad_param_grid": [],
            "test_grid_search_sparse": [],
            "test_grid_search_sparse_scoring": [],
            "test_deprecated_score_func": [],
            "test_grid_search_precomputed_kernel": [],
            "test_grid_search_precomputed_kernel_error_nonsquare": [],
            "test_grid_search_precomputed_kernel_error_kernel_function": [],
            "test_refit": [],
            "test_X_as_list": [],
            "test_unsupervised_grid_search": [],
            "test_bad_estimator": [],
            "test_param_sampler": [],
            "test_randomized_search_grid_scores": [],
            "test_grid_search_score_consistency": [],
            "test_pickle": [],
            "test_grid_search_with_multioutput_data": [],
            "MockClassifier": {
                "__init__": [
                    "self",
                    "foo_param"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ]
            },
            "MockListClassifier": {
                "__init__": [
                    "self",
                    "foo_param"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ],
                "get_params": [
                    "self",
                    "deep"
                ],
                "set_params": [
                    "self"
                ]
            },
            "LinearSVCNoScore": {
                "score": [
                    "self"
                ]
            },
            "BrokenClassifier": {
                "__init__": [
                    "self",
                    "parameter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.tests.test_qda": {
            "test_qda": [],
            "test_qda_priors": [],
            "test_qda_store_covariances": [],
            "test_qda_regularization": []
        },
        "sklearn.tests.test_base": {
            "test_clone": [],
            "test_clone_2": [],
            "test_clone_buggy": [],
            "test_clone_empty_array": [],
            "test_repr": [],
            "test_str": [],
            "test_get_params": [],
            "test_get_params_deprecated": [],
            "test_is_classifier": [],
            "test_set_params": [],
            "MyEstimator": {
                "__init__": [
                    "self",
                    "l1",
                    "empty"
                ]
            },
            "K": {
                "__init__": [
                    "self",
                    "c",
                    "d"
                ]
            },
            "T": {
                "__init__": [
                    "self",
                    "a",
                    "b"
                ]
            },
            "DeprecatedAttributeEstimator": {
                "__init__": [
                    "self",
                    "a",
                    "b"
                ],
                "b": [
                    "self"
                ]
            },
            "Buggy": {
                "__init__": [
                    "self",
                    "a"
                ]
            },
            "NoEstimator": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "VargEstimator": {
                "__init__": [
                    "self"
                ]
            }
        },
        "sklearn.tests.test_isotonic": {
            "test_isotonic_regression": [],
            "test_isotonic_regression_reversed": [],
            "test_assert_raises_exceptions": []
        },
        "sklearn.tests.test_random_projection": {
            "make_sparse_random_data": [
                "n_samples",
                "n_features",
                "n_nonzeros"
            ],
            "densify": [
                "matrix"
            ],
            "test_invalid_jl_domain": [],
            "test_input_size_jl_min_dim": [],
            "check_input_size_random_matrix": [
                "random_matrix"
            ],
            "check_size_generated": [
                "random_matrix"
            ],
            "check_zero_mean_and_unit_norm": [
                "random_matrix"
            ],
            "check_input_with_sparse_random_matrix": [
                "random_matrix"
            ],
            "test_basic_property_of_random_matrix": [],
            "test_gaussian_random_matrix": [],
            "test_sparse_random_matrix": [],
            "test_sparse_random_projection_transformer_invalid_density": [],
            "test_random_projection_transformer_invalid_input": [],
            "test_try_to_transform_before_fit": [],
            "test_too_many_samples_to_find_a_safe_embedding": [],
            "test_random_projection_embedding_quality": [],
            "test_SparseRandomProjection_output_representation": [],
            "test_correct_RandomProjection_dimensions_embedding": [],
            "test_warning_n_components_greater_than_n_features": []
        },
        "sklearn.tests.test_pipeline": {
            "test_pipeline_init": [],
            "test_pipeline_methods_anova": [],
            "test_pipeline_fit_params": [],
            "test_pipeline_methods_pca_svm": [],
            "test_pipeline_methods_preprocessing_svm": [],
            "test_feature_union": [],
            "test_pipeline_transform": [],
            "test_pipeline_fit_transform": [],
            "test_feature_union_weights": [],
            "test_feature_union_feature_names": [],
            "IncorrectT": {
                "__init__": [
                    "self",
                    "a",
                    "b"
                ]
            },
            "T": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "TransfT": {
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "FitParamT": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "should_succeed"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.tests.test_lda": {
            "test_lda_predict": [],
            "test_lda_transform": []
        },
        "sklearn.tests.test_common": {
            "test_all_estimators": [],
            "test_all_estimator_no_base_class": [],
            "test_estimators_sparse_data": [],
            "test_transformers": [],
            "test_transformers_sparse_data": [],
            "test_estimators_nan_inf": [],
            "test_transformers_pickle": [],
            "test_classifiers_one_label": [],
            "test_clustering": [],
            "test_classifiers_train": [],
            "test_classifiers_classes": [],
            "test_classifiers_input_shapes": [],
            "test_classifiers_pickle": [],
            "_boston_subset": [],
            "test_regressors_int": [],
            "test_regressors_train": [],
            "test_regressor_pickle": [],
            "test_configure": [],
            "test_class_weight_classifiers": [],
            "test_class_weight_auto_classifies": [],
            "test_estimators_overwrite_params": [],
            "test_cluster_overwrite_params": [],
            "test_import_all_consistency": []
        },
        "sklearn.tests.test_dummy": {
            "_check_predict_proba": [
                "clf",
                "X",
                "y"
            ],
            "_check_behavior_2d": [
                "clf"
            ],
            "test_most_frequent_strategy": [],
            "test_most_frequent_strategy_multioutput": [],
            "test_stratified_strategy": [],
            "test_stratified_strategy_multioutput": [],
            "test_uniform_strategy": [],
            "test_uniform_strategy_multioutput": [],
            "test_string_labels": [],
            "test_classifier_exceptions": [],
            "test_regressor": [],
            "test_multioutput_regressor": [],
            "test_regressor_exceptions": []
        },
        "sklearn.tests.test_cross_validation": {
            "test_kfold_valueerrors": [],
            "test_kfold_indices": [],
            "test_kfold_balance": [],
            "test_shuffle_kfold": [],
            "test_shuffle_split": [],
            "test_stratified_shuffle_split_init": [],
            "test_stratified_shuffle_split_iter": [],
            "test_stratified_shuffle_split_iter_no_indices": [],
            "test_leave_label_out_changing_labels": [],
            "test_cross_val_score": [],
            "test_cross_val_score_precomputed": [],
            "test_cross_val_score_fit_params": [],
            "test_cross_val_score_score_func": [],
            "test_cross_val_score_errors": [],
            "test_train_test_split_errors": [],
            "test_train_test_split": [],
            "test_cross_val_score_with_score_func_classification": [],
            "test_cross_val_score_with_score_func_regression": [],
            "test_permutation_score": [],
            "test_cross_val_generator_with_mask": [],
            "test_cross_val_generator_with_indices": [],
            "test_cross_val_generator_mask_indices_same": [],
            "test_bootstrap_errors": [],
            "test_bootstrap_test_sizes": [],
            "test_shufflesplit_errors": [],
            "test_shufflesplit_reproducible": [],
            "test_cross_indices_exception": [],
            "MockListClassifier": {
                "__init__": [
                    "self",
                    "foo_param"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ]
            },
            "MockClassifier": {
                "__init__": [
                    "self",
                    "a"
                ],
                "fit": [
                    "self",
                    "X",
                    "Y",
                    "sample_weight",
                    "class_prior"
                ],
                "predict": [
                    "self",
                    "T"
                ],
                "score": [
                    "self",
                    "X",
                    "Y"
                ]
            }
        },
        "sklearn.tests.test_check_build": {
            "test_raise_build_error": []
        },
        "sklearn.tests.test_naive_bayes": {
            "test_gnb": [],
            "test_gnb_prior": [],
            "test_discrete_prior": [],
            "test_mnnb": [],
            "check_partial_fit": [
                "cls"
            ],
            "test_discretenb_partial_fit": [],
            "test_discretenb_pickle": [],
            "test_input_check_fit": [],
            "test_input_check_partial_fit": [],
            "test_discretenb_predict_proba": [],
            "test_discretenb_uniform_prior": [],
            "test_discretenb_provide_prior": [],
            "test_deprecated_fit_param": [],
            "test_sample_weight_multiclass": [],
            "check_sample_weight_multiclass": [
                "cls"
            ],
            "test_sample_weight_mnb": [],
            "test_coef_intercept_shape": [],
            "test_check_accuracy_on_digits": []
        },
        "sklearn.tests": {},
        "sklearn.feature_extraction.dict_vectorizer": {
            "_tosequence": [
                "X"
            ],
            "DictVectorizer": {
                "__init__": [
                    "self",
                    "dtype",
                    "separator",
                    "sparse"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "dict_type"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ],
                "get_feature_names": [
                    "self"
                ],
                "restrict": [
                    "self",
                    "support",
                    "indices"
                ]
            }
        },
        "sklearn.feature_extraction.image": {
            "_make_edges_3d": [
                "n_x",
                "n_y",
                "n_z"
            ],
            "_compute_gradient_3d": [
                "edges",
                "img"
            ],
            "_mask_edges_weights": [
                "mask",
                "edges",
                "weights"
            ],
            "_to_graph": [
                "n_x",
                "n_y",
                "n_z",
                "mask",
                "img",
                "return_as",
                "dtype"
            ],
            "img_to_graph": [
                "img",
                "mask",
                "return_as",
                "dtype"
            ],
            "grid_to_graph": [
                "n_x",
                "n_y",
                "n_z",
                "mask",
                "return_as",
                "dtype"
            ],
            "_compute_n_patches": [
                "i_h",
                "i_w",
                "p_h",
                "p_w",
                "max_patches"
            ],
            "extract_patches": [
                "arr",
                "patch_shape",
                "extraction_step"
            ],
            "extract_patches_2d": [
                "image",
                "patch_size",
                "max_patches",
                "random_state"
            ],
            "reconstruct_from_patches_2d": [
                "patches",
                "image_size"
            ],
            "PatchExtractor": {
                "__init__": [
                    "self",
                    "patch_size",
                    "max_patches",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.feature_extraction.stop_words": {},
        "sklearn.feature_extraction.text": {
            "strip_accents_unicode": [
                "s"
            ],
            "strip_accents_ascii": [
                "s"
            ],
            "strip_tags": [
                "s"
            ],
            "_check_stop_list": [
                "stop"
            ],
            "_document_frequency": [
                "X"
            ],
            "_make_int_array": [],
            "VectorizerMixin": {
                "decode": [
                    "self",
                    "doc"
                ],
                "_word_ngrams": [
                    "self",
                    "tokens",
                    "stop_words"
                ],
                "_char_ngrams": [
                    "self",
                    "text_document"
                ],
                "_char_wb_ngrams": [
                    "self",
                    "text_document"
                ],
                "build_preprocessor": [
                    "self"
                ],
                "build_tokenizer": [
                    "self"
                ],
                "get_stop_words": [
                    "self"
                ],
                "build_analyzer": [
                    "self"
                ]
            },
            "HashingVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "charset",
                    "encoding",
                    "decode_error",
                    "charset_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "analyzer",
                    "n_features",
                    "binary",
                    "norm",
                    "non_negative",
                    "dtype"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_get_hasher": [
                    "self"
                ]
            },
            "CountVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "encoding",
                    "charset",
                    "decode_error",
                    "charset_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "analyzer",
                    "max_df",
                    "min_df",
                    "max_features",
                    "vocabulary",
                    "binary",
                    "dtype"
                ],
                "_sort_features": [
                    "self",
                    "cscmatrix",
                    "vocabulary"
                ],
                "_limit_features": [
                    "self",
                    "cscmatrix",
                    "vocabulary",
                    "high",
                    "low",
                    "limit"
                ],
                "_count_vocab": [
                    "self",
                    "raw_documents",
                    "fixed_vocab"
                ],
                "fit": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "transform": [
                    "self",
                    "raw_documents"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ],
                "get_feature_names": [
                    "self"
                ],
                "max_df_stop_words_": [
                    "self"
                ]
            },
            "TfidfTransformer": {
                "__init__": [
                    "self",
                    "norm",
                    "use_idf",
                    "smooth_idf",
                    "sublinear_tf"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "copy"
                ],
                "idf_": [
                    "self"
                ]
            },
            "TfidfVectorizer": {
                "__init__": [
                    "self",
                    "input",
                    "encoding",
                    "charset",
                    "decode_error",
                    "charset_error",
                    "strip_accents",
                    "lowercase",
                    "preprocessor",
                    "tokenizer",
                    "analyzer",
                    "stop_words",
                    "token_pattern",
                    "ngram_range",
                    "max_df",
                    "min_df",
                    "max_features",
                    "vocabulary",
                    "binary",
                    "dtype",
                    "norm",
                    "use_idf",
                    "smooth_idf",
                    "sublinear_tf"
                ],
                "norm": [
                    "self",
                    "value"
                ],
                "use_idf": [
                    "self",
                    "value"
                ],
                "smooth_idf": [
                    "self",
                    "value"
                ],
                "sublinear_tf": [
                    "self",
                    "value"
                ],
                "fit": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "raw_documents",
                    "y"
                ],
                "transform": [
                    "self",
                    "raw_documents",
                    "copy"
                ]
            }
        },
        "sklearn.feature_extraction.hashing": {
            "_iteritems": [
                "d"
            ],
            "FeatureHasher": {
                "__init__": [
                    "self",
                    "n_features",
                    "input_type",
                    "dtype",
                    "non_negative"
                ],
                "_validate_params": [
                    "n_features",
                    "input_type"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "raw_X",
                    "y"
                ]
            }
        },
        "sklearn.feature_extraction.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.feature_extraction": {},
        "sklearn.feature_extraction.tests.test_feature_hasher": {
            "test_feature_hasher_dicts": [],
            "test_feature_hasher_strings": [],
            "test_feature_hasher_pairs": [],
            "test_hash_empty_input": [],
            "test_hasher_invalid_input": [],
            "test_hasher_set_params": []
        },
        "sklearn.feature_extraction.tests.test_image": {
            "test_img_to_graph": [],
            "test_grid_to_graph": [],
            "test_connect_regions": [],
            "test_connect_regions_with_grid": [],
            "_downsampled_lena": [],
            "_orange_lena": [
                "lena"
            ],
            "_make_images": [
                "lena"
            ],
            "test_extract_patches_all": [],
            "test_extract_patches_all_color": [],
            "test_extract_patches_all_rect": [],
            "test_extract_patches_max_patches": [],
            "test_reconstruct_patches_perfect": [],
            "test_reconstruct_patches_perfect_color": [],
            "test_patch_extractor_fit": [],
            "test_patch_extractor_max_patches": [],
            "test_patch_extractor_max_patches_default": [],
            "test_patch_extractor_all_patches": [],
            "test_patch_extractor_color": [],
            "test_extract_patches_strided": [],
            "test_extract_patches_square": []
        },
        "sklearn.feature_extraction.tests.test_dict_vectorizer": {
            "test_dictvectorizer": [],
            "test_feature_selection": [],
            "test_one_of_k": [],
            "test_unseen_or_no_features": [],
            "test_deterministic_vocabulary": []
        },
        "sklearn.feature_extraction.tests.test_text": {
            "uppercase": [
                "s"
            ],
            "strip_eacute": [
                "s"
            ],
            "split_tokenize": [
                "s"
            ],
            "lazy_analyze": [
                "s"
            ],
            "test_strip_accents": [],
            "test_to_ascii": [],
            "test_word_analyzer_unigrams": [],
            "test_word_analyzer_unigrams_and_bigrams": [],
            "test_unicode_decode_error": [],
            "test_char_ngram_analyzer": [],
            "test_char_wb_ngram_analyzer": [],
            "test_countvectorizer_custom_vocabulary": [],
            "test_countvectorizer_custom_vocabulary_pipeline": [],
            "test_countvectorizer_stop_words": [],
            "test_countvectorizer_empty_vocabulary": [],
            "test_fit_countvectorizer_twice": [],
            "test_tf_idf_smoothing": [],
            "test_tfidf_no_smoothing": [],
            "test_sublinear_tf": [],
            "test_vectorizer": [],
            "test_tfidf_vectorizer_setters": [],
            "test_hashing_vectorizer": [],
            "test_feature_names": [],
            "test_vectorizer_max_features": [],
            "test_vectorizer_max_df": [],
            "test_vectorizer_min_df": [],
            "test_count_binary_occurrences": [],
            "test_hashed_binary_occurrences": [],
            "test_vectorizer_inverse_transform": [],
            "test_count_vectorizer_pipeline_grid_selection": [],
            "test_vectorizer_pipeline_grid_selection": [],
            "test_vectorizer_unicode": [],
            "test_tfidf_vectorizer_with_fixed_vocabulary": [],
            "test_pickling_vectorizer": [],
            "test_pickling_transformer": []
        },
        "sklearn.feature_extraction.tests": {},
        "sklearn.neural_network.rbm": {
            "BernoulliRBM": {
                "__init__": [
                    "self",
                    "n_components",
                    "learning_rate",
                    "batch_size",
                    "n_iter",
                    "verbose",
                    "random_state"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "_mean_hiddens": [
                    "self",
                    "v"
                ],
                "_sample_hiddens": [
                    "self",
                    "v",
                    "rng"
                ],
                "_sample_visibles": [
                    "self",
                    "h",
                    "rng"
                ],
                "_free_energy": [
                    "self",
                    "v"
                ],
                "gibbs": [
                    "self",
                    "v"
                ],
                "_fit": [
                    "self",
                    "v_pos",
                    "rng"
                ],
                "score_samples": [
                    "self",
                    "v"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.neural_network": {},
        "sklearn.svm.classes": {
            "LinearSVC": {
                "__init__": [
                    "self",
                    "penalty",
                    "loss",
                    "dual",
                    "tol",
                    "C",
                    "multi_class",
                    "fit_intercept",
                    "intercept_scaling",
                    "class_weight",
                    "verbose",
                    "random_state"
                ]
            },
            "SVC": {
                "__init__": [
                    "self",
                    "C",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "probability",
                    "tol",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "random_state"
                ]
            },
            "NuSVC": {
                "__init__": [
                    "self",
                    "nu",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "probability",
                    "tol",
                    "cache_size",
                    "verbose",
                    "max_iter",
                    "random_state"
                ]
            },
            "SVR": {
                "__init__": [
                    "self",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "C",
                    "epsilon",
                    "shrinking",
                    "probability",
                    "cache_size",
                    "verbose",
                    "max_iter",
                    "random_state"
                ]
            },
            "NuSVR": {
                "__init__": [
                    "self",
                    "nu",
                    "C",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "shrinking",
                    "probability",
                    "tol",
                    "cache_size",
                    "verbose",
                    "max_iter",
                    "random_state"
                ]
            },
            "OneClassSVM": {
                "__init__": [
                    "self",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "nu",
                    "shrinking",
                    "cache_size",
                    "verbose",
                    "max_iter",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "sample_weight"
                ]
            }
        },
        "sklearn.svm.bounds": {
            "l1_min_c": [
                "X",
                "y",
                "loss",
                "fit_intercept",
                "intercept_scaling"
            ]
        },
        "sklearn.svm.base": {
            "_one_vs_one_coef": [
                "dual_coef",
                "n_support",
                "support_vectors"
            ],
            "BaseLibSVM": {
                "__init__": [
                    "self",
                    "impl",
                    "kernel",
                    "degree",
                    "gamma",
                    "coef0",
                    "tol",
                    "C",
                    "nu",
                    "epsilon",
                    "shrinking",
                    "probability",
                    "cache_size",
                    "class_weight",
                    "verbose",
                    "max_iter",
                    "random_state"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_validate_targets": [
                    "self",
                    "y"
                ],
                "_warn_from_fit_status": [
                    "self"
                ],
                "_dense_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "solver_type",
                    "kernel",
                    "random_seed"
                ],
                "_sparse_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "solver_type",
                    "kernel",
                    "random_seed"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_dense_predict": [
                    "self",
                    "X"
                ],
                "_sparse_predict": [
                    "self",
                    "X"
                ],
                "_compute_kernel": [
                    "self",
                    "X"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "_validate_for_predict": [
                    "self",
                    "X"
                ],
                "coef_": [
                    "self"
                ]
            },
            "BaseSVC": {
                "_validate_targets": [
                    "self",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ],
                "_dense_predict_proba": [
                    "self",
                    "X"
                ],
                "_sparse_predict_proba": [
                    "self",
                    "X"
                ],
                "label_": [
                    "self"
                ]
            },
            "BaseLibLinear": {
                "__init__": [
                    "self",
                    "penalty",
                    "loss",
                    "dual",
                    "tol",
                    "C",
                    "multi_class",
                    "fit_intercept",
                    "intercept_scaling",
                    "class_weight",
                    "verbose",
                    "random_state"
                ],
                "_get_solver_type": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "classes_": [
                    "self"
                ],
                "label_": [
                    "self"
                ],
                "_get_bias": [
                    "self"
                ]
            }
        },
        "sklearn.svm.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.svm": {},
        "sklearn.svm.tests.test_svm": {
            "test_libsvm_parameters": [],
            "test_libsvm_iris": [],
            "test_single_sample_1d": [],
            "test_precomputed": [],
            "test_svr": [],
            "test_svr_errors": [],
            "test_oneclass": [],
            "test_oneclass_decision_function": [],
            "test_tweak_params": [],
            "test_probability": [],
            "test_decision_function": [],
            "test_weight": [],
            "test_sample_weights": [],
            "test_auto_weight": [],
            "test_bad_input": [],
            "test_linearsvc_parameters": [],
            "test_linearsvc": [],
            "test_linearsvc_crammer_singer": [],
            "test_linearsvc_iris": [],
            "test_dense_liblinear_intercept_handling": [
                "classifier"
            ],
            "test_liblinear_set_coef": [],
            "test_immutable_coef_property": [],
            "test_inheritance": [],
            "test_linearsvc_verbose": [],
            "test_svc_clone_with_callable_kernel": [],
            "test_svc_bad_kernel": [],
            "test_timeout": [],
            "test_consistent_proba": []
        },
        "sklearn.svm.tests.test_bounds": {
            "test_l1_min_c": [],
            "check_l1_min_c": [
                "X",
                "y",
                "loss",
                "fit_intercept",
                "intercept_scaling"
            ],
            "test_ill_posed_min_c": [],
            "test_unsupported_loss": []
        },
        "sklearn.svm.tests.test_sparse": {
            "test_svc": [],
            "test_unsorted_indices": [],
            "test_svc_with_custom_kernel": [],
            "test_svc_iris": [],
            "test_error": [],
            "test_linearsvc": [],
            "test_linearsvc_iris": [],
            "test_weight": [],
            "test_sample_weights": [],
            "test_sparse_liblinear_intercept_handling": [],
            "test_sparse_realdata": [],
            "test_sparse_svc_clone_with_callable_kernel": [],
            "test_timeout": [],
            "test_consistent_proba": []
        },
        "sklearn.svm.tests": {},
        "sklearn.mixture.gmm": {
            "log_multivariate_normal_density": [
                "X",
                "means",
                "covars",
                "covariance_type"
            ],
            "sample_gaussian": [
                "mean",
                "covar",
                "covariance_type",
                "n_samples",
                "random_state"
            ],
            "_log_multivariate_normal_density_diag": [
                "X",
                "means",
                "covars"
            ],
            "_log_multivariate_normal_density_spherical": [
                "X",
                "means",
                "covars"
            ],
            "_log_multivariate_normal_density_tied": [
                "X",
                "means",
                "covars"
            ],
            "_log_multivariate_normal_density_full": [
                "X",
                "means",
                "covars",
                "min_covar"
            ],
            "_validate_covars": [
                "covars",
                "covariance_type",
                "n_components"
            ],
            "distribute_covar_matrix_to_match_covariance_type": [
                "tied_cv",
                "covariance_type",
                "n_components"
            ],
            "_covar_mstep_diag": [
                "gmm",
                "X",
                "responsibilities",
                "weighted_X_sum",
                "norm",
                "min_covar"
            ],
            "_covar_mstep_spherical": [],
            "_covar_mstep_full": [
                "gmm",
                "X",
                "responsibilities",
                "weighted_X_sum",
                "norm",
                "min_covar"
            ],
            "_covar_mstep_tied": [
                "gmm",
                "X",
                "responsibilities",
                "weighted_X_sum",
                "norm",
                "min_covar"
            ],
            "GMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "covariance_type",
                    "random_state",
                    "thresh",
                    "min_covar",
                    "n_iter",
                    "n_init",
                    "params",
                    "init_params"
                ],
                "_get_covars": [
                    "self"
                ],
                "_set_covars": [
                    "self",
                    "covars"
                ],
                "eval": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "sample": [
                    "self",
                    "n_samples",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X"
                ],
                "_do_mstep": [
                    "self",
                    "X",
                    "responsibilities",
                    "params",
                    "min_covar"
                ],
                "_n_parameters": [
                    "self"
                ],
                "bic": [
                    "self",
                    "X"
                ],
                "aic": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.mixture.dpgmm": {
            "sqnorm": [
                "v"
            ],
            "digamma": [
                "x"
            ],
            "gammaln": [
                "x"
            ],
            "log_normalize": [
                "v",
                "axis"
            ],
            "wishart_log_det": [
                "a",
                "b",
                "detB",
                "n_features"
            ],
            "wishart_logz": [
                "v",
                "s",
                "dets",
                "n_features"
            ],
            "_bound_wishart": [
                "a",
                "B",
                "detB"
            ],
            "_sym_quad_form": [
                "x",
                "mu",
                "A"
            ],
            "_bound_state_log_lik": [
                "X",
                "initial_bound",
                "precs",
                "means",
                "covariance_type"
            ],
            "DPGMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "covariance_type",
                    "alpha",
                    "random_state",
                    "thresh",
                    "verbose",
                    "min_covar",
                    "n_iter",
                    "params",
                    "init_params"
                ],
                "_get_precisions": [
                    "self"
                ],
                "_get_covars": [
                    "self"
                ],
                "_set_covars": [
                    "self",
                    "covars"
                ],
                "eval": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "_update_concentration": [
                    "self",
                    "z"
                ],
                "_update_means": [
                    "self",
                    "X",
                    "z"
                ],
                "_update_precisions": [
                    "self",
                    "X",
                    "z"
                ],
                "_monitor": [
                    "self",
                    "X",
                    "z",
                    "n",
                    "end"
                ],
                "_do_mstep": [
                    "self",
                    "X",
                    "z",
                    "params"
                ],
                "_initialize_gamma": [
                    "self"
                ],
                "_bound_concentration": [
                    "self"
                ],
                "_bound_means": [
                    "self"
                ],
                "_bound_precisions": [
                    "self"
                ],
                "_bound_proportions": [
                    "self",
                    "z"
                ],
                "_logprior": [
                    "self",
                    "z"
                ],
                "lower_bound": [
                    "self",
                    "X",
                    "z"
                ],
                "_set_weights": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X"
                ]
            },
            "VBGMM": {
                "__init__": [
                    "self",
                    "n_components",
                    "covariance_type",
                    "alpha",
                    "random_state",
                    "thresh",
                    "verbose",
                    "min_covar",
                    "n_iter",
                    "params",
                    "init_params"
                ],
                "eval": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "_update_concentration": [
                    "self",
                    "z"
                ],
                "_initialize_gamma": [
                    "self"
                ],
                "_bound_proportions": [
                    "self",
                    "z"
                ],
                "_bound_concentration": [
                    "self"
                ],
                "_monitor": [
                    "self",
                    "X",
                    "z",
                    "n",
                    "end"
                ],
                "_set_weights": [
                    "self"
                ]
            }
        },
        "sklearn.mixture": {},
        "sklearn.mixture.tests.test_gmm": {
            "test_sample_gaussian": [],
            "_naive_lmvnpdf_diag": [
                "X",
                "mu",
                "cv"
            ],
            "test_lmvnpdf_diag": [],
            "test_lmvnpdf_spherical": [],
            "test_lmvnpdf_full": [],
            "test_GMM_attributes": [],
            "test_multiple_init": [],
            "test_n_parameters": [],
            "test_aic": [],
            "GMMTester": {
                "_setUp": [
                    "self"
                ],
                "test_eval": [
                    "self"
                ],
                "test_sample": [
                    "self",
                    "n"
                ],
                "test_train": [
                    "self",
                    "params"
                ],
                "test_train_degenerate": [
                    "self",
                    "params"
                ],
                "test_train_1d": [
                    "self",
                    "params"
                ],
                "score": [
                    "self",
                    "g",
                    "X"
                ]
            },
            "TestGMMWithSphericalCovars": {},
            "TestGMMWithDiagonalCovars": {},
            "TestGMMWithTiedCovars": {},
            "TestGMMWithFullCovars": {}
        },
        "sklearn.mixture.tests.test_dpgmm": {
            "test_class_weights": [],
            "test_log_normalize": [],
            "do_model": [
                "self"
            ],
            "DPGMMTester": {
                "score": [
                    "self",
                    "g",
                    "train_obs"
                ]
            },
            "TestDPGMMWithSphericalCovars": {},
            "TestDPGMMWithDiagCovars": {},
            "TestDPGMMWithTiedCovars": {},
            "TestDPGMMWithFullCovars": {},
            "VBGMMTester": {
                "score": [
                    "self",
                    "g",
                    "train_obs"
                ]
            },
            "TestVBGMMWithSphericalCovars": {},
            "TestVBGMMWithDiagCovars": {},
            "TestVBGMMWithTiedCovars": {},
            "TestVBGMMWithFullCovars": {}
        },
        "sklearn.mixture.tests": {},
        "sklearn.tree.tree": {
            "BaseDecisionTree": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_mask",
                    "X_argsorted",
                    "check_input",
                    "sample_weight"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "feature_importances_": [
                    "self"
                ]
            },
            "DecisionTreeClassifier": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "random_state",
                    "min_density",
                    "compute_importances"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "DecisionTreeRegressor": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "random_state",
                    "min_density",
                    "compute_importances"
                ]
            },
            "ExtraTreeClassifier": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "random_state",
                    "min_density",
                    "compute_importances"
                ]
            },
            "ExtraTreeRegressor": {
                "__init__": [
                    "self",
                    "criterion",
                    "splitter",
                    "max_depth",
                    "min_samples_split",
                    "min_samples_leaf",
                    "max_features",
                    "random_state",
                    "min_density",
                    "compute_importances"
                ]
            }
        },
        "sklearn.tree.export": {
            "export_graphviz": [
                "decision_tree",
                "out_file",
                "feature_names",
                "max_depth",
                "close"
            ]
        },
        "sklearn.tree.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.tree": {},
        "sklearn.tree.tests.test_tree": {
            "test_classification_toy": [],
            "test_weighted_classification_toy": [],
            "test_regression_toy": [],
            "test_xor": [],
            "test_iris": [],
            "test_boston": [],
            "test_probability": [],
            "test_arrayrepr": [],
            "test_pure_set": [],
            "test_numerical_stability": [],
            "test_importances": [],
            "test_max_features": [],
            "test_error": [],
            "test_min_samples_leaf": [],
            "test_pickle": [],
            "test_multioutput": [],
            "test_classes_shape": [],
            "test_unbalanced_iris": [],
            "test_memory_layout": [],
            "test_sample_weight": [],
            "test_32bit_equality": []
        },
        "sklearn.tree.tests": {},
        "sklearn.tree.tests.test_export": {
            "test_graphviz_toy": [],
            "test_graphviz_errors": []
        },
        "sklearn.neighbors.classification": {
            "KNeighborsClassifier": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ]
            },
            "RadiusNeighborsClassifier": {
                "__init__": [
                    "self",
                    "radius",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric",
                    "outlier_label"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.neighbors.unsupervised": {
            "NearestNeighbors": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "radius",
                    "algorithm",
                    "leaf_size",
                    "metric"
                ]
            }
        },
        "sklearn.neighbors.graph": {
            "kneighbors_graph": [
                "X",
                "n_neighbors",
                "mode"
            ],
            "radius_neighbors_graph": [
                "X",
                "radius",
                "mode"
            ]
        },
        "sklearn.neighbors.kde": {
            "KernelDensity": {
                "__init__": [
                    "self",
                    "bandwidth",
                    "algorithm",
                    "kernel",
                    "metric",
                    "atol",
                    "rtol",
                    "breadth_first",
                    "leaf_size",
                    "metric_params"
                ],
                "_choose_algorithm": [
                    "self",
                    "algorithm",
                    "metric"
                ],
                "fit": [
                    "self",
                    "X"
                ],
                "score_samples": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X"
                ],
                "sample": [
                    "self",
                    "n_samples",
                    "random_state"
                ]
            }
        },
        "sklearn.neighbors.regression": {
            "KNeighborsRegressor": {
                "__init__": [
                    "self",
                    "n_neighbors",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            },
            "RadiusNeighborsRegressor": {
                "__init__": [
                    "self",
                    "radius",
                    "weights",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "metric"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.neighbors.nearest_centroid": {
            "NearestCentroid": {
                "__init__": [
                    "self",
                    "metric",
                    "shrink_threshold"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.neighbors.base": {
            "_check_weights": [
                "weights"
            ],
            "_get_weights": [
                "dist",
                "weights"
            ],
            "NeighborsWarning": {},
            "NeighborsBase": {
                "__init__": [
                    "self"
                ],
                "_init_params": [
                    "self",
                    "n_neighbors",
                    "radius",
                    "algorithm",
                    "leaf_size",
                    "metric",
                    "p"
                ],
                "_fit": [
                    "self",
                    "X"
                ]
            },
            "KNeighborsMixin": {
                "kneighbors": [
                    "self",
                    "X",
                    "n_neighbors",
                    "return_distance"
                ],
                "kneighbors_graph": [
                    "self",
                    "X",
                    "n_neighbors",
                    "mode"
                ]
            },
            "RadiusNeighborsMixin": {
                "radius_neighbors": [
                    "self",
                    "X",
                    "radius",
                    "return_distance"
                ],
                "radius_neighbors_graph": [
                    "self",
                    "X",
                    "radius",
                    "mode"
                ]
            },
            "SupervisedFloatMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SupervisedIntegerMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "UnsupervisedMixin": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.neighbors.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.neighbors": {},
        "sklearn.preprocessing._weights": {
            "_balance_weights": [
                "y"
            ],
            "balance_weights": [
                "y"
            ]
        },
        "sklearn.preprocessing.data": {
            "_mean_and_std": [
                "X",
                "axis",
                "with_mean",
                "with_std"
            ],
            "scale": [
                "X",
                "axis",
                "with_mean",
                "with_std",
                "copy"
            ],
            "normalize": [
                "X",
                "norm",
                "axis",
                "copy"
            ],
            "binarize": [
                "X",
                "threshold",
                "copy"
            ],
            "add_dummy_feature": [
                "X",
                "value"
            ],
            "_transform_selected": [
                "X",
                "transform",
                "selected",
                "copy"
            ],
            "MinMaxScaler": {
                "__init__": [
                    "self",
                    "feature_range",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            },
            "StandardScaler": {
                "__init__": [
                    "self",
                    "copy",
                    "with_mean",
                    "with_std"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y",
                    "copy"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "copy"
                ]
            },
            "Scaler": {
                "__init__": [
                    "self",
                    "copy",
                    "with_mean",
                    "with_std"
                ]
            },
            "Normalizer": {
                "__init__": [
                    "self",
                    "norm",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y",
                    "copy"
                ]
            },
            "Binarizer": {
                "__init__": [
                    "self",
                    "threshold",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y",
                    "copy"
                ]
            },
            "KernelCenterer": {
                "fit": [
                    "self",
                    "K",
                    "y"
                ],
                "transform": [
                    "self",
                    "K",
                    "y",
                    "copy"
                ]
            },
            "OneHotEncoder": {
                "__init__": [
                    "self",
                    "n_values",
                    "categorical_features",
                    "dtype"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit_transform": [
                    "self",
                    "X"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_transform": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.preprocessing.imputation": {
            "_get_mask": [
                "X",
                "value_to_mask"
            ],
            "_get_median": [
                "negative_elements",
                "n_zeros",
                "positive_elements"
            ],
            "_get_elem_at_rank": [
                "negative_elements",
                "n_zeros",
                "positive_elements",
                "k"
            ],
            "_most_frequent": [
                "array",
                "extra_value",
                "n_repeat"
            ],
            "Imputer": {
                "__init__": [
                    "self",
                    "missing_values",
                    "strategy",
                    "axis",
                    "verbose",
                    "copy"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_sparse_fit": [
                    "self",
                    "X",
                    "strategy",
                    "missing_values",
                    "axis"
                ],
                "_dense_fit": [
                    "self",
                    "X",
                    "strategy",
                    "missing_values",
                    "axis"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.preprocessing.label": {
            "label_binarize": [
                "y",
                "classes",
                "multilabel",
                "neg_label",
                "pos_label"
            ],
            "LabelEncoder": {
                "_check_fitted": [
                    "self"
                ],
                "fit": [
                    "self",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "y"
                ],
                "transform": [
                    "self",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "y"
                ]
            },
            "LabelBinarizer": {
                "__init__": [
                    "self",
                    "neg_label",
                    "pos_label"
                ],
                "multilabel": [
                    "self"
                ],
                "_check_fitted": [
                    "self"
                ],
                "fit": [
                    "self",
                    "y"
                ],
                "transform": [
                    "self",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "Y",
                    "threshold"
                ]
            }
        },
        "sklearn.preprocessing": {},
        "sklearn.linear_model.omp": {
            "_cholesky_omp": [
                "X",
                "y",
                "n_nonzero_coefs",
                "tol",
                "copy_X",
                "return_path"
            ],
            "_gram_omp": [
                "Gram",
                "Xy",
                "n_nonzero_coefs",
                "tol_0",
                "tol",
                "copy_Gram",
                "copy_Xy",
                "return_path"
            ],
            "orthogonal_mp": [
                "X",
                "y",
                "n_nonzero_coefs",
                "tol",
                "precompute",
                "copy_X",
                "return_path",
                "precompute_gram"
            ],
            "orthogonal_mp_gram": [
                "Gram",
                "Xy",
                "n_nonzero_coefs",
                "tol",
                "norms_squared",
                "copy_Gram",
                "copy_Xy",
                "return_path"
            ],
            "_omp_path_residues": [
                "X_train",
                "y_train",
                "X_test",
                "y_test",
                "copy",
                "fit_intercept",
                "normalize",
                "max_iter"
            ],
            "OrthogonalMatchingPursuit": {
                "__init__": [
                    "self",
                    "copy_X",
                    "copy_Gram",
                    "copy_Xy",
                    "n_nonzero_coefs",
                    "tol",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "precompute_gram"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "Gram",
                    "Xy"
                ]
            },
            "OrthogonalMatchingPursuitCV": {
                "__init__": [
                    "self",
                    "copy",
                    "fit_intercept",
                    "normalize",
                    "max_iter",
                    "cv",
                    "n_jobs",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.linear_model.passive_aggressive": {
            "PassiveAggressiveClassifier": {
                "__init__": [
                    "self",
                    "C",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "loss",
                    "n_jobs",
                    "random_state",
                    "warm_start"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init"
                ]
            },
            "PassiveAggressiveRegressor": {
                "__init__": [
                    "self",
                    "C",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "loss",
                    "epsilon",
                    "random_state",
                    "class_weight",
                    "warm_start"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init"
                ]
            }
        },
        "sklearn.linear_model.coordinate_descent": {
            "_alpha_grid": [
                "X",
                "y",
                "Xy",
                "l1_ratio",
                "fit_intercept",
                "eps",
                "n_alphas",
                "normalize",
                "copy_X"
            ],
            "lasso_path": [
                "X",
                "y",
                "eps",
                "n_alphas",
                "alphas",
                "precompute",
                "Xy",
                "fit_intercept",
                "normalize",
                "copy_X",
                "verbose",
                "return_models"
            ],
            "enet_path": [
                "X",
                "y",
                "l1_ratio",
                "eps",
                "n_alphas",
                "alphas",
                "precompute",
                "Xy",
                "fit_intercept",
                "normalize",
                "copy_X",
                "verbose",
                "rho",
                "return_models"
            ],
            "_path_residuals": [
                "X",
                "y",
                "train",
                "test",
                "path",
                "path_params",
                "l1_ratio",
                "X_order",
                "dtype"
            ],
            "ElasticNet": {
                "__init__": [
                    "self",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "copy_X",
                    "tol",
                    "warm_start",
                    "positive",
                    "rho"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "Xy",
                    "coef_init"
                ],
                "sparse_coef_": [
                    "self"
                ],
                "decision_function": [
                    "self",
                    "X"
                ]
            },
            "Lasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "warm_start",
                    "positive"
                ]
            },
            "LinearModelCV": {
                "__init__": [
                    "self",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "tol",
                    "copy_X",
                    "cv",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "rho_": [
                    "self"
                ]
            },
            "LassoCV": {
                "__init__": [
                    "self",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "tol",
                    "copy_X",
                    "cv",
                    "verbose"
                ]
            },
            "ElasticNetCV": {
                "__init__": [
                    "self",
                    "l1_ratio",
                    "eps",
                    "n_alphas",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "tol",
                    "cv",
                    "copy_X",
                    "verbose",
                    "n_jobs",
                    "rho"
                ],
                "rho": [
                    "self"
                ]
            },
            "MultiTaskElasticNet": {
                "__init__": [
                    "self",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "warm_start",
                    "rho"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "Xy",
                    "coef_init"
                ]
            },
            "MultiTaskLasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "warm_start"
                ]
            }
        },
        "sklearn.linear_model.least_angle": {
            "lars_path": [
                "X",
                "y",
                "Xy",
                "Gram",
                "max_iter",
                "alpha_min",
                "method",
                "copy_X",
                "eps",
                "copy_Gram",
                "verbose",
                "return_path"
            ],
            "_lars_path_residues": [
                "X_train",
                "y_train",
                "X_test",
                "y_test",
                "Gram",
                "copy",
                "method",
                "verbose",
                "fit_intercept",
                "normalize",
                "max_iter",
                "eps"
            ],
            "Lars": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "n_nonzero_coefs",
                    "eps",
                    "copy_X",
                    "fit_path"
                ],
                "_get_gram": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "Xy"
                ]
            },
            "LassoLars": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "eps",
                    "copy_X",
                    "fit_path"
                ]
            },
            "LarsCV": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "verbose",
                    "max_iter",
                    "normalize",
                    "precompute",
                    "cv",
                    "max_n_alphas",
                    "n_jobs",
                    "eps",
                    "copy_X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "alpha": [
                    "self"
                ]
            },
            "LassoLarsCV": {},
            "LassoLarsIC": {
                "__init__": [
                    "self",
                    "criterion",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "eps",
                    "copy_X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "copy_X"
                ]
            }
        },
        "sklearn.linear_model.perceptron": {
            "Perceptron": {
                "__init__": [
                    "self",
                    "penalty",
                    "alpha",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "eta0",
                    "n_jobs",
                    "random_state",
                    "class_weight",
                    "warm_start",
                    "seed"
                ]
            }
        },
        "sklearn.linear_model.ridge": {
            "_solve_sparse_cg": [
                "X",
                "y",
                "alpha",
                "max_iter",
                "tol"
            ],
            "_solve_lsqr": [
                "X",
                "y",
                "alpha",
                "max_iter",
                "tol"
            ],
            "_solve_dense_cholesky": [
                "X",
                "y",
                "alpha"
            ],
            "_solve_dense_cholesky_kernel": [
                "K",
                "y",
                "alpha",
                "sample_weight"
            ],
            "_solve_svd": [
                "X",
                "y",
                "alpha"
            ],
            "ridge_regression": [
                "X",
                "y",
                "alpha",
                "sample_weight",
                "solver",
                "max_iter",
                "tol"
            ],
            "_BaseRidge": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "solver"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "Ridge": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "solver"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "RidgeClassifier": {
                "__init__": [
                    "self",
                    "alpha",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "max_iter",
                    "tol",
                    "class_weight",
                    "solver"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "classes_": [
                    "self"
                ]
            },
            "_RidgeGCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "scoring",
                    "score_func",
                    "loss_func",
                    "copy_X",
                    "gcv_mode",
                    "store_cv_values"
                ],
                "_pre_compute": [
                    "self",
                    "X",
                    "y"
                ],
                "_decomp_diag": [
                    "self",
                    "v_prime",
                    "Q"
                ],
                "_diag_dot": [
                    "self",
                    "D",
                    "B"
                ],
                "_errors": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "Q",
                    "QT_y"
                ],
                "_values": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "Q",
                    "QT_y"
                ],
                "_pre_compute_svd": [
                    "self",
                    "X",
                    "y"
                ],
                "_errors_svd": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "U",
                    "UT_y"
                ],
                "_values_svd": [
                    "self",
                    "alpha",
                    "y",
                    "v",
                    "U",
                    "UT_y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "_BaseRidgeCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "scoring",
                    "score_func",
                    "loss_func",
                    "cv",
                    "gcv_mode",
                    "store_cv_values"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ]
            },
            "RidgeCV": {},
            "RidgeClassifierCV": {
                "__init__": [
                    "self",
                    "alphas",
                    "fit_intercept",
                    "normalize",
                    "score_func",
                    "loss_func",
                    "cv",
                    "class_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight",
                    "class_weight"
                ],
                "classes_": [
                    "self"
                ]
            }
        },
        "sklearn.linear_model.randomized_l1": {
            "_resample_model": [
                "estimator_func",
                "X",
                "y",
                "scaling",
                "n_resampling",
                "n_jobs",
                "verbose",
                "pre_dispatch",
                "random_state",
                "sample_fraction"
            ],
            "_randomized_lasso": [
                "X",
                "y",
                "weights",
                "mask",
                "alpha",
                "verbose",
                "precompute",
                "eps",
                "max_iter"
            ],
            "_randomized_logistic": [
                "X",
                "y",
                "weights",
                "mask",
                "C",
                "verbose",
                "fit_intercept",
                "tol"
            ],
            "_lasso_stability_path": [
                "X",
                "y",
                "mask",
                "weights",
                "eps"
            ],
            "lasso_stability_path": [
                "X",
                "y",
                "scaling",
                "random_state",
                "n_resampling",
                "n_grid",
                "sample_fraction",
                "eps",
                "n_jobs",
                "verbose"
            ],
            "BaseRandomizedLinearModel": {
                "__init__": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_make_estimator_and_params": [
                    "self",
                    "X",
                    "y"
                ],
                "get_support": [
                    "self",
                    "indices"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            },
            "RandomizedLasso": {
                "__init__": [
                    "self",
                    "alpha",
                    "scaling",
                    "sample_fraction",
                    "n_resampling",
                    "selection_threshold",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "precompute",
                    "max_iter",
                    "eps",
                    "random_state",
                    "n_jobs",
                    "pre_dispatch",
                    "memory"
                ],
                "_make_estimator_and_params": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RandomizedLogisticRegression": {
                "__init__": [
                    "self",
                    "C",
                    "scaling",
                    "sample_fraction",
                    "n_resampling",
                    "selection_threshold",
                    "tol",
                    "fit_intercept",
                    "verbose",
                    "normalize",
                    "random_state",
                    "n_jobs",
                    "pre_dispatch",
                    "memory"
                ],
                "_make_estimator_and_params": [
                    "self",
                    "X",
                    "y"
                ],
                "_center_data": [
                    "self",
                    "X",
                    "y",
                    "fit_intercept",
                    "normalize"
                ]
            }
        },
        "sklearn.linear_model.stochastic_gradient": {
            "_check_fit_data": [
                "X",
                "y"
            ],
            "_make_dataset": [
                "X",
                "y_i",
                "sample_weight"
            ],
            "_prepare_fit_binary": [
                "est",
                "y",
                "i"
            ],
            "fit_binary": [
                "est",
                "i",
                "X",
                "y",
                "alpha",
                "C",
                "learning_rate",
                "n_iter",
                "pos_weight",
                "neg_weight",
                "sample_weight"
            ],
            "BaseSGD": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "C",
                    "l1_ratio",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "warm_start",
                    "rho"
                ],
                "set_params": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_validate_params": [
                    "self"
                ],
                "_init_t": [
                    "self",
                    "loss_function"
                ],
                "_get_loss_function": [
                    "self",
                    "loss"
                ],
                "_get_learning_rate_type": [
                    "self",
                    "learning_rate"
                ],
                "_get_penalty_type": [
                    "self",
                    "penalty"
                ],
                "_validate_sample_weight": [
                    "self",
                    "sample_weight",
                    "n_samples"
                ],
                "_set_coef": [
                    "self",
                    "coef_"
                ],
                "_allocate_parameter_mem": [
                    "self",
                    "n_classes",
                    "n_features",
                    "coef_init",
                    "intercept_init"
                ]
            },
            "BaseSGDClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "n_jobs",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "class_weight",
                    "warm_start",
                    "rho",
                    "seed"
                ],
                "seed": [
                    "self"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "n_iter",
                    "classes",
                    "sample_weight",
                    "coef_init",
                    "intercept_init"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "coef_init",
                    "intercept_init",
                    "class_weight",
                    "sample_weight"
                ],
                "_fit_binary": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "sample_weight",
                    "learning_rate",
                    "n_iter"
                ],
                "_fit_multiclass": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "learning_rate",
                    "sample_weight",
                    "n_iter"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "classes",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init",
                    "class_weight",
                    "sample_weight"
                ]
            },
            "SGDClassifier": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "n_jobs",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "class_weight",
                    "warm_start",
                    "rho",
                    "seed"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "BaseSGDRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "warm_start",
                    "rho"
                ],
                "_partial_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "n_iter",
                    "sample_weight",
                    "coef_init",
                    "intercept_init"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "sample_weight"
                ],
                "_fit": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "coef_init",
                    "intercept_init",
                    "sample_weight"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "coef_init",
                    "intercept_init",
                    "sample_weight"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_fit_regressor": [
                    "self",
                    "X",
                    "y",
                    "alpha",
                    "C",
                    "loss",
                    "learning_rate",
                    "sample_weight",
                    "n_iter"
                ]
            },
            "SGDRegressor": {
                "__init__": [
                    "self",
                    "loss",
                    "penalty",
                    "alpha",
                    "l1_ratio",
                    "fit_intercept",
                    "n_iter",
                    "shuffle",
                    "verbose",
                    "epsilon",
                    "random_state",
                    "learning_rate",
                    "eta0",
                    "power_t",
                    "warm_start",
                    "rho"
                ]
            }
        },
        "sklearn.linear_model.bayes": {
            "BayesianRidge": {
                "__init__": [
                    "self",
                    "n_iter",
                    "tol",
                    "alpha_1",
                    "alpha_2",
                    "lambda_1",
                    "lambda_2",
                    "compute_score",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "ARDRegression": {
                "__init__": [
                    "self",
                    "n_iter",
                    "tol",
                    "alpha_1",
                    "alpha_2",
                    "lambda_1",
                    "lambda_2",
                    "compute_score",
                    "threshold_lambda",
                    "fit_intercept",
                    "normalize",
                    "copy_X",
                    "verbose"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.linear_model.base": {
            "sparse_center_data": [
                "X",
                "y",
                "fit_intercept",
                "normalize"
            ],
            "center_data": [
                "X",
                "y",
                "fit_intercept",
                "normalize",
                "copy",
                "sample_weight"
            ],
            "_pre_fit": [
                "X",
                "y",
                "Xy",
                "precompute",
                "normalize",
                "fit_intercept",
                "copy"
            ],
            "LinearModel": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_set_intercept": [
                    "self",
                    "X_mean",
                    "y_mean",
                    "X_std"
                ]
            },
            "LinearClassifierMixin": {
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "_predict_proba_lr": [
                    "self",
                    "X"
                ]
            },
            "SparseCoefMixin": {
                "densify": [
                    "self"
                ],
                "sparsify": [
                    "self"
                ]
            },
            "LinearRegression": {
                "__init__": [
                    "self",
                    "fit_intercept",
                    "normalize",
                    "copy_X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y",
                    "n_jobs"
                ]
            }
        },
        "sklearn.linear_model.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.linear_model.logistic": {
            "LogisticRegression": {
                "__init__": [
                    "self",
                    "penalty",
                    "dual",
                    "tol",
                    "C",
                    "fit_intercept",
                    "intercept_scaling",
                    "class_weight",
                    "random_state"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.linear_model": {},
        "sklearn.linear_model.tests.test_logistic": {
            "check_predictions": [
                "clf",
                "X",
                "y"
            ],
            "test_predict_2_classes": [],
            "test_error": [],
            "test_predict_3_classes": [],
            "test_predict_iris": [],
            "test_sparsify": [],
            "test_inconsistent_input": [],
            "test_write_parameters": [],
            "test_nan": [],
            "test_liblinear_random_state": []
        },
        "sklearn.linear_model.tests.test_sgd": {
            "SparseSGDClassifier": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "predict_log_proba": [
                    "self",
                    "X"
                ]
            },
            "SparseSGDRegressor": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ],
                "decision_function": [
                    "self",
                    "X"
                ]
            },
            "CommonTest": {
                "_test_warm_start": [
                    "self",
                    "X",
                    "Y",
                    "lr"
                ],
                "test_warm_start_constant": [
                    "self"
                ],
                "test_warm_start_invscaling": [
                    "self"
                ],
                "test_warm_start_optimal": [
                    "self"
                ],
                "test_warm_start_multiclass": [
                    "self"
                ],
                "test_multiple_fit": [
                    "self"
                ],
                "test_input_format": [
                    "self"
                ],
                "test_clone": [
                    "self"
                ]
            },
            "DenseSGDClassifierTestCase": {
                "test_sgd": [
                    "self"
                ],
                "test_sgd_bad_l1_ratio": [
                    "self"
                ],
                "test_sgd_bad_learning_rate_schedule": [
                    "self"
                ],
                "test_sgd_bad_eta0": [
                    "self"
                ],
                "test_sgd_bad_alpha": [
                    "self"
                ],
                "test_sgd_bad_penalty": [
                    "self"
                ],
                "test_sgd_bad_loss": [
                    "self"
                ],
                "test_sgd_n_iter_param": [
                    "self"
                ],
                "test_sgd_shuffle_param": [
                    "self"
                ],
                "test_argument_coef": [
                    "self"
                ],
                "test_provide_coef": [
                    "self"
                ],
                "test_set_intercept": [
                    "self"
                ],
                "test_set_intercept_binary": [
                    "self"
                ],
                "test_set_intercept_to_intercept": [
                    "self"
                ],
                "test_sgd_at_least_two_labels": [
                    "self"
                ],
                "test_sgd_multiclass": [
                    "self"
                ],
                "test_sgd_multiclass_with_init_coef": [
                    "self"
                ],
                "test_sgd_multiclass_njobs": [
                    "self"
                ],
                "test_set_coef_multiclass": [
                    "self"
                ],
                "test_sgd_proba": [
                    "self"
                ],
                "test_sgd_l1": [
                    "self"
                ],
                "test_class_weights": [
                    "self"
                ],
                "test_equal_class_weight": [
                    "self"
                ],
                "test_wrong_class_weight_label": [
                    "self"
                ],
                "test_wrong_class_weight_format": [
                    "self"
                ],
                "test_auto_weight": [
                    "self"
                ],
                "test_sample_weights": [
                    "self"
                ],
                "test_wrong_sample_weights": [
                    "self"
                ],
                "test_partial_fit_exception": [
                    "self"
                ],
                "test_partial_fit_binary": [
                    "self"
                ],
                "test_partial_fit_multiclass": [
                    "self"
                ],
                "_test_partial_fit_equal_fit": [
                    "self",
                    "lr"
                ],
                "test_partial_fit_equal_fit_constant": [
                    "self"
                ],
                "test_partial_fit_equal_fit_optimal": [
                    "self"
                ],
                "test_partial_fit_equal_fit_invscaling": [
                    "self"
                ],
                "test_regression_losses": [
                    "self"
                ]
            },
            "SparseSGDClassifierTestCase": {},
            "DenseSGDRegressorTestCase": {
                "test_sgd": [
                    "self"
                ],
                "test_sgd_bad_penalty": [
                    "self"
                ],
                "test_sgd_bad_loss": [
                    "self"
                ],
                "test_sgd_least_squares_fit": [
                    "self"
                ],
                "test_sgd_epsilon_insensitive": [
                    "self"
                ],
                "test_sgd_huber_fit": [
                    "self"
                ],
                "test_elasticnet_convergence": [
                    "self"
                ],
                "test_partial_fit": [
                    "self"
                ],
                "_test_partial_fit_equal_fit": [
                    "self",
                    "lr"
                ],
                "test_partial_fit_equal_fit_constant": [
                    "self"
                ],
                "test_partial_fit_equal_fit_optimal": [
                    "self"
                ],
                "test_partial_fit_equal_fit_invscaling": [
                    "self"
                ],
                "test_loss_function_epsilon": [
                    "self"
                ]
            },
            "SparseSGDRegressorTestCase": {}
        },
        "sklearn.linear_model.tests.test_base": {
            "test_linear_regression": [],
            "test_fit_intercept": [],
            "test_linear_regression_sparse": [
                "random_state"
            ],
            "test_linear_regression_multiple_outcome": [
                "random_state"
            ],
            "test_linear_regression_sparse_multiple_outcome": [
                "random_state"
            ]
        },
        "sklearn.linear_model.tests.test_randomized_l1": {
            "test_lasso_stability_path": [],
            "test_randomized_lasso": [],
            "test_randomized_logistic": [],
            "test_randomized_logistic_sparse": []
        },
        "sklearn.linear_model.tests.test_passive_aggressive": {
            "test_classifier_accuracy": [],
            "test_classifier_partial_fit": [],
            "test_classifier_refit": [],
            "test_classifier_correctness": [],
            "test_classifier_undefined_methods": [],
            "test_regressor_mse": [],
            "test_regressor_partial_fit": [],
            "test_regressor_correctness": [],
            "test_regressor_undefined_methods": [],
            "MyPassiveAggressive": {
                "__init__": [
                    "self",
                    "C",
                    "epsilon",
                    "loss",
                    "fit_intercept",
                    "n_iter",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "project": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.linear_model.tests.test_perceptron": {
            "test_perceptron_accuracy": [],
            "test_perceptron_correctness": [],
            "test_undefined_methods": [],
            "MyPerceptron": {
                "__init__": [
                    "self",
                    "n_iter"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "project": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.linear_model.tests.test_coordinate_descent": {
            "check_warnings": [],
            "test_lasso_zero": [],
            "test_lasso_toy": [],
            "test_enet_toy": [],
            "build_dataset": [
                "n_samples",
                "n_features",
                "n_informative_features",
                "n_targets"
            ],
            "test_lasso_cv": [],
            "test_lasso_path_return_models_vs_new_return_gives_same_coefficients": [],
            "test_enet_path": [],
            "test_path_parameters": [],
            "test_warm_start": [],
            "test_lasso_alpha_warning": [],
            "test_lasso_positive_constraint": [],
            "test_enet_positive_constraint": [],
            "test_multi_task_lasso_and_enet": [],
            "test_enet_multitarget": []
        },
        "sklearn.linear_model.tests.test_ridge": {
            "test_ridge": [],
            "test_ridge_singular": [],
            "test_ridge_sample_weights": [],
            "test_ridge_shapes": [],
            "test_ridge_intercept": [],
            "test_toy_ridge_object": [],
            "test_ridge_vs_lstsq": [],
            "test_ridge_individual_penalties": [],
            "_test_ridge_loo": [
                "filter_"
            ],
            "_test_ridge_cv": [
                "filter_"
            ],
            "_test_ridge_diabetes": [
                "filter_"
            ],
            "_test_multi_ridge_diabetes": [
                "filter_"
            ],
            "_test_ridge_classifiers": [
                "filter_"
            ],
            "_test_tolerance": [
                "filter_"
            ],
            "test_dense_sparse": [],
            "test_ridge_cv_sparse_svd": [],
            "test_class_weights": [],
            "test_class_weights_cv": [],
            "test_ridgecv_store_cv_values": []
        },
        "sklearn.linear_model.tests.test_least_angle": {
            "test_simple": [],
            "test_simple_precomputed": [],
            "test_all_precomputed": [],
            "test_lars_lstsq": [],
            "test_lasso_gives_lstsq_solution": [],
            "test_collinearity": [],
            "test_no_path": [],
            "test_no_path_precomputed": [],
            "test_no_path_all_precomputed": [],
            "test_singular_matrix": [],
            "test_rank_deficient_design": [],
            "test_lasso_lars_vs_lasso_cd": [
                "verbose"
            ],
            "test_lasso_lars_vs_lasso_cd_early_stopping": [
                "verbose"
            ],
            "test_lasso_lars_path_length": [],
            "test_lasso_lars_vs_lasso_cd_ill_conditioned": [],
            "test_lars_drop_for_good": [],
            "test_lars_add_features": [],
            "test_lars_n_nonzero_coefs": [
                "verbose"
            ],
            "test_multitarget": [],
            "test_lars_cv": [],
            "test_lasso_lars_ic": []
        },
        "sklearn.linear_model.tests.test_sparse_coordinate_descent": {
            "test_sparse_coef": [],
            "test_normalize_option": [],
            "test_lasso_zero": [],
            "test_enet_toy_list_input": [],
            "test_enet_toy_explicit_sparse_input": [],
            "make_sparse_data": [
                "n_samples",
                "n_features",
                "n_informative",
                "seed",
                "positive",
                "n_targets"
            ],
            "_test_sparse_enet_not_as_toy_dataset": [
                "alpha",
                "fit_intercept",
                "positive"
            ],
            "test_sparse_enet_not_as_toy_dataset": [],
            "test_sparse_lasso_not_as_toy_dataset": [],
            "test_enet_multitarget": [],
            "test_path_parameters": []
        },
        "sklearn.linear_model.tests.test_bayes": {
            "test_bayesian_on_diabetes": [],
            "test_toy_bayesian_ridge_object": [],
            "test_toy_ard_object": []
        },
        "sklearn.linear_model.tests.test_omp": {
            "test_correct_shapes": [],
            "test_correct_shapes_gram": [],
            "test_n_nonzero_coefs": [],
            "test_tol": [],
            "test_with_without_gram": [],
            "test_with_without_gram_tol": [],
            "test_unreachable_accuracy": [],
            "test_bad_input": [],
            "test_perfect_signal_recovery": [],
            "test_estimator": [],
            "test_scaling_with_gram": [],
            "test_identical_regressors": [],
            "test_swapped_regressors": [],
            "test_no_atoms": [],
            "test_omp_path": [],
            "test_omp_cv": [],
            "test_omp_reaches_least_squares": []
        },
        "sklearn.linear_model.tests": {},
        "sklearn.cluster.spectral": {
            "discretize": [
                "vectors",
                "copy",
                "max_svd_restarts",
                "n_iter_max",
                "random_state"
            ],
            "spectral_clustering": [
                "affinity",
                "n_clusters",
                "n_components",
                "eigen_solver",
                "random_state",
                "n_init",
                "k",
                "eigen_tol",
                "assign_labels",
                "mode"
            ],
            "SpectralClustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "eigen_solver",
                    "random_state",
                    "n_init",
                    "gamma",
                    "affinity",
                    "n_neighbors",
                    "k",
                    "eigen_tol",
                    "assign_labels",
                    "mode",
                    "degree",
                    "coef0",
                    "kernel_params"
                ],
                "fit": [
                    "self",
                    "X"
                ],
                "_pairwise": [
                    "self"
                ],
                "mode": [
                    "self"
                ],
                "k": [
                    "self"
                ]
            }
        },
        "sklearn.cluster.k_means_": {
            "_k_init": [
                "X",
                "n_clusters",
                "n_local_trials",
                "random_state",
                "x_squared_norms"
            ],
            "_tolerance": [
                "X",
                "tol"
            ],
            "k_means": [
                "X",
                "n_clusters",
                "init",
                "precompute_distances",
                "n_init",
                "max_iter",
                "verbose",
                "tol",
                "random_state",
                "copy_x",
                "n_jobs"
            ],
            "_kmeans_single": [
                "X",
                "n_clusters",
                "max_iter",
                "init",
                "verbose",
                "x_squared_norms",
                "random_state",
                "tol",
                "precompute_distances"
            ],
            "_squared_norms": [
                "X"
            ],
            "_labels_inertia_precompute_dense": [
                "X",
                "x_squared_norms",
                "centers"
            ],
            "_labels_inertia": [
                "X",
                "x_squared_norms",
                "centers",
                "precompute_distances",
                "distances"
            ],
            "_init_centroids": [
                "X",
                "k",
                "init",
                "random_state",
                "x_squared_norms",
                "init_size"
            ],
            "_mini_batch_step": [
                "X",
                "x_squared_norms",
                "centers",
                "counts",
                "old_center_buffer",
                "compute_squared_diff",
                "distances",
                "random_reassign",
                "random_state",
                "reassignment_ratio",
                "verbose"
            ],
            "_mini_batch_convergence": [
                "model",
                "iteration_idx",
                "n_iter",
                "tol",
                "n_samples",
                "centers_squared_diff",
                "batch_inertia",
                "context",
                "verbose"
            ],
            "KMeans": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "init",
                    "n_init",
                    "max_iter",
                    "tol",
                    "precompute_distances",
                    "verbose",
                    "random_state",
                    "copy_x",
                    "n_jobs"
                ],
                "_check_fit_data": [
                    "self",
                    "X"
                ],
                "_check_test_data": [
                    "self",
                    "X"
                ],
                "_check_fitted": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_predict": [
                    "self",
                    "X"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_transform": [
                    "self",
                    "X"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "score": [
                    "self",
                    "X"
                ]
            },
            "MiniBatchKMeans": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "init",
                    "max_iter",
                    "batch_size",
                    "verbose",
                    "compute_labels",
                    "random_state",
                    "tol",
                    "max_no_improvement",
                    "init_size",
                    "n_init",
                    "reassignment_ratio"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.cluster.dbscan_": {
            "dbscan": [
                "X",
                "eps",
                "min_samples",
                "metric",
                "algorithm",
                "leaf_size",
                "p",
                "random_state"
            ],
            "DBSCAN": {
                "__init__": [
                    "self",
                    "eps",
                    "min_samples",
                    "metric",
                    "algorithm",
                    "leaf_size",
                    "p",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.cluster.hierarchical": {
            "ward_tree": [
                "X",
                "connectivity",
                "n_components",
                "copy",
                "n_clusters"
            ],
            "_fix_connectivity": [
                "X",
                "connectivity",
                "n_components",
                "labels"
            ],
            "_hc_cut": [
                "n_clusters",
                "children",
                "n_leaves"
            ],
            "Ward": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "memory",
                    "connectivity",
                    "copy",
                    "n_components",
                    "compute_full_tree"
                ],
                "fit": [
                    "self",
                    "X"
                ]
            },
            "WardAgglomeration": {
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.cluster._feature_agglomeration": {
            "AgglomerationTransform": {
                "transform": [
                    "self",
                    "X",
                    "pooling_func"
                ],
                "inverse_transform": [
                    "self",
                    "Xred"
                ]
            }
        },
        "sklearn.cluster.mean_shift_": {
            "estimate_bandwidth": [
                "X",
                "quantile",
                "n_samples",
                "random_state"
            ],
            "mean_shift": [
                "X",
                "bandwidth",
                "seeds",
                "bin_seeding",
                "min_bin_freq",
                "cluster_all",
                "max_iterations"
            ],
            "get_bin_seeds": [
                "X",
                "bin_size",
                "min_bin_freq"
            ],
            "MeanShift": {
                "__init__": [
                    "self",
                    "bandwidth",
                    "seeds",
                    "bin_seeding",
                    "min_bin_freq",
                    "cluster_all"
                ],
                "fit": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.cluster.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.cluster": {
            "spectral_embedding": []
        },
        "sklearn.cluster.affinity_propagation_": {
            "affinity_propagation": [
                "S",
                "preference",
                "convergence_iter",
                "max_iter",
                "damping",
                "copy",
                "verbose"
            ],
            "AffinityPropagation": {
                "__init__": [
                    "self",
                    "damping",
                    "max_iter",
                    "convergence_iter",
                    "copy",
                    "preference",
                    "affinity",
                    "verbose"
                ],
                "_pairwise": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.cluster.tests.test_affinity_propagation": {
            "test_affinity_propagation": []
        },
        "sklearn.cluster.tests.test_hierarchical": {
            "test_structured_ward_tree": [],
            "test_unstructured_ward_tree": [],
            "test_height_ward_tree": [],
            "test_ward_clustering": [],
            "test_ward_agglomeration": [],
            "assess_same_labelling": [
                "cut1",
                "cut2"
            ],
            "test_scikit_vs_scipy": [],
            "test_connectivity_popagation": [],
            "test_connectivity_fixing_non_lil": []
        },
        "sklearn.cluster.tests.test_dbscan": {
            "test_dbscan_similarity": [],
            "test_dbscan_feature": [],
            "test_dbscan_callable": [],
            "test_dbscan_balltree": [],
            "test_dbscan_badargs": [],
            "test_pickle": []
        },
        "sklearn.cluster.tests.test_mean_shift": {
            "test_mean_shift": [],
            "test_unfitted": [],
            "test_bin_seeds": []
        },
        "sklearn.cluster.tests.common": {
            "generate_clustered_data": [
                "seed",
                "n_clusters",
                "n_features",
                "n_samples_per_cluster",
                "std"
            ]
        },
        "sklearn.cluster.tests.test_spectral": {
            "test_spectral_clustering": [],
            "test_spectral_lobpcg_mode": [],
            "test_spectral_amg_mode": [],
            "test_spectral_unknown_mode": [],
            "test_spectral_unknown_assign_labels": [],
            "test_spectral_clustering_sparse": [],
            "test_affinities": [],
            "test_discretize": [
                "seed"
            ]
        },
        "sklearn.cluster.tests.test_k_means": {
            "test_square_norms": [],
            "test_kmeans_dtype": [],
            "test_labels_assignment_and_inertia": [],
            "test_minibatch_update_consistency": [],
            "_check_fitted_model": [
                "km"
            ],
            "test_k_means_plus_plus_init": [],
            "test_k_means_check_fitted": [],
            "test_k_means_new_centers": [],
            "_is_mac_os_version_ge": [
                "version"
            ],
            "test_k_means_plus_plus_init_2_jobs": [],
            "test_k_means_plus_plus_init_sparse": [],
            "test_k_means_random_init": [],
            "test_k_means_random_init_sparse": [],
            "test_k_means_plus_plus_init_not_precomputed": [],
            "test_k_means_random_init_not_precomputed": [],
            "test_k_means_perfect_init": [],
            "test_mb_k_means_plus_plus_init_dense_array": [],
            "test_mb_kmeans_verbose": [],
            "test_mb_k_means_plus_plus_init_sparse_matrix": [],
            "test_minibatch_init_with_large_k": [],
            "test_minibatch_k_means_random_init_dense_array": [],
            "test_minibatch_k_means_random_init_sparse_csr": [],
            "test_minibatch_k_means_perfect_init_dense_array": [],
            "test_minibatch_k_means_perfect_init_sparse_csr": [],
            "test_minibatch_reassign": [],
            "test_sparse_mb_k_means_callable_init": [],
            "test_mini_batch_k_means_random_init_partial_fit": [],
            "test_minibatch_default_init_size": [],
            "test_minibatch_tol": [],
            "test_minibatch_set_init_size": [],
            "test_k_means_invalid_init": [],
            "test_mini_match_k_means_invalid_init": [],
            "test_k_means_copyx": [],
            "test_k_means_non_collapsed": [],
            "test_predict": [],
            "test_score": [],
            "test_predict_minibatch_dense_input": [],
            "test_predict_minibatch_kmeanspp_init_sparse_input": [],
            "test_predict_minibatch_random_init_sparse_input": [],
            "test_input_dtypes": [],
            "test_transform": [],
            "test_fit_transform": [],
            "test_n_init": [],
            "test_k_means_function": []
        },
        "sklearn.cluster.tests": {},
        "sklearn.cluster.bicluster.spectral": {
            "_scale_normalize": [
                "X"
            ],
            "_bistochastic_normalize": [
                "X",
                "max_iter",
                "tol"
            ],
            "_log_normalize": [
                "X"
            ],
            "BaseSpectral": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "svd_method",
                    "n_svd_vecs",
                    "mini_batch",
                    "init",
                    "n_init",
                    "n_jobs",
                    "random_state"
                ],
                "_check_parameters": [
                    "self"
                ],
                "fit": [
                    "self",
                    "X"
                ],
                "_svd": [
                    "self",
                    "array",
                    "n_components",
                    "n_discard"
                ],
                "_k_means": [
                    "self",
                    "data",
                    "n_clusters"
                ]
            },
            "SpectralCoclustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "svd_method",
                    "n_svd_vecs",
                    "mini_batch",
                    "init",
                    "n_init",
                    "n_jobs",
                    "random_state"
                ],
                "_fit": [
                    "self",
                    "X"
                ]
            },
            "SpectralBiclustering": {
                "__init__": [
                    "self",
                    "n_clusters",
                    "method",
                    "n_components",
                    "n_best",
                    "svd_method",
                    "n_svd_vecs",
                    "mini_batch",
                    "init",
                    "n_init",
                    "n_jobs",
                    "random_state"
                ],
                "_check_parameters": [
                    "self"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "_fit_best_piecewise": [
                    "self",
                    "vectors",
                    "n_best",
                    "n_clusters"
                ],
                "_project_and_cluster": [
                    "self",
                    "data",
                    "vectors",
                    "n_clusters"
                ]
            }
        },
        "sklearn.cluster.bicluster.utils": {
            "check_array_ndim": [
                "X"
            ],
            "get_indices": [
                "rows",
                "columns"
            ],
            "get_indicators": [
                "rows",
                "columns",
                "shape"
            ],
            "get_shape": [
                "rows",
                "columns"
            ],
            "get_submatrix": [
                "rows",
                "columns",
                "data"
            ]
        },
        "sklearn.cluster.bicluster": {},
        "sklearn.cluster.bicluster.tests.test_utils": {
            "test_get_indicators": [],
            "test_get_shape": [],
            "test_get_submatrix": []
        },
        "sklearn.cluster.bicluster.tests.test_spectral": {
            "test_spectral_coclustering": [],
            "test_spectral_biclustering": [],
            "_do_scale_test": [
                "scaled"
            ],
            "_do_bistochastic_test": [
                "scaled"
            ],
            "test_scale_normalize": [],
            "test_bistochastic_normalize": [],
            "test_log_normalize": [],
            "test_fit_best_piecewise": [],
            "test_project_and_cluster": [],
            "test_perfect_checkerboard": [],
            "test_errors": []
        },
        "sklearn.cluster.bicluster.tests": {},
        "sklearn.__check_build.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.__check_build": {
            "raise_build_error": [
                "e"
            ]
        },
        "sklearn.semi_supervised.label_propagation": {
            "_not_converged": [
                "y_truth",
                "y_prediction",
                "tol"
            ],
            "BaseLabelPropagation": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "n_neighbors",
                    "alpha",
                    "max_iter",
                    "tol"
                ],
                "_get_kernel": [
                    "self",
                    "X",
                    "y"
                ],
                "_build_graph": [
                    "self"
                ],
                "predict": [
                    "self",
                    "X"
                ],
                "predict_proba": [
                    "self",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "LabelPropagation": {
                "_build_graph": [
                    "self"
                ]
            },
            "LabelSpreading": {
                "__init__": [
                    "self",
                    "kernel",
                    "gamma",
                    "n_neighbors",
                    "alpha",
                    "max_iter",
                    "tol"
                ],
                "_build_graph": [
                    "self"
                ]
            }
        },
        "sklearn.semi_supervised": {},
        "sklearn.decomposition.sparse_pca": {
            "SparsePCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "ridge_alpha",
                    "max_iter",
                    "tol",
                    "method",
                    "n_jobs",
                    "U_init",
                    "V_init",
                    "verbose",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "ridge_alpha"
                ]
            },
            "MiniBatchSparsePCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "ridge_alpha",
                    "n_iter",
                    "callback",
                    "batch_size",
                    "verbose",
                    "shuffle",
                    "n_jobs",
                    "method",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.decomposition.factor_analysis": {
            "FactorAnalysis": {
                "__init__": [
                    "self",
                    "n_components",
                    "tol",
                    "copy",
                    "max_iter",
                    "verbose",
                    "noise_variance_init"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "get_covariance": [
                    "self"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.decomposition.truncated_svd": {
            "TruncatedSVD": {
                "__init__": [
                    "self",
                    "n_components",
                    "algorithm",
                    "n_iterations",
                    "random_state",
                    "tol"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.decomposition.dict_learning": {
            "_sparse_encode": [
                "X",
                "dictionary",
                "gram",
                "cov",
                "algorithm",
                "regularization",
                "copy_cov",
                "init",
                "max_iter"
            ],
            "sparse_encode": [
                "X",
                "dictionary",
                "gram",
                "cov",
                "algorithm",
                "n_nonzero_coefs",
                "alpha",
                "copy_cov",
                "init",
                "max_iter",
                "n_jobs"
            ],
            "_update_dict": [
                "dictionary",
                "Y",
                "code",
                "verbose",
                "return_r2",
                "random_state"
            ],
            "dict_learning": [
                "X",
                "n_components",
                "alpha",
                "max_iter",
                "tol",
                "method",
                "n_jobs",
                "dict_init",
                "code_init",
                "callback",
                "verbose",
                "random_state"
            ],
            "dict_learning_online": [
                "X",
                "n_components",
                "alpha",
                "n_iter",
                "return_code",
                "dict_init",
                "callback",
                "batch_size",
                "verbose",
                "shuffle",
                "n_jobs",
                "method",
                "iter_offset",
                "random_state"
            ],
            "SparseCodingMixin": {
                "_set_sparse_coding_params": [
                    "self",
                    "n_components",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "split_sign",
                    "n_jobs"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "SparseCoder": {
                "__init__": [
                    "self",
                    "dictionary",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "split_sign",
                    "n_jobs"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "DictionaryLearning": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "max_iter",
                    "tol",
                    "fit_algorithm",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "n_jobs",
                    "code_init",
                    "dict_init",
                    "verbose",
                    "split_sign",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "MiniBatchDictionaryLearning": {
                "__init__": [
                    "self",
                    "n_components",
                    "alpha",
                    "n_iter",
                    "fit_algorithm",
                    "n_jobs",
                    "batch_size",
                    "shuffle",
                    "dict_init",
                    "transform_algorithm",
                    "transform_n_nonzero_coefs",
                    "transform_alpha",
                    "verbose",
                    "split_sign",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "partial_fit": [
                    "self",
                    "X",
                    "y",
                    "iter_offset"
                ]
            }
        },
        "sklearn.decomposition.nmf": {
            "safe_vstack": [
                "Xs"
            ],
            "norm": [
                "x"
            ],
            "_sparseness": [
                "x"
            ],
            "check_non_negative": [
                "X",
                "whom"
            ],
            "_initialize_nmf": [
                "X",
                "n_components",
                "variant",
                "eps",
                "random_state"
            ],
            "_nls_subproblem": [
                "V",
                "W",
                "H_init",
                "tol",
                "max_iter",
                "sigma",
                "beta"
            ],
            "ProjectedGradientNMF": {
                "__init__": [
                    "self",
                    "n_components",
                    "init",
                    "sparseness",
                    "beta",
                    "eta",
                    "tol",
                    "max_iter",
                    "nls_max_iter",
                    "random_state"
                ],
                "_init": [
                    "self",
                    "X"
                ],
                "_update_W": [
                    "self",
                    "X",
                    "H",
                    "W",
                    "tolW"
                ],
                "_update_H": [
                    "self",
                    "X",
                    "H",
                    "W",
                    "tolH"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ]
            },
            "NMF": {}
        },
        "sklearn.decomposition.fastica_": {
            "_gs_decorrelation": [
                "w",
                "W",
                "j"
            ],
            "_sym_decorrelation": [
                "W"
            ],
            "_ica_def": [
                "X",
                "tol",
                "g",
                "fun_args",
                "max_iter",
                "w_init"
            ],
            "_ica_par": [
                "X",
                "tol",
                "g",
                "fun_args",
                "max_iter",
                "w_init"
            ],
            "_logcosh": [
                "x",
                "fun_args"
            ],
            "_exp": [
                "x",
                "fun_args"
            ],
            "_cube": [
                "x",
                "fun_args"
            ],
            "fastica": [
                "X",
                "n_components",
                "algorithm",
                "whiten",
                "fun",
                "fun_args",
                "max_iter",
                "tol",
                "w_init",
                "random_state",
                "return_X_mean",
                "compute_sources"
            ],
            "FastICA": {
                "__init__": [
                    "self",
                    "n_components",
                    "algorithm",
                    "whiten",
                    "fun",
                    "fun_args",
                    "max_iter",
                    "tol",
                    "w_init",
                    "random_state"
                ],
                "_fit": [
                    "self",
                    "X",
                    "compute_sources"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X",
                    "y",
                    "copy"
                ],
                "get_mixing_matrix": [
                    "self"
                ],
                "sources_": [
                    "self"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "copy"
                ]
            }
        },
        "sklearn.decomposition.pca": {
            "_assess_dimension_": [
                "spectrum",
                "rank",
                "n_samples",
                "n_features"
            ],
            "_infer_dimension_": [
                "spectrum",
                "n_samples",
                "n_features"
            ],
            "PCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "copy",
                    "whiten"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            },
            "ProbabilisticPCA": {
                "fit": [
                    "self",
                    "X",
                    "y",
                    "homoscedastic"
                ],
                "score": [
                    "self",
                    "X",
                    "y"
                ]
            },
            "RandomizedPCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "copy",
                    "iterated_power",
                    "whiten",
                    "random_state"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "_fit": [
                    "self",
                    "X"
                ],
                "transform": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "inverse_transform": [
                    "self",
                    "X",
                    "y"
                ]
            }
        },
        "sklearn.decomposition": {},
        "sklearn.decomposition.kernel_pca": {
            "KernelPCA": {
                "__init__": [
                    "self",
                    "n_components",
                    "kernel",
                    "gamma",
                    "degree",
                    "coef0",
                    "kernel_params",
                    "alpha",
                    "fit_inverse_transform",
                    "eigen_solver",
                    "tol",
                    "max_iter",
                    "remove_zero_eig"
                ],
                "_pairwise": [
                    "self"
                ],
                "_get_kernel": [
                    "self",
                    "X",
                    "Y"
                ],
                "_fit_transform": [
                    "self",
                    "K"
                ],
                "_fit_inverse_transform": [
                    "self",
                    "X_transformed",
                    "X"
                ],
                "fit": [
                    "self",
                    "X",
                    "y"
                ],
                "fit_transform": [
                    "self",
                    "X",
                    "y"
                ],
                "transform": [
                    "self",
                    "X"
                ],
                "inverse_transform": [
                    "self",
                    "X"
                ]
            }
        },
        "sklearn.decomposition.tests.test_nmf": {
            "test_initialize_nn_input": [],
            "test_initialize_nn_output": [],
            "test_initialize_close": [],
            "test_initialize_variants": [],
            "test_projgrad_nmf_fit_nn_input": [],
            "test_projgrad_nmf_fit_nn_output": [],
            "test_projgrad_nmf_fit_close": [],
            "test_nls_nn_input": [],
            "test_nls_nn_output": [],
            "test_nls_close": [],
            "test_projgrad_nmf_transform": [],
            "test_n_components_greater_n_features": [],
            "test_projgrad_nmf_sparseness": [],
            "test_sparse_input": [],
            "test_sparse_transform": []
        },
        "sklearn.decomposition.tests.test_kernel_pca": {
            "test_kernel_pca": [],
            "test_invalid_parameters": [],
            "test_kernel_pca_sparse": [],
            "test_kernel_pca_linear_kernel": [],
            "test_kernel_pca_n_components": [],
            "test_remove_zero_eig": [],
            "test_kernel_pca_precomputed": [],
            "test_kernel_pca_invalid_kernel": [],
            "test_gridsearch_pipeline": [],
            "test_gridsearch_pipeline_precomputed": [],
            "test_nested_circles": []
        },
        "sklearn.decomposition.tests.test_truncated_svd": {
            "test_algorithms": [],
            "test_attributes": [],
            "test_too_many_components": [],
            "test_sparse_formats": [],
            "test_inverse_transform": [],
            "test_integers": []
        },
        "sklearn.decomposition.tests.test_sparse_pca": {
            "generate_toy_data": [
                "n_components",
                "n_samples",
                "image_size",
                "random_state"
            ],
            "test_correct_shapes": [],
            "test_fit_transform": [],
            "test_transform_nan": [],
            "test_fit_transform_tall": [],
            "test_initialization": [],
            "test_mini_batch_correct_shapes": [],
            "test_mini_batch_fit_transform": []
        },
        "sklearn.decomposition.tests.test_fastica": {
            "center_and_norm": [
                "x",
                "axis"
            ],
            "test_gs": [],
            "test_fastica_simple": [
                "add_noise"
            ],
            "test_fastica_nowhiten": [],
            "test_non_square_fastica": [
                "add_noise"
            ],
            "test_fit_transform": [],
            "test_inverse_transform": []
        },
        "sklearn.decomposition.tests.test_pca": {
            "test_pca": [],
            "test_whitening": [],
            "test_pca_check_projection": [],
            "test_pca_inverse": [],
            "test_randomized_pca_check_projection": [],
            "test_randomized_pca_check_list": [],
            "test_randomized_pca_inverse": [],
            "test_sparse_randomized_pca_check_projection": [],
            "test_sparse_randomized_pca_inverse": [],
            "test_pca_dim": [],
            "test_infer_dim_1": [],
            "test_infer_dim_2": [],
            "test_infer_dim_3": [],
            "test_infer_dim_by_explained_variance": [],
            "test_probabilistic_pca_1": [],
            "test_probabilistic_pca_2": [],
            "test_probabilistic_pca_3": [],
            "test_probabilistic_pca_4": []
        },
        "sklearn.decomposition.tests.test_factor_analysis": {
            "test_factor_analysis": []
        },
        "sklearn.decomposition.tests.test_dict_learning": {
            "test_dict_learning_shapes": [],
            "test_dict_learning_overcomplete": [],
            "test_dict_learning_reconstruction": [],
            "test_dict_learning_nonzero_coefs": [],
            "test_dict_learning_unknown_fit_algorithm": [],
            "test_dict_learning_split": [],
            "test_dict_learning_online_shapes": [],
            "test_dict_learning_online_verbosity": [],
            "test_dict_learning_online_estimator_shapes": [],
            "test_dict_learning_online_overcomplete": [],
            "test_dict_learning_online_initialization": [],
            "test_dict_learning_online_partial_fit": [],
            "test_sparse_encode_shapes": [],
            "test_sparse_encode_error": [],
            "test_unknown_method": [],
            "test_sparse_coder_estimator": []
        },
        "sklearn.decomposition.tests": {},
        "sklearn.utils.multiclass": {
            "_unique_multiclass": [
                "y"
            ],
            "_unique_sequence_of_sequence": [
                "y"
            ],
            "_unique_indicator": [
                "y"
            ],
            "unique_labels": [],
            "_is_integral_float": [
                "y"
            ],
            "is_label_indicator_matrix": [
                "y"
            ],
            "is_sequence_of_sequences": [
                "y"
            ],
            "is_multilabel": [
                "y"
            ],
            "type_of_target": [
                "y"
            ],
            "_check_partial_fit_first_call": [
                "clf",
                "classes"
            ]
        },
        "sklearn.utils.extmath": {
            "norm": [
                "v"
            ],
            "_fast_logdet": [
                "A"
            ],
            "_fast_logdet_numpy": [
                "A"
            ],
            "density": [
                "w"
            ],
            "safe_sparse_dot": [
                "a",
                "b",
                "dense_output"
            ],
            "randomized_range_finder": [
                "A",
                "size",
                "n_iter",
                "random_state",
                "n_iterations"
            ],
            "randomized_svd": [
                "M",
                "n_components",
                "n_oversamples",
                "n_iter",
                "transpose",
                "flip_sign",
                "random_state",
                "n_iterations"
            ],
            "logsumexp": [
                "arr",
                "axis"
            ],
            "weighted_mode": [
                "a",
                "w",
                "axis"
            ],
            "pinvh": [
                "a",
                "cond",
                "rcond",
                "lower"
            ],
            "cartesian": [
                "arrays",
                "out"
            ],
            "svd_flip": [
                "u",
                "v"
            ],
            "logistic_sigmoid": [
                "X",
                "log",
                "out"
            ],
            "safe_min": [
                "X"
            ],
            "make_nonnegative": [
                "X",
                "min_value"
            ]
        },
        "sklearn.utils.testing": {
            "_assert_less": [
                "a",
                "b",
                "msg"
            ],
            "_assert_greater": [
                "a",
                "b",
                "msg"
            ],
            "assert_warns": [
                "warning_class",
                "func"
            ],
            "assert_no_warnings": [
                "func"
            ],
            "_assert_allclose": [
                "actual",
                "desired",
                "rtol",
                "atol",
                "err_msg",
                "verbose"
            ],
            "assert_raise_message": [
                "exception",
                "message",
                "function"
            ],
            "fake_mldata": [
                "columns_dict",
                "dataname",
                "matfile",
                "ordering"
            ],
            "install_mldata_mock": [
                "mock_datasets"
            ],
            "uninstall_mldata_mock": [],
            "all_estimators": [
                "include_meta_estimators",
                "include_other",
                "type_filter"
            ],
            "set_random_state": [
                "estimator",
                "random_state"
            ],
            "if_matplotlib": [
                "func"
            ],
            "mock_mldata_urlopen": {
                "__init__": [
                    "self",
                    "mock_datasets"
                ],
                "__call__": [
                    "self",
                    "urlname"
                ]
            }
        },
        "sklearn.utils.graph": {
            "single_source_shortest_path_length": [
                "graph",
                "source",
                "cutoff"
            ],
            "graph_laplacian": [
                "csgraph",
                "normed",
                "return_diag"
            ],
            "_laplacian_sparse": [
                "graph",
                "normed",
                "return_diag"
            ],
            "_laplacian_dense": [
                "graph",
                "normed",
                "return_diag"
            ]
        },
        "sklearn.utils.bench": {
            "total_seconds": [
                "delta"
            ]
        },
        "sklearn.utils.arpack": {
            "_aslinearoperator_with_dtype": [
                "m"
            ],
            "get_inv_matvec": [
                "M",
                "symmetric",
                "tol"
            ],
            "get_OPinv_matvec": [
                "A",
                "M",
                "sigma",
                "symmetric",
                "tol"
            ],
            "_eigs": [
                "A",
                "k",
                "M",
                "sigma",
                "which",
                "v0",
                "ncv",
                "maxiter",
                "tol",
                "return_eigenvectors",
                "Minv",
                "OPinv",
                "OPpart"
            ],
            "_eigsh": [
                "A",
                "k",
                "M",
                "sigma",
                "which",
                "v0",
                "ncv",
                "maxiter",
                "tol",
                "return_eigenvectors",
                "Minv",
                "OPinv",
                "mode"
            ],
            "_svds": [
                "A",
                "k",
                "ncv",
                "tol"
            ],
            "ArpackError": {
                "__init__": [
                    "self",
                    "info",
                    "infodict"
                ]
            },
            "ArpackNoConvergence": {
                "__init__": [
                    "self",
                    "msg",
                    "eigenvalues",
                    "eigenvectors"
                ]
            },
            "_ArpackParams": {
                "__init__": [
                    "self",
                    "n",
                    "k",
                    "tp",
                    "mode",
                    "sigma",
                    "ncv",
                    "v0",
                    "maxiter",
                    "which",
                    "tol"
                ],
                "_raise_no_convergence": [
                    "self"
                ]
            },
            "_SymmetricArpackParams": {
                "__init__": [
                    "self",
                    "n",
                    "k",
                    "tp",
                    "matvec",
                    "mode",
                    "M_matvec",
                    "Minv_matvec",
                    "sigma",
                    "ncv",
                    "v0",
                    "maxiter",
                    "which",
                    "tol"
                ],
                "iterate": [
                    "self"
                ],
                "extract": [
                    "self",
                    "return_eigenvectors"
                ]
            },
            "_UnsymmetricArpackParams": {
                "__init__": [
                    "self",
                    "n",
                    "k",
                    "tp",
                    "matvec",
                    "mode",
                    "M_matvec",
                    "Minv_matvec",
                    "sigma",
                    "ncv",
                    "v0",
                    "maxiter",
                    "which",
                    "tol"
                ],
                "iterate": [
                    "self"
                ],
                "extract": [
                    "self",
                    "return_eigenvectors"
                ]
            },
            "SpLuInv": {
                "__init__": [
                    "self",
                    "M"
                ],
                "_matvec": [
                    "self",
                    "x"
                ]
            },
            "LuInv": {
                "__init__": [
                    "self",
                    "M"
                ],
                "_matvec": [
                    "self",
                    "x"
                ]
            },
            "IterInv": {
                "__init__": [
                    "self",
                    "M",
                    "ifunc",
                    "tol"
                ],
                "_matvec": [
                    "self",
                    "x"
                ]
            },
            "IterOpInv": {
                "__init__": [
                    "self",
                    "A",
                    "M",
                    "sigma",
                    "ifunc",
                    "tol"
                ],
                "mult_func": [
                    "self",
                    "x"
                ],
                "mult_func_M_None": [
                    "self",
                    "x"
                ],
                "_matvec": [
                    "self",
                    "x"
                ]
            }
        },
        "sklearn.utils.validation": {
            "_assert_all_finite": [
                "X"
            ],
            "assert_all_finite": [
                "X"
            ],
            "safe_asarray": [
                "X",
                "dtype",
                "order",
                "copy"
            ],
            "as_float_array": [
                "X",
                "copy"
            ],
            "array2d": [
                "X",
                "dtype",
                "order",
                "copy",
                "force_all_finite"
            ],
            "_atleast2d_or_sparse": [
                "X",
                "dtype",
                "order",
                "copy",
                "sparse_class",
                "convmethod",
                "force_all_finite"
            ],
            "atleast2d_or_csc": [
                "X",
                "dtype",
                "order",
                "copy",
                "force_all_finite"
            ],
            "atleast2d_or_csr": [
                "X",
                "dtype",
                "order",
                "copy",
                "force_all_finite"
            ],
            "_num_samples": [
                "x"
            ],
            "check_arrays": [],
            "column_or_1d": [
                "y",
                "warn"
            ],
            "warn_if_not_float": [
                "X",
                "estimator"
            ],
            "check_random_state": [
                "seed"
            ],
            "DataConversionWarning": {}
        },
        "sklearn.utils.fixes": {
            "lsqr": [
                "X",
                "y",
                "tol"
            ],
            "_unique": [
                "ar",
                "return_index",
                "return_inverse"
            ],
            "_bincount": [
                "X",
                "weights",
                "minlength"
            ],
            "_copysign": [
                "x1",
                "x2"
            ],
            "_in1d": [
                "ar1",
                "ar2",
                "assume_unique"
            ],
            "qr_economic": [
                "A"
            ],
            "savemat": [
                "file_name",
                "mdict",
                "oned_as"
            ]
        },
        "sklearn.utils.class_weight": {
            "compute_class_weight": [
                "class_weight",
                "classes",
                "y_ind"
            ]
        },
        "sklearn.utils.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.utils": {
            "safe_mask": [
                "X",
                "mask"
            ],
            "resample": [],
            "shuffle": [],
            "safe_sqr": [
                "X",
                "copy"
            ],
            "gen_even_slices": [
                "n",
                "n_packs"
            ],
            "tosequence": [
                "x"
            ],
            "deprecated": {
                "__init__": [
                    "self",
                    "extra"
                ],
                "__call__": [
                    "self",
                    "obj"
                ],
                "_decorate_class": [
                    "self",
                    "cls"
                ],
                "_decorate_fun": [
                    "self",
                    "fun"
                ],
                "_update_doc": [
                    "self",
                    "olddoc"
                ]
            },
            "ConvergenceWarning": {}
        },
        "sklearn.utils.linear_assignment_": {
            "linear_assignment": [
                "X"
            ],
            "_Hungarian": {
                "compute": [
                    "self",
                    "cost_matrix"
                ],
                "_step1": [
                    "self"
                ],
                "_step3": [
                    "self"
                ],
                "_step4": [
                    "self"
                ],
                "_step5": [
                    "self"
                ],
                "_step6": [
                    "self"
                ],
                "_find_prime_in_row": [
                    "self",
                    "row"
                ],
                "_clear_covers": [
                    "self"
                ]
            }
        },
        "sklearn.utils.sparsetools._graph_validation": {
            "validate_graph": [
                "csgraph",
                "directed",
                "dtype",
                "csr_output",
                "dense_output",
                "copy_if_dense",
                "copy_if_sparse",
                "null_value_in",
                "null_value_out",
                "infinity_null",
                "nan_null"
            ]
        },
        "sklearn.utils.sparsetools.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.utils.sparsetools": {},
        "sklearn.utils.tests.test_multiclass": {
            "test_unique_labels": [],
            "test_is_multilabel": [],
            "test_is_label_indicator_matrix": [],
            "test_is_sequence_of_sequences": [],
            "test_type_of_target": []
        },
        "sklearn.utils.tests.test_sparsefuncs": {
            "test_mean_variance_axis0": [],
            "test_densify_rows": []
        },
        "sklearn.utils.tests.test_extmath": {
            "test_density": [],
            "test_uniform_weights": [],
            "test_random_weights": [],
            "test_logsumexp": [],
            "test_randomized_svd_low_rank": [],
            "test_randomized_svd_low_rank_with_noise": [],
            "test_randomized_svd_infinite_rank": [],
            "test_randomized_svd_transpose_consistency": [],
            "test_randomized_svd_sign_flip": [],
            "test_cartesian": [],
            "test_logistic_sigmoid": []
        },
        "sklearn.utils.tests.test_validation": {
            "test_as_float_array": [],
            "test_check_arrays_exceptions": [],
            "test_np_matrix": [],
            "test_memmap": [],
            "test_ordering": [],
            "test_check_arrays": []
        },
        "sklearn.utils.tests.test_linear_assignment": {
            "test_hungarian": []
        },
        "sklearn.utils.tests.test_class_weight": {
            "test_compute_class_weight": [],
            "test_compute_class_weight_not_present": []
        },
        "sklearn.utils.tests.test_graph": {
            "test_graph_laplacian": []
        },
        "sklearn.utils.tests.test_utils": {
            "test_make_rng": [],
            "test_resample_noarg": [],
            "test_deprecated": [],
            "test_resample_value_errors": [],
            "test_safe_mask": [],
            "test_pinvh_simple_real": [],
            "test_pinvh_nonpositive": [],
            "test_pinvh_simple_complex": [],
            "test_column_or_1d": []
        },
        "sklearn.utils.tests.test_murmurhash": {
            "test_mmhash3_int": [],
            "test_mmhash3_int_array": [],
            "test_mmhash3_bytes": [],
            "test_mmhash3_unicode": [],
            "test_no_collision_on_byte_range": [],
            "test_uniform_distribution": []
        },
        "sklearn.utils.tests.test_bench": {
            "test_total_seconds": []
        },
        "sklearn.utils.tests.test_shortest_path": {
            "floyd_warshall_slow": [
                "graph",
                "directed"
            ],
            "generate_graph": [
                "N"
            ],
            "test_floyd_warshall": [],
            "test_dijkstra": [],
            "test_shortest_path": [],
            "test_dijkstra_bug_fix": []
        },
        "sklearn.utils.tests.test_testing": {
            "test_set_random_state": [],
            "test_assert_raise_message": [],
            "TestWarns": {
                "test_warn": [
                    "self"
                ],
                "test_warn_wrong_warning": [
                    "self"
                ]
            }
        },
        "sklearn.utils.tests.test_random": {
            "test_invalid_sample_without_replacement_algorithm": [],
            "test_sample_without_replacement_algorithms": [],
            "check_edge_case_of_sample_int": [
                "sample_without_replacement"
            ],
            "check_sample_int": [
                "sample_without_replacement"
            ],
            "check_sample_int_distribution": [
                "sample_without_replacement"
            ]
        },
        "sklearn.utils.tests.test_fixes": {
            "test_in1d": [],
            "test_divide": [],
            "test_copysign": []
        },
        "sklearn.utils.tests": {},
        "sklearn.externals.six": {
            "_add_doc": [
                "func",
                "doc"
            ],
            "_import_module": [
                "name"
            ],
            "add_move": [
                "move"
            ],
            "remove_move": [
                "name"
            ],
            "iterkeys": [
                "d"
            ],
            "itervalues": [
                "d"
            ],
            "iteritems": [
                "d"
            ],
            "with_metaclass": [
                "meta"
            ],
            "_LazyDescr": {
                "__init__": [
                    "self",
                    "name"
                ],
                "__get__": [
                    "self",
                    "obj",
                    "tp"
                ]
            },
            "MovedModule": {
                "__init__": [
                    "self",
                    "name",
                    "old",
                    "new"
                ],
                "_resolve": [
                    "self"
                ]
            },
            "MovedAttribute": {
                "__init__": [
                    "self",
                    "name",
                    "old_mod",
                    "new_mod",
                    "old_attr",
                    "new_attr"
                ],
                "_resolve": [
                    "self"
                ]
            },
            "_MovedItems": {}
        },
        "sklearn.externals.test_externals_setup": {},
        "sklearn.externals.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.externals": {},
        "sklearn.externals.joblib.format_stack": {
            "safe_repr": [
                "value"
            ],
            "eq_repr": [
                "value",
                "repr"
            ],
            "uniq_stable": [
                "elems"
            ],
            "fix_frame_records_filenames": [
                "records"
            ],
            "_fixed_getframes": [
                "etb",
                "context",
                "tb_offset"
            ],
            "_format_traceback_lines": [
                "lnum",
                "index",
                "lines",
                "lvals"
            ],
            "format_records": [
                "records"
            ],
            "format_exc": [
                "etype",
                "evalue",
                "etb",
                "context",
                "tb_offset"
            ],
            "format_outer_frames": [
                "context",
                "stack_start",
                "stack_end",
                "ignore_ipython"
            ]
        },
        "sklearn.externals.joblib.testing": {
            "warnings_to_stdout": []
        },
        "sklearn.externals.joblib.numpy_pickle": {
            "_read_magic": [
                "file_handle"
            ],
            "read_zfile": [
                "file_handle"
            ],
            "write_zfile": [
                "file_handle",
                "data",
                "compress"
            ],
            "dump": [
                "value",
                "filename",
                "compress",
                "cache_size"
            ],
            "load": [
                "filename",
                "mmap_mode"
            ],
            "NDArrayWrapper": {
                "__init__": [
                    "self",
                    "filename",
                    "subclass"
                ],
                "read": [
                    "self",
                    "unpickler"
                ]
            },
            "ZNDArrayWrapper": {
                "__init__": [
                    "self",
                    "filename",
                    "init_args",
                    "state"
                ],
                "read": [
                    "self",
                    "unpickler"
                ]
            },
            "NumpyPickler": {
                "__init__": [
                    "self",
                    "filename",
                    "compress",
                    "cache_size"
                ],
                "_write_array": [
                    "self",
                    "array",
                    "filename"
                ],
                "save": [
                    "self",
                    "obj"
                ],
                "close": [
                    "self"
                ]
            },
            "NumpyUnpickler": {
                "__init__": [
                    "self",
                    "filename",
                    "file_handle",
                    "mmap_mode"
                ],
                "_open_pickle": [
                    "self",
                    "file_handle"
                ],
                "load_build": [
                    "self"
                ]
            },
            "ZipNumpyUnpickler": {
                "__init__": [
                    "self",
                    "filename",
                    "file_handle"
                ],
                "_open_pickle": [
                    "self",
                    "file_handle"
                ]
            }
        },
        "sklearn.externals.joblib.parallel": {
            "cpu_count": [],
            "_verbosity_filter": [
                "index",
                "verbose"
            ],
            "delayed": [
                "function"
            ],
            "WorkerInterrupt": {},
            "SafeFunction": {
                "__init__": [
                    "self",
                    "func"
                ],
                "__call__": [
                    "self"
                ]
            },
            "ImmediateApply": {
                "__init__": [
                    "self",
                    "func",
                    "args",
                    "kwargs"
                ],
                "get": [
                    "self"
                ]
            },
            "CallBack": {
                "__init__": [
                    "self",
                    "index",
                    "parallel"
                ],
                "__call__": [
                    "self",
                    "out"
                ]
            },
            "Parallel": {
                "__init__": [
                    "self",
                    "n_jobs",
                    "verbose",
                    "pre_dispatch"
                ],
                "dispatch": [
                    "self",
                    "func",
                    "args",
                    "kwargs"
                ],
                "dispatch_next": [
                    "self"
                ],
                "_print": [
                    "self",
                    "msg",
                    "msg_args"
                ],
                "print_progress": [
                    "self",
                    "index"
                ],
                "retrieve": [
                    "self"
                ],
                "__call__": [
                    "self",
                    "iterable"
                ],
                "__repr__": [
                    "self"
                ]
            }
        },
        "sklearn.externals.joblib.logger": {
            "_squeeze_time": [
                "t"
            ],
            "format_time": [
                "t"
            ],
            "short_format_time": [
                "t"
            ],
            "Logger": {
                "__init__": [
                    "self",
                    "depth"
                ],
                "warn": [
                    "self",
                    "msg"
                ],
                "debug": [
                    "self",
                    "msg"
                ],
                "format": [
                    "self",
                    "obj",
                    "indent"
                ]
            },
            "PrintTime": {
                "__init__": [
                    "self",
                    "logfile",
                    "logdir"
                ],
                "__call__": [
                    "self",
                    "msg",
                    "total"
                ]
            }
        },
        "sklearn.externals.joblib._compat": {},
        "sklearn.externals.joblib.my_exceptions": {
            "_mk_exception": [
                "exception",
                "name"
            ],
            "_mk_common_exceptions": [],
            "JoblibException": {
                "__init__": [
                    "self",
                    "message"
                ],
                "__reduce__": [
                    "self"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "TransportableException": {
                "__init__": [
                    "self",
                    "message",
                    "etype"
                ],
                "__reduce__": [
                    "self"
                ]
            }
        },
        "sklearn.externals.joblib.func_inspect": {
            "get_func_code": [
                "func"
            ],
            "_clean_win_chars": [
                "string"
            ],
            "get_func_name": [
                "func",
                "resolv_alias",
                "win_characters"
            ],
            "filter_args": [
                "func",
                "ignore_lst",
                "args",
                "kwargs"
            ]
        },
        "sklearn.externals.joblib.disk": {
            "disk_used": [
                "path"
            ],
            "memstr_to_kbytes": [
                "text"
            ],
            "mkdirp": [
                "d"
            ],
            "rm_subdirs": [
                "path",
                "onerror"
            ]
        },
        "sklearn.externals.joblib.memory": {
            "extract_first_line": [
                "func_code"
            ],
            "JobLibCollisionWarning": {},
            "MemorizedFunc": {
                "__init__": [
                    "self",
                    "func",
                    "cachedir",
                    "ignore",
                    "mmap_mode",
                    "compress",
                    "verbose",
                    "timestamp"
                ],
                "__call__": [
                    "self"
                ],
                "__reduce__": [
                    "self"
                ],
                "_get_func_dir": [
                    "self",
                    "mkdir"
                ],
                "get_output_dir": [
                    "self"
                ],
                "_write_func_code": [
                    "self",
                    "filename",
                    "func_code",
                    "first_line"
                ],
                "_check_previous_func_code": [
                    "self",
                    "stacklevel"
                ],
                "clear": [
                    "self",
                    "warn"
                ],
                "call": [
                    "self"
                ],
                "format_call": [
                    "self"
                ],
                "format_signature": [
                    "self",
                    "func"
                ],
                "_persist_output": [
                    "self",
                    "output",
                    "dir"
                ],
                "_persist_input": [
                    "self",
                    "output_dir"
                ],
                "load_output": [
                    "self",
                    "output_dir"
                ],
                "__repr__": [
                    "self"
                ]
            },
            "Memory": {
                "__init__": [
                    "self",
                    "cachedir",
                    "mmap_mode",
                    "compress",
                    "verbose"
                ],
                "cache": [
                    "self",
                    "func",
                    "ignore",
                    "verbose",
                    "mmap_mode"
                ],
                "clear": [
                    "self",
                    "warn"
                ],
                "eval": [
                    "self",
                    "func"
                ],
                "__repr__": [
                    "self"
                ],
                "__reduce__": [
                    "self"
                ]
            }
        },
        "sklearn.externals.joblib.hashing": {
            "hash": [
                "obj",
                "hash_name",
                "coerce_mmap"
            ],
            "_ConsistentSet": {
                "__init__": [
                    "self",
                    "set_sequence"
                ]
            },
            "_MyHash": {
                "__init__": [
                    "self"
                ]
            },
            "Hasher": {
                "__init__": [
                    "self",
                    "hash_name"
                ],
                "hash": [
                    "self",
                    "obj",
                    "return_digest"
                ],
                "save": [
                    "self",
                    "obj"
                ],
                "save_global": [
                    "self",
                    "obj",
                    "name",
                    "pack"
                ],
                "_batch_setitems": [
                    "self",
                    "items"
                ],
                "save_set": [
                    "self",
                    "set_items"
                ]
            },
            "NumpyHasher": {
                "__init__": [
                    "self",
                    "hash_name",
                    "coerce_mmap"
                ],
                "save": [
                    "self",
                    "obj"
                ]
            }
        },
        "sklearn.externals.joblib": {},
        "sklearn.externals.joblib.test.test_hashing": {
            "time_func": [
                "func"
            ],
            "relative_time": [
                "func1",
                "func2"
            ],
            "test_trival_hash": [],
            "test_hash_methods": [],
            "test_hash_numpy": [],
            "test_hash_memmap": [],
            "test_hash_numpy_performance": [],
            "test_bound_methods_hash": [],
            "test_bound_cached_methods_hash": [],
            "test_hash_object_dtype": [],
            "test_numpy_scalar": [],
            "test_dict_hash": [],
            "test_set_hash": [],
            "Klass": {
                "f": [
                    "self",
                    "x"
                ]
            },
            "KlassWithCachedMethod": {
                "__init__": [
                    "self"
                ],
                "f": [
                    "self",
                    "x"
                ]
            }
        },
        "sklearn.externals.joblib.test.common": {},
        "sklearn.externals.joblib.test.test_disk": {
            "test_disk_used": [],
            "test_memstr_to_kbytes": [],
            "test_mkdirp": []
        },
        "sklearn.externals.joblib.test.test_func_inspect": {
            "f": [
                "x",
                "y"
            ],
            "f2": [
                "x"
            ],
            "g": [
                "x"
            ],
            "h": [
                "x",
                "y"
            ],
            "i": [
                "x"
            ],
            "j": [
                "x",
                "y"
            ],
            "k": [],
            "test_filter_args": [],
            "test_filter_args_method": [],
            "test_filter_varargs": [],
            "test_filter_kwargs": [],
            "test_filter_args_2": [],
            "test_func_name": [],
            "test_func_inspect_errors": [],
            "test_bound_methods": [],
            "test_filter_args_error_msg": [],
            "test_clean_win_chars": [],
            "Klass": {
                "f": [
                    "self",
                    "x"
                ]
            }
        },
        "sklearn.externals.joblib.test.test_memory": {
            "f": [
                "x",
                "y"
            ],
            "setup_module": [],
            "_rmtree_onerror": [
                "func",
                "path",
                "excinfo"
            ],
            "teardown_module": [],
            "check_identity_lazy": [
                "func",
                "accumulator"
            ],
            "test_memory_integration": [],
            "test_no_memory": [],
            "test_memory_kwarg": [],
            "test_memory_lambda": [],
            "test_memory_name_collision": [],
            "test_memory_warning_lambda_collisions": [],
            "test_memory_warning_collision_detection": [],
            "test_memory_partial": [],
            "test_memory_eval": [],
            "count_and_append": [
                "x"
            ],
            "test_argument_change": [],
            "test_memory_numpy": [],
            "test_memory_exception": [],
            "test_memory_ignore": [],
            "test_func_dir": [],
            "test_persistence": [],
            "test_format_signature": [],
            "test_format_signature_numpy": []
        },
        "sklearn.externals.joblib.test.test_numpy_pickle": {
            "_function": [
                "x"
            ],
            "setup_module": [],
            "teardown_module": [],
            "test_standard_types": [],
            "test_value_error": [],
            "test_numpy_persistence": [],
            "test_memmap_persistence": [],
            "test_masked_array_persistence": [],
            "test_z_file": [],
            "test_numpy_subclass": [],
            "_class": {
                "_method": [
                    "self"
                ]
            },
            "_newclass": {
                "_method": [
                    "self"
                ]
            }
        },
        "sklearn.externals.joblib.test.test_my_exceptions": {
            "test_inheritance": []
        },
        "sklearn.externals.joblib.test.test_format_stack": {
            "test_safe_repr": [],
            "Vicious": {
                "__repr__": [
                    "self"
                ]
            }
        },
        "sklearn.externals.joblib.test.test_logger": {
            "setup": [],
            "teardown": [],
            "test_print_time": []
        },
        "sklearn.externals.joblib.test": {},
        "sklearn.externals.joblib.test.test_parallel": {
            "division": [
                "x",
                "y"
            ],
            "square": [
                "x"
            ],
            "exception_raiser": [
                "x"
            ],
            "interrupt_raiser": [
                "x"
            ],
            "f": [
                "x",
                "y",
                "z"
            ],
            "test_cpu_count": [],
            "test_simple_parallel": [],
            "nested_loop": [],
            "test_nested_loop": [],
            "test_parallel_kwargs": [],
            "test_parallel_pickling": [],
            "test_error_capture": [],
            "consumer": [
                "queue",
                "item"
            ],
            "test_dispatch_one_job": [],
            "test_dispatch_multiprocessing": [],
            "test_exception_dispatch": [],
            "_reload_joblib": [],
            "test_multiple_spawning": [],
            "test_joblib_exception": [],
            "test_safe_function": [],
            "Counter": {
                "__init__": [
                    "self",
                    "list1",
                    "list2"
                ],
                "__call__": [
                    "self",
                    "i"
                ]
            }
        },
        "sklearn.datasets.twenty_newsgroups": {
            "download_20newsgroups": [
                "target_dir",
                "cache_path"
            ],
            "strip_newsgroup_header": [
                "text"
            ],
            "strip_newsgroup_quoting": [
                "text"
            ],
            "strip_newsgroup_footer": [
                "text"
            ],
            "fetch_20newsgroups": [
                "data_home",
                "subset",
                "categories",
                "shuffle",
                "random_state",
                "remove",
                "download_if_missing"
            ],
            "fetch_20newsgroups_vectorized": [
                "subset",
                "remove",
                "data_home"
            ]
        },
        "sklearn.datasets.mldata": {
            "mldata_filename": [
                "dataname"
            ],
            "fetch_mldata": [
                "dataname",
                "target_name",
                "data_name",
                "transpose_data",
                "data_home"
            ],
            "setup_module": [
                "module"
            ],
            "teardown_module": [
                "module"
            ]
        },
        "sklearn.datasets.lfw": {
            "scale_face": [
                "face"
            ],
            "check_fetch_lfw": [
                "data_home",
                "funneled",
                "download_if_missing"
            ],
            "_load_imgs": [
                "file_paths",
                "slice_",
                "color",
                "resize"
            ],
            "_fetch_lfw_people": [
                "data_folder_path",
                "slice_",
                "color",
                "resize",
                "min_faces_per_person"
            ],
            "fetch_lfw_people": [
                "data_home",
                "funneled",
                "resize",
                "min_faces_per_person",
                "color",
                "slice_",
                "download_if_missing"
            ],
            "_fetch_lfw_pairs": [
                "index_file_path",
                "data_folder_path",
                "slice_",
                "color",
                "resize"
            ],
            "load_lfw_people": [
                "download_if_missing"
            ],
            "fetch_lfw_pairs": [
                "subset",
                "data_home",
                "funneled",
                "resize",
                "color",
                "slice_",
                "download_if_missing"
            ],
            "load_lfw_pairs": [
                "download_if_missing"
            ]
        },
        "sklearn.datasets.mlcomp": {
            "_load_document_classification": [
                "dataset_path",
                "metadata",
                "set_"
            ],
            "load_mlcomp": [
                "name_or_id",
                "set_",
                "mlcomp_root"
            ]
        },
        "sklearn.datasets.california_housing": {
            "fetch_california_housing": [
                "data_home",
                "download_if_missing"
            ]
        },
        "sklearn.datasets.species_distributions": {
            "_load_coverage": [
                "F",
                "header_length",
                "dtype"
            ],
            "_load_csv": [
                "F"
            ],
            "construct_grids": [
                "batch"
            ],
            "fetch_species_distributions": [
                "data_home",
                "download_if_missing"
            ]
        },
        "sklearn.datasets.base": {
            "get_data_home": [
                "data_home"
            ],
            "clear_data_home": [
                "data_home"
            ],
            "load_files": [
                "container_path",
                "description",
                "categories",
                "load_content",
                "shuffle",
                "encoding",
                "charset",
                "charset_error",
                "decode_error",
                "random_state"
            ],
            "load_iris": [],
            "load_digits": [
                "n_class"
            ],
            "load_diabetes": [],
            "load_linnerud": [],
            "load_boston": [],
            "load_sample_images": [],
            "load_sample_image": [
                "image_name"
            ],
            "Bunch": {
                "__init__": [
                    "self"
                ]
            }
        },
        "sklearn.datasets.covtype": {
            "fetch_covtype": [
                "data_home",
                "download_if_missing",
                "random_state",
                "shuffle"
            ],
            "_mkdirp": [
                "d"
            ]
        },
        "sklearn.datasets.setup": {
            "configuration": [
                "parent_package",
                "top_path"
            ]
        },
        "sklearn.datasets.olivetti_faces": {
            "fetch_olivetti_faces": [
                "data_home",
                "shuffle",
                "random_state",
                "download_if_missing"
            ]
        },
        "sklearn.datasets": {},
        "sklearn.datasets.samples_generator": {
            "make_classification": [
                "n_samples",
                "n_features",
                "n_informative",
                "n_redundant",
                "n_repeated",
                "n_classes",
                "n_clusters_per_class",
                "weights",
                "flip_y",
                "class_sep",
                "hypercube",
                "shift",
                "scale",
                "shuffle",
                "random_state"
            ],
            "make_multilabel_classification": [
                "n_samples",
                "n_features",
                "n_classes",
                "n_labels",
                "length",
                "allow_unlabeled",
                "return_indicator",
                "random_state"
            ],
            "make_hastie_10_2": [
                "n_samples",
                "random_state"
            ],
            "make_regression": [
                "n_samples",
                "n_features",
                "n_informative",
                "n_targets",
                "bias",
                "effective_rank",
                "tail_strength",
                "noise",
                "shuffle",
                "coef",
                "random_state"
            ],
            "make_circles": [
                "n_samples",
                "shuffle",
                "noise",
                "random_state",
                "factor"
            ],
            "make_moons": [
                "n_samples",
                "shuffle",
                "noise",
                "random_state"
            ],
            "make_blobs": [
                "n_samples",
                "n_features",
                "centers",
                "cluster_std",
                "center_box",
                "shuffle",
                "random_state"
            ],
            "make_friedman1": [
                "n_samples",
                "n_features",
                "noise",
                "random_state"
            ],
            "make_friedman2": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_friedman3": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_low_rank_matrix": [
                "n_samples",
                "n_features",
                "effective_rank",
                "tail_strength",
                "random_state"
            ],
            "make_sparse_coded_signal": [
                "n_samples",
                "n_components",
                "n_features",
                "n_nonzero_coefs",
                "random_state"
            ],
            "make_sparse_uncorrelated": [
                "n_samples",
                "n_features",
                "random_state"
            ],
            "make_spd_matrix": [
                "n_dim",
                "random_state"
            ],
            "make_sparse_spd_matrix": [
                "dim",
                "alpha",
                "norm_diag",
                "smallest_coef",
                "largest_coef",
                "random_state"
            ],
            "make_swiss_roll": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_s_curve": [
                "n_samples",
                "noise",
                "random_state"
            ],
            "make_gaussian_quantiles": [
                "mean",
                "cov",
                "n_samples",
                "n_features",
                "n_classes",
                "shuffle",
                "random_state"
            ],
            "_shuffle": [
                "data",
                "random_state"
            ],
            "make_biclusters": [
                "shape",
                "n_clusters",
                "noise",
                "minval",
                "maxval",
                "shuffle",
                "random_state"
            ],
            "make_checkerboard": [
                "shape",
                "n_clusters",
                "noise",
                "minval",
                "maxval",
                "shuffle",
                "random_state"
            ]
        },
        "sklearn.datasets.svmlight_format": {
            "load_svmlight_file": [
                "f",
                "n_features",
                "dtype",
                "multilabel",
                "zero_based",
                "query_id"
            ],
            "_gen_open": [
                "f"
            ],
            "_open_and_load": [
                "f",
                "dtype",
                "multilabel",
                "zero_based",
                "query_id"
            ],
            "load_svmlight_files": [
                "files",
                "n_features",
                "dtype",
                "multilabel",
                "zero_based",
                "query_id"
            ],
            "_dump_svmlight": [
                "X",
                "y",
                "f",
                "one_based",
                "comment",
                "query_id"
            ],
            "dump_svmlight_file": [
                "X",
                "y",
                "f",
                "zero_based",
                "comment",
                "query_id"
            ]
        },
        "sklearn.datasets.tests.test_base": {
            "_remove_dir": [
                "path"
            ],
            "teardown_module": [],
            "setup_load_files": [],
            "teardown_load_files": [],
            "test_data_home": [],
            "test_default_empty_load_files": [],
            "test_default_load_files": [],
            "test_load_files_w_categories_desc_and_encoding": [],
            "test_load_files_wo_load_content": [],
            "test_load_sample_images": [],
            "test_load_digits": [],
            "test_load_digits_n_class_lt_10": [],
            "test_load_sample_image": [],
            "test_load_missing_sample_image_error": [],
            "test_load_diabetes": [],
            "test_load_linnerud": [],
            "test_load_iris": [],
            "test_load_boston": []
        },
        "sklearn.datasets.tests.test_covtype": {
            "fetch": [],
            "test_fetch": []
        },
        "sklearn.datasets.tests.test_lfw": {
            "setup_module": [],
            "teardown_module": [],
            "test_load_empty_lfw_people": [],
            "test_load_fake_lfw_people": [],
            "test_load_fake_lfw_people_too_restrictive": [],
            "test_load_empty_lfw_pairs": [],
            "test_load_fake_lfw_pairs": []
        },
        "sklearn.datasets.tests.test_mldata": {
            "setup_tmpdata": [],
            "teardown_tmpdata": [],
            "test_mldata_filename": [],
            "test_download": [],
            "test_fetch_one_column": [],
            "test_fetch_multiple_column": []
        },
        "sklearn.datasets.tests.test_samples_generator": {
            "test_make_classification": [],
            "test_make_multilabel_classification": [],
            "test_make_multilabel_classification_return_indicator": [],
            "test_make_hastie_10_2": [],
            "test_make_regression": [],
            "test_make_regression_multitarget": [],
            "test_make_blobs": [],
            "test_make_friedman1": [],
            "test_make_friedman2": [],
            "test_make_friedman3": [],
            "test_make_low_rank_matrix": [],
            "test_make_sparse_coded_signal": [],
            "test_make_sparse_uncorrelated": [],
            "test_make_spd_matrix": [],
            "test_make_swiss_roll": [],
            "test_make_s_curve": [],
            "test_make_biclusters": [],
            "test_make_checkerboard": []
        },
        "sklearn.datasets.tests.test_20news": {
            "test_20news": [],
            "test_20news_vectorized": []
        },
        "sklearn.datasets.tests.test_svmlight_format": {
            "test_load_svmlight_file": [],
            "test_load_svmlight_file_fd": [],
            "test_load_svmlight_file_multilabel": [],
            "test_load_svmlight_files": [],
            "test_load_svmlight_file_n_features": [],
            "test_load_compressed": [],
            "test_load_invalid_file": [],
            "test_load_invalid_order_file": [],
            "test_load_zero_based": [],
            "test_load_zero_based_auto": [],
            "test_load_with_qid": [],
            "test_load_invalid_file2": [],
            "test_not_a_filename": [],
            "test_invalid_filename": [],
            "test_dump": [],
            "test_dump_concise": [],
            "test_dump_comment": [],
            "test_dump_invalid": [],
            "test_dump_query_id": []
        },
        "sklearn.datasets.tests": {},
        "doc.sphinxext.numpy_ext.docscrape_sphinx": {
            "get_doc_object": [
                "obj",
                "what",
                "doc",
                "config"
            ],
            "SphinxDocString": {
                "__init__": [
                    "self",
                    "docstring",
                    "config"
                ],
                "_str_header": [
                    "self",
                    "name",
                    "symbol"
                ],
                "_str_field_list": [
                    "self",
                    "name"
                ],
                "_str_indent": [
                    "self",
                    "doc",
                    "indent"
                ],
                "_str_signature": [
                    "self"
                ],
                "_str_summary": [
                    "self"
                ],
                "_str_extended_summary": [
                    "self"
                ],
                "_str_param_list": [
                    "self",
                    "name"
                ],
                "_obj": [
                    "self"
                ],
                "_str_member_list": [
                    "self",
                    "name"
                ],
                "_str_section": [
                    "self",
                    "name"
                ],
                "_str_see_also": [
                    "self",
                    "func_role"
                ],
                "_str_warnings": [
                    "self"
                ],
                "_str_index": [
                    "self"
                ],
                "_str_references": [
                    "self"
                ],
                "_str_examples": [
                    "self"
                ],
                "__str__": [
                    "self",
                    "indent",
                    "func_role"
                ]
            },
            "SphinxFunctionDoc": {
                "__init__": [
                    "self",
                    "obj",
                    "doc",
                    "config"
                ]
            },
            "SphinxClassDoc": {
                "__init__": [
                    "self",
                    "obj",
                    "doc",
                    "func_doc",
                    "config"
                ]
            },
            "SphinxObjDoc": {
                "__init__": [
                    "self",
                    "obj",
                    "doc",
                    "config"
                ]
            }
        },
        "doc.sphinxext.numpy_ext": {},
        "scikits": {},
        "scikits.learn.lda": {},
        "scikits.learn.neighbors": {},
        "scikits.learn.label_propagation": {},
        "scikits.learn.ball_tree": {},
        "scikits.learn.cross_val": {},
        "scikits.learn.base": {},
        "scikits.learn.qda": {},
        "scikits.learn.naive_bayes": {},
        "scikits.learn.grid_search": {},
        "scikits.learn": {},
        "scikits.learn.pipeline": {}
    }
}